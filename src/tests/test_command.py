"""Test the commands of the REPL."""
import unittest
from typing import Dict, Tuple, Union, cast
from unittest.mock import MagicMock

import core.command as command
import core.command_data as command_data
from core.command import Options
from core.error_messages import ReplErrors
from core.log import Log
from graph.control_flow_graph import ControlFlowGraph as CFG
from graph.graph import EdgeListGraph, EdgeListType
from tests.unit_utils import captured_output, get_second_test_graph, get_test_graph

# pylint does not understand decorators :(
# pylint: disable=no-value-for-parameter
# pylint: disable=too-many-public-methods
# pylint: disable=fixme
# pylint: disable=unused-variable


class TestController(unittest.TestCase):
    """Test the methods of the Controller object."""

    def setUp(self) -> None:
        """Create a new instance of the Controller."""
        self.controller = command.Controller(Log(display_output=False))

    def test_graph_generator_names(self) -> None:
        """Check that we can get the names of all the files we can convert."""
        names = self.controller.get_graph_generator_names()
        expected_names = [".cpp", ".c", ".jar", ".class", ".java", ".py"]
        self.assertEqual(list(names), expected_names)

    def test_get_graph_generator(self) -> None:
        """Check that we can get the converter from the file extension."""
        converter = self.controller.get_graph_generator(".py")
        self.assertEqual(converter.name(), "Python")


class TestCommandMultithreading(unittest.TestCase):
    """Test the multithreading implementation of the command object."""

    def test_init(self) -> None:
        """Test the initialization with multithreading."""
        with captured_output() as (out, err):
            command.Command("", False, True, None)
        expected_msg = "MULTITHREADING ENABLED"
        self.assertTrue(expected_msg in out.getvalue())
        self.assertTrue(len(err.getvalue().strip()) == 0)


class TestCommandKlee(unittest.TestCase):
    """This class is used to test all klee-related commands given valid inputs."""

    def setUp(self) -> None:
        """
        Create a new instance of the command object without the wrapping object.

        Note that in these tests we use the Command object directly.
        """
        self.command = command.Command("", False, False, None)
        self.opts = Options()

    # ==== do_to_klee_format =====
    def test_to_klee_format_valid(self) -> None:
        """Verify that we can convert a valid file to a KLEE-compatible format."""
        with captured_output() as (out, err):
            self.command.do_to_klee_format(self.opts, "examplefile.c")
        self.assertTrue(len(err.getvalue()) == 0)

    # ==== Test do_klee_to_bc =====
    def test_klee_to_bc(self) -> None:
        """See if we can convert a klee formatted file to a .bc file."""
        with captured_output() as (out, err):
            pass
        self.assertTrue(len(err.getvalue()) == 0)

    # ==== Test do_klee_replay ====
    def test_klee_replay_valid(self) -> None:
        """Verify that tests can be replayed given a valid test file generated by KLEE."""
        with captured_output() as (out, err):
            self.command.do_klee_replay(self.opts, "samplefile.ktest")
        self.assertTrue(len(err.getvalue()) == 0)


class TestCommand(unittest.TestCase):
    """Test each command with valid inputs."""

    valid_commands: Dict[str, Tuple[int, Union[float, int]]] = {}

    def setUp(self) -> None:
        """
        Create a new instance of the Command object without the wrapping object.

        Note that in these tests we use the Command object directly.
        """
        # self.patcher = patch("core.command.Data")
        # self.addCleanup(self.patcher.stop)
        # self.mock_data = self.patcher.start()

        self.command = command.Command(curr_path="/app/code/tests/dotFiles", debug_mode=False,
                                       multi_threaded=False, repl_wrapper=None)
        self.command.logger = Log(display_output=False)
        self.command.data = MagicMock()
        self.opts = Options()

    # === Test do_import ===
    def test_import_single_threaded(self) -> None:
        """."""
        # TODO Patch in CFG.from_file and assert everything was called.
        self.command.get_files = MagicMock(name="get_files", return_value=[""])  # type: ignore
        self.command.do_import(Options())

    def test_import_multi_threaded(self) -> None:
        """."""
        # TODO: this

    # === Test verify_file_type ===
    def test_verify_file_type_no_ext(self) -> None:
        """Check that we get None when checking the extension for a file without an extension."""
        res = self.command.verify_file_type("foo", "desired_ext")
        self.assertIsNone(res)

    def test_verify_file_type_incorrect(self) -> None:
        """Check that we get None when the file does not have desired extension."""
        res = self.command.verify_file_type("foo.c", "desired_ext")
        self.assertIsNone(res)

    def test_verify_file_type_correct(self) -> None:
        """Check that we get the filename when it has the desired extension."""
        res = self.command.verify_file_type("foo.c", "c")
        self.assertEqual(res, "foo.c")

    # === Test do_export ===
    def test_export_graph(self) -> None:
        """Verify that the proper exporter is called when trying to export a graph."""
        self.command.do_export(self.opts, command_data.ObjTypes.GRAPH.value, "foo")
        self.command.data.export_graph.assert_called_once()  # type: ignore

    def test_export_metric(self) -> None:
        """Verify that the proper exporter is called when trying to export a metric."""
        self.command.do_export(self.opts, command_data.ObjTypes.METRIC.value, "foo")
        self.command.data.export_metrics.assert_called_once()  # type: ignore

    def test_export_klee(self) -> None:
        """Verify that the proper exporter is called when trying to export various klee objects."""
        self.command.do_export(self.opts, command_data.ObjTypes.KLEE_BC.value, "foo")
        self.command.data.export_bc.assert_called_once()  # type: ignore

        self.command.do_export(self.opts, command_data.ObjTypes.KLEE_FILE.value, "foo")
        self.command.data.export_klee_file.assert_called_once()  # type: ignore

        self.command.do_export(self.opts, command_data.ObjTypes.KLEE_STATS.value, "foo")
        self.command.data.export_klee_stats.assert_called_once()  # type: ignore

    def test_export_klee_all(self) -> None:
        """Verify that the proper exporters are called when trying to export all klee objects at once."""
        self.command.do_export(self.opts, command_data.ObjTypes.KLEE.value, "foo")
        self.command.data.export_klee_file.assert_called_once()  # type: ignore
        self.command.data.export_klee_stats.assert_called_once()  # type: ignore
        self.command.data.export_bc.assert_called_once()  # type: ignore

    def test_export_invalid(self) -> None:
        """Test that we get an error message when trying to export a type that does not exist."""
        self.command.logger = MagicMock()
        self.command.do_export(self.opts, "Gabe", "foo")
        self.command.logger.e_msg.assert_called_once()

    # === Test parse_convert_args ===

    def test_parse_convert_args_recursive(self) -> None:
        """Verify that passing recursive flag creates the correct options object."""
        expected_opts = Options(recursive_mode=True)
        res, opts = self.command.parse_convert_args(['-r', "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

        res, opts = self.command.parse_convert_args(['--recursive', "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

    def test_parse_convert_args_inline(self) -> None:
        """Verify that passing inline flag creates the correct options object."""
        expected_opts = Options(inline_type=command.InlineType.Inline)
        res, opts = self.command.parse_convert_args(["-i", "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

        res, opts = self.command.parse_convert_args(["--inline_functions", "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

    def test_parse_convert_args_heuristic(self) -> None:
        """Verify that passing heuristic inline flag creates the correct options object."""
        expected_opts = Options(inline_type=command.InlineType.Heuristic)
        res, opts = self.command.parse_convert_args(["-h", "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

        res, opts = self.command.parse_convert_args(["--heuristic_inline", "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

    def test_parse_convert_args_stitching(self) -> None:
        """Verify that passing inline flag creates the correct options object."""
        expected_opts = Options(graph_stitching=True)
        res, opts = self.command.parse_convert_args(["-gs", "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

        res, opts = self.command.parse_convert_args(["--graph_stitch", "rest"])
        self.assertEqual(opts, expected_opts)
        self.assertEqual(res, ["rest"])

    def test_parse_convert_args_no_args(self) -> None:
        """Verify that passing no params does not return any flags."""
        res, opts = self.command.parse_convert_args([])
        self.assertTrue(len(res) == 0)
        self.assertEqual(opts, Options())

    def test_parse_convert_args_no_flags(self) -> None:
        """Verify that passing no flags creates the correct options object."""
        res, opts = self.command.parse_convert_args(["rest"])
        self.assertTrue(len(res) == 1)
        self.assertEqual(opts, Options())

    # === Test do_quit ===
    # pylint: disable=E1121
    def test_quit(self) -> None:
        """Check that exiting the REPL works."""
        with self.assertRaises(SystemExit):
            self.command.do_quit(self.opts)

    # === directory functions. ===
    # pylint: disable=E1121
    def test_directories(self) -> None:
        """Check that all functions related to working with directories work."""
        self.command.logger._display_output = True
        with captured_output() as (out, err):
            self.command.do_pwd(self.opts)

        self.assertTrue("/app/code/tests/dotFiles" in out.getvalue())

        with captured_output() as (out, err):
            self.command.do_ls(self.opts)

        expected_files = ["dotTest.dot", "testgraph.dot", "testsimple.dot"]
        self.assertTrue(all(check_file in out.getvalue() for check_file in expected_files))

        with captured_output() as (out, err):
            self.command.do_cd(self.opts, "/app/code/tests/")
            out.truncate(0)
            out.seek(0)
            self.command.do_pwd(self.opts)

        self.assertTrue("/app/code/tests" in out.getvalue())
        self.assertTrue(len(err.getvalue()) == 0)

    # === Test do_metrics ===
    def test_do_metrics_invalid(self) -> None:
        """Verify that do_metrics does not err on nonexistant graph."""
        self.command.logger = MagicMock()
        self.command.do_metrics(self.opts, "invalid_graphname")
        self.command.logger.e_msg.assert_called_once()

    def test_do_metrics_valid(self) -> None:
        """Compute metrics for stored graphs."""
        metric_mock_1, metric_mock_2 = MagicMock(), MagicMock()

        metric_mock_1.name.return_value = 'Metric1'
        metric_mock_2.name.return_value = 'Metric2'

        self.command.data.graphs = {"foo": CFG(get_test_graph()), "other": CFG(get_second_test_graph())}
        self.command.controller.metrics_generators = [metric_mock_1, metric_mock_2]

        self.command.do_metrics(self.opts, "foo")
        metric_mock_1.name.assert_called()
        metric_mock_2.name.assert_called()

    # ==== Test do_show =====
    def test_show_invalid_type(self) -> None:
        """
        Test show command with inexistant object type.

        Verify that we get the correct error when we try to call show for
        a nonexistant object.
        """
        with captured_output() as (out, err):
            self.command.logger = MagicMock()
            self.command.do_show(self.opts, "", "foo")
            self.command.logger.e_msg.assert_called_once_with(ReplErrors.UNRECOGNIZED_TYPE)

    def test_show_metric_valid(self) -> None:
        """
        Check show command with metric of a specific name.

        Verify that calling the show command with a valid metric name will
        display the metric value in the REPL.
        """
        self.command.do_show(self.opts, command_data.ObjTypes.METRIC.value, "foo")
        self.command.data.show_metric.assert_called_once()  # type: ignore

    def test_show_graph_valid(self) -> None:
        """
        Check show command with a graph of specific name.

        Verify that we get the correct output graph if we call the show function
        for a valid graph name.
        """
        self.command.do_show(self.opts, command_data.ObjTypes.GRAPH.value, "foo")
        self.command.data.show_graphs.assert_called_once()  # type: ignore

    def test_show_klee(self) -> None:
        """Check that we can show klee objects."""
        self.command.do_show(self.opts, command_data.ObjTypes.KLEE_BC.value, "foo")
        self.command.data.show_klee_bc.assert_called_once()  # type: ignore

        self.command.do_show(self.opts, command_data.ObjTypes.KLEE_FILE.value, "foo")
        self.command.data.show_klee_files.assert_called_once()  # type: ignore

        self.command.do_show(self.opts, command_data.ObjTypes.KLEE_STATS.value, "foo")
        self.command.data.show_klee_stats.assert_called_once()  # type: ignore

        self.command.do_show(self.opts, command_data.ObjTypes.KLEE.value, "foo")
        self.command.data.show_klee.assert_called_once()  # type: ignore

    def test_show_all_types_valid(self) -> None:
        """
        Check show command with wildcard operator for type.

        Verify that we can use the wildcard operator to show all objects (objects
        of all types) for a given name.
        """
        # TODO

    def test_show_all_names_valid(self) -> None:
        """
        Check show command with wildcard operator for name.

        Verify that we can use the wildcard operator to show all objects
        of a given type.
        """
        # TODO

    # ==== Test do_list =====
    def test_list_graphs(self) -> None:
        """
        Check list command with graph type argument.

        Verify that calling list with graph type displays all of the graphs the
        REPL knows about.
        """
        self.command.do_list(self.opts, command_data.ObjTypes.GRAPH.value)
        self.command.data.list_graphs.assert_called_once()  # type: ignore

    def test_list_metrics(self) -> None:
        """
        Check list command with metric type argument.

        Verify that calling list with metric type displays all of the metrics the
        REPL knows about.
        """
        self.command.do_list(self.opts, command_data.ObjTypes.METRIC.value)
        self.command.data.list_metrics.assert_called_once()  # type: ignore

    def test_list_klee(self) -> None:
        """Check list command with klee arguments."""
        self.command.do_list(self.opts, command_data.ObjTypes.KLEE_BC.value)
        self.command.data.list_klee_bc.assert_called_once()  # type: ignore

        self.command.do_list(self.opts, command_data.ObjTypes.KLEE_STATS.value)
        self.command.data.list_klee_stats.assert_called_once()  # type: ignore

        self.command.do_list(self.opts, command_data.ObjTypes.KLEE_FILE.value)
        self.command.data.list_klee_files.assert_called_once()  # type: ignore

        self.command.do_list(self.opts, command_data.ObjTypes.KLEE.value)
        self.command.data.list_klee.assert_called_once()  # type: ignore

    def test_list_all(self) -> None:
        """
        Check list with wildcard.

        Verify that we can use the wildcard operator to list objects of all types through
        the list command.
        """
        self.command.do_list(self.opts, command_data.ObjTypes.ALL.value)
        self.command.data.list_metrics.assert_called_once()  # type: ignore
        self.command.data.list_graphs.assert_called_once()  # type: ignore
        self.command.data.list_klee.assert_called_once()  # type: ignore

    def test_list_invalid_type(self) -> None:
        """
        Test list command with invalid type.

        Verify that if we pass in an object type that does not exist, the list command
        will show the correct error.
        """
        with captured_output() as (out, err):
            self.command.logger = MagicMock()
            self.command.do_list(self.opts, "")
            self.command.logger.e_msg.assert_called_once_with(ReplErrors.UNRECOGNIZED_TYPE)

    # ==== Test do_delete ======
    def test_delete_graph_valid(self) -> None:
        """
        Check delete graph.

        Verify that if we call the delete command with the name of a Graph that the REPL
        knows about, that Graph will be deleted from the REPL.
        """
        with captured_output() as (out, err):
            obj_type = command.ObjTypes.GRAPH
            obj_name = "sample_graph"
            self.command.data.graphs['sample_graph'] = CFG(EdgeListGraph(cast(EdgeListType, []), 1))
            self.command.data.graphs['sample_graph'] = CFG(EdgeListGraph(cast(EdgeListType, []), 1))
            self.command.data.metrics['sample_graph'] = [('abc', 1)]
            self.command.do_delete(self.opts, str(obj_type), str(obj_name))

    def test_delete_metric_valid(self) -> None:
        """
        Check delete metric.

        Verify that if we call the delete command with the name of a Graph that the REPL does
        not know about, we get the correct error.
        """
        with captured_output() as (out, err):
            obj_type = command.ObjTypes.METRIC
            obj_name = "sample_metric"
            graph = CFG(EdgeListGraph(cast(EdgeListType, []), 1))
            self.command.data.metrics['sample_metric'] = [('foo', 1)]
            self.command.data.metrics['sample_metric'] = [('bar', 1)]
            self.command.data.graphs['sample_metric'] = graph
            self.command.do_delete(self.opts, str(obj_type), str(obj_name))

    def test_delete_all_types_valid(self) -> None:
        """
        Check wildcard in delete.

        Verify that we can use the wildcard operator with the delete command to delete objects all
        all types matching a given name.
        """
        with captured_output() as (out, err):
            obj_type = command.ObjTypes.ALL
            obj_name = "sample_name"
            graph = CFG(EdgeListGraph(cast(EdgeListType, []), 1))
            self.command.data.graphs['sample_name'] = graph
            self.command.data.metrics['sample_name'] = [('foo', 1)]

            self.command.data.graphs['sample_name'] = graph
            self.command.data.metrics['sample_name'] = [('b', 1)]
            self.command.do_delete(self.opts, str(obj_type), str(obj_name))

    def test_delete_all_names_valid(self) -> None:
        """Verify that we can use the wildcard operator to delete all objects of a given type."""
        with captured_output() as (out, err):
            # Delete * name
            obj_type = command.ObjTypes.GRAPH
            obj_name = "*"
            self.command.data.graphs['sample_name'] = CFG(EdgeListGraph(cast(EdgeListType, []), 1))
            self.command.data.graphs['sample_name'] = CFG(EdgeListGraph(cast(EdgeListType, []), 1))
            self.command.data.graphs['sample_name'] = CFG(EdgeListGraph(cast(EdgeListType, []), 1))
            self.command.data.metrics['sample_name'] = [("123", 1)]

            self.command.do_delete(self.opts, str(obj_type), str(obj_name))


if __name__ == '__main__':
    unittest.main()
