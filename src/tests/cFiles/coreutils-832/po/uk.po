# Ukrainian translation for coreutils.
# Copyright (C) 2006 Free Software Foundation, Inc.
# This file is put in the public domain.
#
# Maxim Dziumanenko <dziumanenko@gmail.com>, 2007-2009.
# sevenfourk <sevenfourk@gmail.com>, 2009.
# Yuri Chornoivan <yurchor@ukr.net>, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020.
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.31.90\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2020-03-05 13:28+0000\n"
"PO-Revision-Date: 2020-02-28 14:26+0200\n"
"Last-Translator: Yuri Chornoivan <yurchor@ukr.net>\n"
"Language-Team: Ukrainian <trans-uk@lists.fedoraproject.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 20.03.70\n"

#: lib/argmatch.c:132
#, c-format
msgid "invalid argument %s for %s"
msgstr "неправильний аргумент %s для %s"

#: lib/argmatch.c:133
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "неоднозначний аргумент %s для %s"

#: lib/argmatch.c:152 lib/argmatch.h:223
msgid "Valid arguments are:"
msgstr "Допустимі аргументи:"

#: lib/closein.c:100
msgid "error closing file"
msgstr "помилка при закритті файла"

#: lib/closeout.c:122 src/basenc.c:945 src/basenc.c:957 src/basenc.c:963
#: src/basenc.c:1006 src/basenc.c:1071 src/cat.c:187 src/cat.c:203
#: src/cat.c:287 src/cksum.c:245 src/expand.c:150 src/expand.c:175
#: src/factor.c:2387 src/mktemp.c:339 src/od.c:970 src/paste.c:163
#: src/seq.c:295 src/shuf.c:595 src/split.c:936 src/split.c:1190
#: src/split.c:1195 src/tail.c:1291 src/tail.c:1445 src/tail.c:2507
#: src/tr.c:1587 src/tr.c:1813 src/tr.c:1905 src/unexpand.c:234
#: src/unexpand.c:250
#, c-format
msgid "write error"
msgstr "помилка запису"

#: lib/copy-acl.c:54 src/copy.c:1427 src/copy.c:2945
#, c-format
msgid "preserving permissions for %s"
msgstr "збереження прав доступу для %s"

#: lib/error.c:195
msgid "Unknown system error"
msgstr "Невідома системна помилка"

#: lib/file-type.c:40
msgid "regular empty file"
msgstr "звичайний порожній файл"

#: lib/file-type.c:40
msgid "regular file"
msgstr "звичайний файл"

#: lib/file-type.c:43
msgid "directory"
msgstr "каталог"

#: lib/file-type.c:46
msgid "symbolic link"
msgstr "символічне посилання"

#: lib/file-type.c:52
msgid "message queue"
msgstr "черга повідомлень"

#: lib/file-type.c:55
msgid "semaphore"
msgstr "семафор"

#: lib/file-type.c:58
msgid "shared memory object"
msgstr "об'єкт спільній пам'яті"

#: lib/file-type.c:61
msgid "typed memory object"
msgstr "об'єкт типізованої пам'яті"

#: lib/file-type.c:66
msgid "block special file"
msgstr "файл блокового пристрою"

#: lib/file-type.c:69
msgid "character special file"
msgstr "файл символьного пристрою"

#: lib/file-type.c:72
msgid "contiguous data"
msgstr "неперервні дані"

#: lib/file-type.c:75
msgid "fifo"
msgstr "fifo"

#: lib/file-type.c:78
msgid "door"
msgstr "двері"

#: lib/file-type.c:81
msgid "multiplexed block special file"
msgstr "спеціальний файл ущільненого блокового пристрою"

#: lib/file-type.c:84
msgid "multiplexed character special file"
msgstr "спеціальний файл ущільненого символьного пристрою"

#: lib/file-type.c:87
msgid "multiplexed file"
msgstr "ущільнений файл"

#: lib/file-type.c:90
msgid "named file"
msgstr "іменований файл"

#: lib/file-type.c:93
msgid "network special file"
msgstr "спеціальний мережевий файл"

#: lib/file-type.c:96
msgid "migrated file with data"
msgstr "перенесений файл з даними"

#: lib/file-type.c:99
msgid "migrated file without data"
msgstr "перенесений файл без даних"

#: lib/file-type.c:102
msgid "port"
msgstr "порт"

#: lib/file-type.c:105
msgid "socket"
msgstr "сокет"

#: lib/file-type.c:108
msgid "whiteout"
msgstr "забілювання"

#: lib/file-type.c:110
msgid "weird file"
msgstr "дивний файл"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "Сімейство адрес не підтримується для цього вузла"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "Тимчасова помилка розв'язання назв"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "Неправильне значення ai_flags"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "Критична помилка при розв'язанні назв"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "ai_family не підтримується"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "Помилка виділення пам'яті"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "З даною назвою вузла не пов'язано жодної адреси"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "Невідома назва чи сервіс"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr "Servname не підтримується для ai_socktype"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "ai_socktype не підтримується"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "Системна помилка"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "Буфер аргументів надто малий"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "Триває обробка запиту"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "Запит скасовано"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "Запит не скасовано"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "Всі запити завершені"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "Перервано за сигналом"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "Неправильно закодований рядок параметрів"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "Невідома помилка"

#: lib/getopt.c:278
#, c-format
msgid "%s: option '%s%s' is ambiguous\n"
msgstr "%s: параметр «%s%s» не є однозначним\n"

#: lib/getopt.c:284
#, c-format
msgid "%s: option '%s%s' is ambiguous; possibilities:"
msgstr "%s: неоднозначний параметр «%s%s»; можливі варіанти:"

#: lib/getopt.c:319
#, c-format
msgid "%s: unrecognized option '%s%s'\n"
msgstr "%s: невідомий параметр «%s%s»\n"

#: lib/getopt.c:345
#, c-format
msgid "%s: option '%s%s' doesn't allow an argument\n"
msgstr "%s: додавання аргументів до параметра «%s%s» не передбачено\n"

#: lib/getopt.c:360
#, c-format
msgid "%s: option '%s%s' requires an argument\n"
msgstr "%s: до параметра «%s%s» слід додати аргумент\n"

#: lib/getopt.c:621
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s: некоректний параметр — «%c»\n"

#: lib/getopt.c:636 lib/getopt.c:682
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s: до параметра слід додати аргумент — «%c»\n"

#: lib/mkdir-p.c:162 src/copy.c:1927 src/copy.c:1999 src/copy.c:2571
#: src/copy.c:2932 src/find-mount-point.c:84 src/install.c:702
#: src/realpath.c:146 src/stat.c:1440 src/truncate.c:327
#, c-format
msgid "cannot stat %s"
msgstr "не вдалося виконати stat для %s"

#: lib/mkdir-p.c:190 src/install.c:512
#, c-format
msgid "cannot change permissions of %s"
msgstr "Не вдалося змінити права доступу до %s"

#: lib/mkdir-p.c:200 src/copy.c:2560 src/install.c:740 src/install.c:753
#, c-format
msgid "cannot create directory %s"
msgstr "Не вдалося створити каталог %s"

#: lib/obstack.c:338 lib/obstack.c:340 lib/xalloc-die.c:34 src/csplit.c:233
#: src/tac.c:442
#, c-format
msgid "memory exhausted"
msgstr "пам'ять вичерпано"

# c-format
#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "не вдалося зберегти поточний робочий каталог"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "не вдалося повернутись до початкового робочого каталогу"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:362
msgid "`"
msgstr "«"

#: lib/quotearg.c:363
msgid "'"
msgstr "»"

#: lib/randread.c:128
#, c-format
msgid "%s: end of file"
msgstr "%s: кінець файла"

#: lib/randread.c:128 src/du.c:1074 src/md5sum.c:803 src/od.c:954 src/tac.c:251
#: src/tac.c:357 src/tac.c:515 src/tac.c:596 src/wc.c:824
#, c-format
msgid "%s: read error"
msgstr "%s: помилка читання"

#: lib/regcomp.c:135
msgid "Success"
msgstr "Виконано"

#: lib/regcomp.c:138
msgid "No match"
msgstr "Немає збігів"

#: lib/regcomp.c:141
msgid "Invalid regular expression"
msgstr "Неправильний регулярний вираз"

#: lib/regcomp.c:144
msgid "Invalid collation character"
msgstr "Неправильний символ порівняння"

#: lib/regcomp.c:147
msgid "Invalid character class name"
msgstr "Некоректна назва класу символу"

#: lib/regcomp.c:150
msgid "Trailing backslash"
msgstr "Зворотна коса риска наприкінці"

#: lib/regcomp.c:153
msgid "Invalid back reference"
msgstr "Неправильне зворотне посилання"

#: lib/regcomp.c:156
msgid "Unmatched [, [^, [:, [., or [="
msgstr "Вираз без парних [, [^, [:, [. або [="

#: lib/regcomp.c:159
msgid "Unmatched ( or \\("
msgstr "Непарна ( чи \\("

#: lib/regcomp.c:162
msgid "Unmatched \\{"
msgstr "Непарна \\{"

#: lib/regcomp.c:165
msgid "Invalid content of \\{\\}"
msgstr "Неприпустимий вміст \\{\\}"

#: lib/regcomp.c:168
msgid "Invalid range end"
msgstr "Неправильний кінець діапазону"

#: lib/regcomp.c:171
msgid "Memory exhausted"
msgstr "Скінчилась пам'ять"

#: lib/regcomp.c:174
msgid "Invalid preceding regular expression"
msgstr "Некоректний попередній регулярний вираз"

#: lib/regcomp.c:177
msgid "Premature end of regular expression"
msgstr "Передчасний кінець регулярного виразу"

#: lib/regcomp.c:180
msgid "Regular expression too big"
msgstr "Розмір виразу надто великий"

#: lib/regcomp.c:183
msgid "Unmatched ) or \\)"
msgstr "Непарна ) чи \\)"

#: lib/regcomp.c:676
msgid "No previous regular expression"
msgstr "Відсутній попередній регулярний вираз"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "небезпечно рекурсивно обробляти %s"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "небезпечно рекурсивно обробляти %s (те ж саме, що й %s)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr ""
"використовуйте --no-preserve-root, щоб скасувати попередження про небезпеку"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:150
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:163
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-acl.c:46 src/copy.c:2583 src/cp.c:514
#, c-format
msgid "setting permissions for %s"
msgstr "встановлення прав доступу для %s"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "Від'єднання"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "Переривання"

#: lib/siglist.h:37
msgid "Quit"
msgstr "Вихід"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "Помилкова інструкція"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "Переривання на точці зупину"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "Перервано"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "Помилка обчислень з рухомою комою"

#: lib/siglist.h:52
msgid "Killed"
msgstr "Вбито"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "Помилка каналу обміну даними"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "Помилка адресування"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "Канал обірвано"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "Сигнал таймера"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "Припинено"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "Термінова дія з введення-виведення"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "Зупинено (сигнал)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "Зупинено"

#: lib/siglist.h:79
msgid "Continued"
msgstr "Поновлено"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "Дочірній процес завершив роботу"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "Зупинено (ввід з термінала)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "Зупинено (вивід на термінал)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "Можливе введення-виведення"

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "Перевищено обмеження часу використання процесора"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "Перевищено обмеження на розмір файла"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "Збіг час на віртуальному таймері"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "Збіг час профілювання"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "Зміна вікна"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "Визначений користувачем сигнал 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "Визначений користувачем сигнал 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "Пастка емулятора"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "Помилковий системний виклик"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "Помилка роботи зі стеком"

#: lib/siglist.h:126
msgid "Information request"
msgstr "Інформаційний запит"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "Відмова живлення"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "Втрачено ресурс"

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "Сигнал реального часу %d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "Невідомий сигнал %d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "функцію iconv неможливо використати"

#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "функція iconv недоступна"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "символ поза діапазоном"

#: lib/unicodeio.c:181
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "неможливо перетворити U+%04X у локальне кодування"

#: lib/unicodeio.c:183
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "неможливо перетворити U+%04X у локальне кодування: %s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "неправильний користувач"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "неправильна група"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "неправильна специфікація"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "Неможливо вивести повідомлення про помилку"

#: lib/version-etc.c:73
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "Пакування виконано %s (%s)\n"

#: lib/version-etc.c:76
#, c-format
msgid "Packaged by %s\n"
msgstr "Пакування виконано %s\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:83
msgid "(C)"
msgstr "©"

#. TRANSLATORS: The %s placeholder is the web address of the GPL license.
#: lib/version-etc.c:88
#, c-format
msgid ""
"License GPLv3+: GNU GPL version 3 or later <%s>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
msgstr ""
"Умови ліцензування викладено у GPLv3+: GNU GPL версії 3 або новішій, <%s>.\n"
"Це вільне програмне забезпечення: ви можете вільно змінювати і поширювати "
"його.\n"
"Вам не надається ЖОДНИХ ГАРАНТІЙ, окрім гарантій передбачених "
"законодавством.\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:105
#, c-format
msgid "Written by %s.\n"
msgstr "Автор програми %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:109
#, c-format
msgid "Written by %s and %s.\n"
msgstr "Автор програми %s та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:113
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "Автор програми %s, %s та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:120
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Автор програми %s, %s, %s\n"
"та %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:127
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:134
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:142
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:150
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:159
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s\n"
"%s та %s\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:170
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"Автор програми %s, %s, %s.\n"
"%s, %s, %s, %s\n"
"%s, %s та інші.\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:249
#, c-format
msgid "Report bugs to: %s\n"
msgstr "Про вади повідомляйте за такою адресою: %s\n"

#: lib/version-etc.c:251
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "Про вади у %s повідомляйте на адресу %s\n"

#: lib/version-etc.c:255 lib/version-etc.c:257
#, c-format
msgid "%s home page: <%s>\n"
msgstr "Домашня сторінка %s: <%s>\n"

#: lib/version-etc.c:260
#, c-format
msgid "General help using GNU software: <%s>\n"
msgstr "Загальна довідка з ПЗ GNU: <%s>\n"

#: lib/xbinary-io.c:37
#, c-format
msgid "failed to set file descriptor text/binary mode"
msgstr "не вдалося встановити текстовий/бінарний режим для дескриптора файла"

#: lib/xmemcoll.c:39 src/expr.c:1026
#, c-format
msgid "string comparison failed"
msgstr "помилка порівняння рядків"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Щоб обійти цю проблему, встановіть LC_ALL='C'"

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Помилка порівняння рядків %s та %s."

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "не вдалося виконати форматований вивід"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "некоректний аргумент %s%s — «%s»"

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "некоректний суфікс у аргументі %s%s: «%s»"

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "%s%s, аргумент «%s» є занадто об'ємним"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:38 src/chmod.c:39 src/chown.c:37 src/comm.c:39
#: src/cp.c:48 src/csplit.c:45 src/cut.c:46 src/date.c:40 src/dd.c:45
#: src/df.c:49 src/dirname.c:32 src/du.c:55 src/env.c:39 src/expand.c:49
#: src/fold.c:36 src/groups.c:36 src/head.c:47 src/id.c:42 src/install.c:51
#: src/ln.c:52 src/ls.c:137 src/mkdir.c:39 src/mkfifo.c:36 src/mknod.c:37
#: src/mv.c:43 src/nice.c:40 src/nl.c:42 src/paste.c:53 src/pathchk.c:32
#: src/pinky.c:38 src/printenv.c:44 src/printf.c:68 src/rm.c:41 src/rmdir.c:37
#: src/stty.c:68 src/sum.c:39 src/tac.c:58 src/tail.c:77 src/tee.c:38
#: src/touch.c:45 src/tty.c:44 src/uname.c:61 src/unexpand.c:50 src/uniq.c:41
#: src/uptime.c:46 src/users.c:36 src/wc.c:51 src/who.c:51 src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"Використання: %s НАЗВА [СУФІКС]\n"
"  чи:  %s КЛЮЧ... НАЗВА...\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""
"Вивести НАЗВУ з вилученням компонента каталогу на початку рядка.\n"
"Також вилучити завершальний СУФІКС (якщо вказано).\n"

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n"
"  -z, --zero           end each output line with NUL, not newline\n"
msgstr ""
"  -a, --multiple       увімкнути підтримку декількох аргументів, вважати "
"кожен з них НАЗВОЮ\n"
"  -s, --suffix=СУФІКС  вилучити кінцевий СУФІКС; додає -a\n"
"  -z, --zero           відокремлювати пункти у виведенні символом NUL, а не "
"символом нового рядка\n"

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s /usr/bin/sort          -> «sort»\n"
"  %s include/stdio.h .h     -> «stdio»\n"
"  %s -s .h include/stdio.h  -> «stdio»\n"
"  %s -a any/str1 any/str2   -> «str1», потім «str2»\n"

#: src/basename.c:170 src/chcon.c:537 src/chgrp.c:279 src/chmod.c:529
#: src/chown.c:280 src/chroot.c:279 src/comm.c:481 src/csplit.c:1402
#: src/dirname.c:116 src/expr.c:454 src/join.c:1159 src/link.c:76
#: src/mkdir.c:252 src/mkfifo.c:130 src/mknod.c:171 src/nohup.c:107
#: src/pathchk.c:147 src/printf.c:693 src/readlink.c:145 src/realpath.c:237
#: src/rm.c:338 src/rmdir.c:223 src/seq.c:633 src/sleep.c:116 src/stat.c:1885
#: src/stdbuf.c:371 src/tr.c:1753 src/unlink.c:74
#, c-format
msgid "missing operand"
msgstr "відсутній операнд"

#: src/basename.c:176 src/basenc.c:1225 src/comm.c:489 src/cp.c:621
#: src/date.c:471 src/dircolors.c:449 src/du.c:1019 src/hostid.c:72
#: src/hostname.c:111 src/install.c:985 src/join.c:969 src/link.c:84
#: src/ln.c:593 src/logname.c:70 src/mknod.c:182 src/mv.c:451 src/nproc.c:115
#: src/od.c:1871 src/ptx.c:2082 src/seq.c:639 src/shuf.c:491 src/sort.c:4596
#: src/split.c:1554 src/tr.c:1768 src/tsort.c:559 src/tty.c:113 src/uname.c:252
#: src/uniq.c:520 src/uniq.c:537 src/unlink.c:80 src/uptime.c:252
#: src/users.c:145 src/wc.c:758 src/who.c:831 src/whoami.c:78
#, c-format
msgid "extra operand %s"
msgstr "зайвий операнд %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:37 src/basenc.c:40
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:38 src/env.c:40 src/numfmt.c:43
msgid "Assaf Gordon"
msgstr "Assaf Gordon"

#: src/basenc.c:101 src/dircolors.c:99 src/uptime.c:199 src/users.c:105
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"

#: src/basenc.c:106
msgid "basenc encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Кодування чи декодування файла чи стандартного потоку вводу у форматі\n"
"baseenc, і запис у стандартний потік виводу.\n"

#: src/basenc.c:110
#, c-format
msgid "Base%d encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Кодування чи декодування файла чи стандартного потоку вводу у форматі\n"
"Base%d, і запис у стандартний потік виводу.\n"

#: src/basenc.c:118
msgid "      --base64          same as 'base64' program (RFC4648 section 4)\n"
msgstr ""
"      --base64          те саме, що і програма base64 (RFC4648, розділ 4)\n"

#: src/basenc.c:121
msgid "      --base64url       file- and url-safe base64 (RFC4648 section 5)\n"
msgstr ""
"      --base64url       безпечний варіант base64 для файлів і адрес "
"(RFC4648, розділ 5)\n"

#: src/basenc.c:124
msgid "      --base32          same as 'base32' program (RFC4648 section 6)\n"
msgstr ""
"      --base32          те саме, що і програма base32 (RFC4648, розділ 6)\n"

#: src/basenc.c:127
msgid ""
"      --base32hex       extended hex alphabet base32 (RFC4648 section 7)\n"
msgstr ""
"      --base32hex       розширена шістнадцяткова абетна для base32 (RFC4648, "
"розділ 7)\n"

#: src/basenc.c:130
msgid "      --base16          hex encoding (RFC4648 section 8)\n"
msgstr "      --base16          шістнадцяткове кодування (RFC4648, розділ 8)\n"

#: src/basenc.c:133
msgid ""
"      --base2msbf       bit string with most significant bit (msb) first\n"
msgstr ""
"      --base2msbf       рядок бітів, у якому першим є найбільший біт (msb)\n"

#: src/basenc.c:136
msgid ""
"      --base2lsbf       bit string with least significant bit (lsb) first\n"
msgstr ""
"      --base2lsbf       рядок бітів, у якому останнім є найбільший біт "
"(lsb)\n"

#: src/basenc.c:140
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode          декодувати дані\n"
"  -i, --ignore-garbage  під час декодування пропускати символи поза абеткою\n"
"  -w, --wrap=СТОВПЧИК   переносити кодовані рядки після символу СТОВПЧИК "
"(типово 76).\n"
"                          0 вимикає перенесення рядків.\n"
"\n"

#: src/basenc.c:148
msgid ""
"      --z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n"
"                        when encoding, input length must be a multiple of "
"4;\n"
"                        when decoding, input length must be a multiple of 5\n"
msgstr ""
"      --z85             ascii85-подібне кодування (ZeroMQ spec:32/Z85);\n"
"                        при кодуванні довжина вхідних даних має бути кратною "
"до 4;\n"
"                        при декодуванні довжина вхідних даних має бути "
"кратною до 5\n"

#: src/basenc.c:157
msgid ""
"\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"При декодуванні ввід може містити і символи розриву рядків, окрім байтів\n"
"формальної абетки. Вкажіть ключ --ignore-garbage, щоб спробувати\n"
"ігнорувати неабеткові знаки у закодованому потоці.\n"

#: src/basenc.c:164
#, c-format
msgid ""
"\n"
"The data are encoded as described for the %s alphabet in RFC 4648.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"Дані закодовані символами з алфавіту %s, відповідно до RFC 4648. При\n"
"декодуванні ввід може містити також переведення рядків окрім байтів\n"
"формального алфавіту %s. Вкажіть ключ --ignore-garbage, щоб\n"
"спробувати ігнорувати неалфавітні знаки в закодованому потоці.\n"

#: src/basenc.c:619
msgid "invalid input (length must be multiple of 4 characters)"
msgstr "некоректні вхідні дані (довжина має бути кратною до 4 символів)"

#: src/basenc.c:1009 src/basenc.c:1055 src/csplit.c:277 src/csplit.c:1468
#: src/join.c:465 src/shuf.c:233 src/shuf.c:279 src/shuf.c:559
#: src/tac-pipe.c:76 src/tee.c:263 src/tr.c:1611
#, c-format
msgid "read error"
msgstr "помилка читання"

#: src/basenc.c:1074
msgid "invalid input"
msgstr "неправильні вхідні дані"

#: src/basenc.c:1121
msgid "invalid wrap size"
msgstr "неправильна величина переносу"

#: src/basenc.c:1218
#, c-format
msgid "missing encoding type"
msgstr "пропущено тип кодування"

#: src/basenc.c:1256 src/cat.c:764
msgid "closing standard input"
msgstr "закривається стандартний потік вводу"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:47 src/df.c:48 src/du.c:54 src/factor.c:129
#: src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:38 src/ls.c:136 src/rm.c:42 src/split.c:50
#: src/tee.c:37 src/uniq.c:40
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:88 src/df.c:1511 src/expand.c:69 src/fold.c:66 src/head.c:110
#: src/ls.c:5342 src/nl.c:176 src/paste.c:436 src/pr.c:2737 src/rm.c:133
#: src/sum.c:59 src/tac.c:132 src/tail.c:265 src/tee.c:87 src/unexpand.c:78
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"

#: src/cat.c:92
msgid "Concatenate FILE(s) to standard output.\n"
msgstr "Сполучити ФАЙЛ(и) і вивести дані до стандартного виведення.\n"

#: src/cat.c:98
msgid ""
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"\n"
"  -A, --show-all           еквівалент -vET\n"
"  -b, --number-nonblank    кількість непорожніх рядків виводу\n"
"  -e                       еквівалент -vE\n"
"  -E, --show-ends          показувати $ наприкінці кожного рядка\n"
"  -n, --number             кількість усіх рядків виводу\n"
"  -s, --squeeze-blank      не більше ніж один порожній рядок\n"

#: src/cat.c:107
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       еквівалент -vT\n"
"  -T, --show-tabs          відображати символи табуляцій як  ^I\n"
"  -u                       (ігнорується)\n"
"  -v, --show-nonprinting   використовувати нотацію ^ та M-, за винятком\n"
"                           переведення рядка та табуляції\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s f - g  Виводить вміст f, потім стандартний потік вводу, потім вміст g.\n"
"  %s        Копіює дані зі стандартного потоку вводу у стандартний вивід.\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "помилка ioctl на %s"

#: src/cat.c:638 src/dd.c:2492 src/sort.c:405 src/tail.c:2444 src/tee.c:207
#: src/yes.c:128
#, c-format
msgid "standard output"
msgstr "стандартний вивід"

#: src/cat.c:699
#, c-format
msgid "%s: input file is output file"
msgstr "%s: вхідний файл є файлом виводу"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/runcon.c:57
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:38 src/chgrp.c:39 src/chmod.c:40 src/chown.c:38 src/cp.c:49
#: src/cut.c:47 src/dirname.c:33 src/du.c:57 src/head.c:48 src/hostid.c:32
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:44 src/nohup.c:34 src/od.c:40
#: src/pathchk.c:33 src/pwd.c:32 src/rm.c:43 src/sleep.c:34 src/sync.c:33
#: src/tail.c:79 src/tr.c:38 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:101 src/runcon.c:202 src/runcon.c:233
#, c-format
msgid "failed to create security context: %s"
msgstr "не вдалося створити контексту безпеки: %s"

#: src/chcon.c:113
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "не вдалося встановити %s контекст безпеки компоненту %s"

#: src/chcon.c:157 src/chcon.c:548 src/copy.c:958 src/runcon.c:216
#: src/stat.c:833
#, c-format
msgid "failed to get security context of %s"
msgstr "не вдалося встановити контекст безпеки %s"

#: src/chcon.c:167
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "не вдалося застосувати частковий контекст для непозначеного файла %s"

#: src/chcon.c:191
#, c-format
msgid "failed to change context of %s to %s"
msgstr "не вдалося змінити контекст %s на %s"

#: src/chcon.c:256 src/chmod.c:218 src/chown-core.c:324 src/copy.c:759
#: src/du.c:533 src/ls.c:3436
#, c-format
msgid "cannot access %s"
msgstr "не вдалося отримати доступ до %s"

#: src/chcon.c:267 src/chmod.c:231 src/chown-core.c:337 src/du.c:513
#, c-format
msgid "cannot read directory %s"
msgstr "не вдалося прочитати каталог %s"

#: src/chcon.c:294
#, c-format
msgid "changing security context of %s\n"
msgstr "зміна контексту безпеки для %s\n"

#: src/chcon.c:328 src/chmod.c:349 src/chown-core.c:538 src/remove.c:601
#: src/selinux.c:323
#, c-format
msgid "fts_read failed"
msgstr "помилка при операції fts_read"

#: src/chcon.c:339 src/chmod.c:360 src/chown-core.c:550 src/du.c:714
#: src/remove.c:615 src/selinux.c:334
#, c-format
msgid "fts_close failed"
msgstr "помилка fts_close"

#: src/chcon.c:353
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання:  %s [КЛЮЧ]... КОНТЕКСТ ФАЙЛ\n"
"       або:    %s [КЛЮЧ]... [-u КОРИСТУВАЧ] [-r РОЛЬ] [-l ДІАПАЗОН] [-t ТИП] "
"ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chcon.c:359
msgid ""
"Change the SELinux security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""
"Змінює контекст захисту SELinux кожного файла ФАЙЛ на КОНТЕКСТ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛа на контекст "
"ЗФАЙЛа.\n"

#: src/chcon.c:366 src/chgrp.c:125 src/chown.c:95
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"      --dereference      впливає на ціль кожного символічного посилання,\n"
"                         а не на саме символічне посилання\n"
"  -h, --no-dereference   обробити символічні посилання замість файлів, на "
"які вони посилаються\n"

#: src/chcon.c:371
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""
"  -u, --user=КОРИСТУВАЧ  встановити користувача КОРИСТУВАЧ у цільовому "
"контексті безпеки\n"
"  -r, --role=РОЛЬ        встановити роль РОЛЬ у цільовому контексті безпеки\n"
"  -t, --type=ТИП         встановити тип ТИП у цільовому контексті безпеки\n"
"  -l, --range=ДІАПАЗОН   встановити діапазон ДІАПАЗОН у цільовому контексті "
"безпеки\n"

#: src/chcon.c:377 src/chgrp.c:134 src/chmod.c:390 src/chown.c:111
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""
"      --no-preserve-root  не трактувати '/' особливим чином (типово)\n"
"      --preserve-root    перешкоджати рекурсивному виконанню на '/'\n"

#: src/chcon.c:381
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""
"      --reference=ЗФАЙЛА використовувати контекст ЗФАЙЛА замість явного\n"
"                         вказування КОНТЕКСТ\n"

#: src/chcon.c:385 src/chgrp.c:142 src/chown.c:119
msgid "  -R, --recursive        operate on files and directories recursively\n"
msgstr "  -R, --recursive        обробляти файли і каталоги рекурсивно\n"

#: src/chcon.c:388
msgid "  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -v, --verbose          вивести діагностичні дані для кожного з оброблених "
"файлів\n"

#: src/chcon.c:391 src/chgrp.c:145 src/chown.c:122
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"\n"
"Вказані нижче ключі впливають на спосіб обходу ієрархії каталогів при\n"
"заданому ключі -R.  Якщо вказано декілька цих ключів, діє\n"
"лише останній.\n"
"\n"
"  -H                     якщо аргумент командного рядка є символьним\n"
"                         посиланням на каталог, перейти за ним\n"
"  -L                     переходити за кожним символьним посиланням на\n"
"                         каталог\n"
"  -P                     не переходити за символьними посиланнями (типово)\n"
"\n"

#: src/chcon.c:518 src/chgrp.c:266 src/chown.c:267
msgid "-R --dereference requires either -H or -L"
msgstr "Для комбінації ключів -R --dereference слід вказати -H або -L"

#: src/chcon.c:524
msgid "-R -h requires -P"
msgstr "при вказуванні -R -h потрібно вказати -P"

#: src/chcon.c:539 src/chgrp.c:281 src/chmod.c:531 src/chown.c:282
#: src/comm.c:483 src/csplit.c:1404 src/join.c:1161 src/link.c:78
#: src/mknod.c:173 src/tr.c:1756
#, c-format
msgid "missing operand after %s"
msgstr "пропущений операнд після %s"

#: src/chcon.c:563 src/runcon.c:250
#, c-format
msgid "invalid context: %s"
msgstr "неправильний контекст: %s"

#: src/chcon.c:569
#, c-format
msgid "conflicting security context specifiers given"
msgstr "вказано конфліктні специфікатори контексту безпеки"

#: src/chcon.c:578 src/chgrp.c:289 src/chgrp.c:307 src/chmod.c:539
#: src/chmod.c:558 src/chown.c:290 src/chown.c:319 src/cp.c:422 src/cp.c:489
#: src/mv.c:99 src/pwd.c:276 src/rm.c:348 src/touch.c:348
#, c-format
msgid "failed to get attributes of %s"
msgstr "помилка отримання атрибутів %s"

#: src/chgrp.c:93
#, c-format
msgid "invalid group: %s"
msgstr "неправильна група: %s"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... ГРУПА ФАЙЛ...\n"
"  чи:  %s [КЛЮЧ]... --reference=ЗФАЙЛА ФАЙЛ...\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Змінити групу кожного файла ФАЙЛ на ГРУПУ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛА на контекст "
"ЗФАЙЛА.\n"
"\n"

#: src/chgrp.c:120 src/chmod.c:385 src/chown.c:90
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -c, --changes          подібний до verbose, але повідомити про них, лише "
"якщо внесено зміни\n"
"  -f, --silent, --quiet  придушити всі повідомлення про помилки\n"
"  -v, --verbose          вивести діагностичні дані для кожного з оброблених "
"файлів\n"

#: src/chgrp.c:130 src/chown.c:100
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"                         (діє лише на системі з підтримкою зміни прав\n"
"                         власності символічних посилань)\n"

#: src/chgrp.c:138
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""
"      --reference=ЗФАЙЛа використовувати групу ЗФАЙЛа замість явного\n"
"                         вказування ГРУПИ\n"

#: src/chgrp.c:160
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s staff /u      Змінює групу /u на \"staff\".\n"
"  %s -hR staff /u  Змінює групу /u та вкладених файлів на \"staff\".\n"

#: src/chmod.c:127
#, c-format
msgid "getting new attributes of %s"
msgstr "отримуються нові атрибути %s"

#: src/chmod.c:151 src/chown-core.c:146
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr ""
"ані символьне посилання %s, ані об'єкт на який воно вказує, не були змінені\n"

#: src/chmod.c:165
#, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "режим %s змінено з %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:168
#, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr "не вдалося змінити режим %s з %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:171
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "права доступу %s залишені як %04lo (%s)\n"

#: src/chmod.c:238
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "обробка небезпечного символьного посилання %s неможлива"

#: src/chmod.c:278
#, c-format
msgid "changing permissions of %s"
msgstr "зміна прав доступу для %s"

#: src/chmod.c:314
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s: нові права доступу %s, а не %s"

#: src/chmod.c:374
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... РЕЖИМ[,РЕЖИМ]... ФАЙЛ\n"
"       або:    %s [КЛЮЧ]... ВІСІМК-РЕЖИМ ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chmod.c:380
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Змінити режим для всіх файлів на РЕЖИМ.\n"
"З ключем  --reference, змінює контекст безпеки кожного ФАЙЛУ на контекст "
"ЗФАЙЛА.\n"
"\n"

#: src/chmod.c:394
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr ""
"      --reference=ЗФАЙЛ  використовувати режим ЗФАЙЛа, замість значень "
"РЕЖИМ\n"

#: src/chmod.c:397
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr "  -R, --recursive        змінювати файли і каталоги рекурсивно\n"

#: src/chmod.c:402
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"РЕЖИМ вказується у формі '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"

#: src/chmod.c:516
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "не можна використовувати разом ключі режиму та --reference"

#: src/chmod.c:547
#, c-format
msgid "invalid mode: %s"
msgstr "неправильний режим: %s"

#: src/chown-core.c:157
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "змінено власника %s з %s на %s\n"

#: src/chown-core.c:158
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "змінено групу %s з %s на %s\n"

#: src/chown-core.c:159
#, c-format
msgid "no change to ownership of %s\n"
msgstr "не змінений власник %s\n"

#: src/chown-core.c:164
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "не вдалося змінити власника %s з %s на %s\n"

#: src/chown-core.c:165
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "не вдалося змінити групу %s з %s на %s\n"

#: src/chown-core.c:166 src/chown-core.c:172
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "не вдалося змінити власника %s\n"

#: src/chown-core.c:170
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "не вдалося змінити власника %s на %s\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "помилка зміни групи %s на %s\n"

#: src/chown-core.c:179
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "власник %s залишений як %s\n"

#: src/chown-core.c:180
#, c-format
msgid "group of %s retained as %s\n"
msgstr "група %s залишена як %s\n"

#: src/chown-core.c:181
#, c-format
msgid "ownership of %s retained\n"
msgstr "власник %s залишений без змін\n"

#: src/chown-core.c:378
#, c-format
msgid "cannot dereference %s"
msgstr "не вдалося перейти за символьним посиланням %s"

#: src/chown-core.c:466
#, c-format
msgid "changing ownership of %s"
msgstr "зміна власника %s"

#: src/chown-core.c:467
#, c-format
msgid "changing group of %s"
msgstr "зміна групи для %s"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ВЛАСНИК][:[ГРУПА]] ФАЙЛ...\n"
"       або:    %s [КЛЮЧ]... --reference=ЗФАЙЛ ФАЙЛ...\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""
"Змінити власника і/або групу для кожного з ФАЙЛів на ВЛАСНИКА і/або ГРУПУ.\n"
"З ключем  --reference, змінити власника і групу всіх ФАЙЛів на значення "
"ЗФАЙЛа.\n"

#: src/chown.c:104
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=ПОТОЧНИЙ_ВЛАСНИК:ПОТОЧНА_ГРУПА\n"
"                         змінює власника та/або групу кожного файла\n"
"                         лише якщо поточний власник та/або група\n"
"                         відповідає вказаному виразу.\n"
"                         Як група, так і власник можуть бути опущені,\n"
"                         у цьому випадку відповідність атрибута\n"
"                         не обов'язкова.\n"

#: src/chown.c:115
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""
"      --reference=ЗФАЙЛ  використовувати власника та групу ЗФАЙЛа замість\n"
"                         явного вказування ВЛАСНИКА:ГРУПИ\n"

#: src/chown.c:137
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"Власник не змінюється, якщо він не вказаний у аргументі.  Група також не\n"
"змінюється, якщо не вказана; але якщо після символьного ВЛАСНИКА стоїть\n"
"знак ':', вважається зміна групи на основну групу поточного\n"
"користувача.\n"
"ВЛАСНИК та ГРУПА можуть бути як числовими, так і символьними.\n"

#: src/chown.c:143
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s root /u        Змінює власника /u на \"root\".\n"
"  %s root:staff /u  То же, але ще міняє групу на \"staff\".\n"
"  %s -hR root /u    Змінює власника /u та вкладених файлів на \"root\".\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:39
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:139 src/install.c:608
#, c-format
msgid "invalid group %s"
msgstr "неправильна група %s"

#: src/chroot.c:154
#, c-format
msgid "invalid group list %s"
msgstr "некоректний список груп %s"

#: src/chroot.c:187
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ПАРАМЕТР] НОВИЙКОРІНЬ [КОМАНДА [АРГУМЕНТ]...]\n"
"  або:  %s ПАРАМЕТР\n"

#: src/chroot.c:192
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"Виконує КОМАНДУ з вказаним кореневим каталогом.\n"
"\n"

#: src/chroot.c:197
msgid "  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""
"  --groups=СПИСОК_ГРУП   вказати додаткові групи у форматі гр1,гр2,…,грN\n"

#: src/chroot.c:200
msgid "  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
msgstr "  --userspec=КОР:ГРУПА   вказати користувача і групу (ід. або назву)\n"

#: src/chroot.c:203
#, c-format
msgid "  --skip-chdir           do not change working directory to %s\n"
msgstr "  --skip-chdir           не змінювати робочий каталог на %s\n"

#: src/chroot.c:209
msgid ""
"\n"
"If no command is given, run '\"$SHELL\" -i' (default: '/bin/sh -i').\n"
msgstr ""
"\n"
"Якщо команду не вказано, виконати «\"$SHELL\" -i» (типово «/bin/sh -i»).\n"

#: src/chroot.c:288
#, c-format
msgid "option --skip-chdir only permitted if NEWROOT is old %s"
msgstr ""
"параметром --skip-chdir можна користуватися, лише якщо НОВИЙКОРІНЬ є старим "
"%s"

#: src/chroot.c:331
#, c-format
msgid "cannot change root directory to %s"
msgstr "не вдалося змінити кореневий каталог на %s"

#: src/chroot.c:335
msgid "cannot chdir to root directory"
msgstr "не вдалося перейти до кореневого каталогу"

#: src/chroot.c:377
#, c-format
msgid "no group specified for unknown uid: %d"
msgstr "не вказано групи для невідомого UID: %d"

#: src/chroot.c:402
msgid "failed to get supplemental groups"
msgstr "не вдалося отримати список додаткових груп"

#: src/chroot.c:414
msgid "failed to set supplemental groups"
msgstr "не вдалося встановити список додаткових груп"

#: src/chroot.c:420
msgid "failed to set group-ID"
msgstr "не вдалося встановити ідентифікатор групи"

#: src/chroot.c:423
msgid "failed to set user-ID"
msgstr "не вдалося встановити ідентифікатор користувача"

#: src/chroot.c:429 src/nohup.c:222 src/stdbuf.c:392 src/timeout.c:519
#, c-format
msgid "failed to run command %s"
msgstr "не вдалося виконати команду %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:210
#, c-format
msgid "%s: file too long"
msgstr "%s: файл надто великий"

#: src/cksum.c:257
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Використання: %s [ФАЙЛ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/cksum.c:262
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Виводить контрольну суму (CRC) та число байт для кожного ФАЙЛА.\n"
"\n"

#: src/comm.c:112 src/join.c:192
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ1 ФАЙЛ2\n"

#: src/comm.c:116
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "Порівнює сортовані файли ФАЙЛ1 та ФАЙЛ2 по рядках.\n"

#: src/comm.c:119 src/join.c:201
msgid ""
"\n"
"When FILE1 or FILE2 (not both) is -, read standard input.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ1 або ФАЙЛ2 (але не обидва) мають значення -, читати\n"
"зі стандартного джерела вхідних даних.\n"

#: src/comm.c:123
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"Якщо запущений без ключів виводить результат у три стовпчики. Перший\n"
"стовпчик містить рядки, унікальні для ФАЙЛА1, другий -- унікальні для\n"
"ФАЙЛА2, а третій -- спільні для обох файлів рядки.\n"

#: src/comm.c:129
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1              не виводити стовпчик 1 (рядки, які є лише у ФАЙЛ1)\n"
"  -2              не виводити стовпчик 2 (рядки, які є лише у ФАЙЛ2)\n"
"  -3              не виводити стовпчик 3 (рядки, які є у обох файлах)\n"

#: src/comm.c:135
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order     перевіряти, що вхідний потік сортований, навіть\n"
"                      якщо усі вхідні рядки утворюють пари\n"
"  --nocheck-order   не перевіряти, що вхідний потік коректно сортований\n"

#: src/comm.c:141
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=РЯД  розділяти стовпчику вставляючи РЯД\n"

#: src/comm.c:144
msgid "  --total           output a summary\n"
msgstr "  --total           вивести резюме\n"

#: src/comm.c:147 src/cut.c:178 src/head.c:134 src/numfmt.c:945 src/paste.c:452
#: src/tail.c:312
msgid "  -z, --zero-terminated    line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated    завершувати рядки нульовим байтом, а не символом "
"нового рядка\n"

#: src/comm.c:152
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"Зауважте, що під час порівняння використовуються правила LC_COLLATE.\n"

#: src/comm.c:156
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s -12 файл1 файл2  Вивести лише рядки, які є спільними для файл1 і "
"файл2.\n"
"  %s -3 файл1 файл2   Вивести рядки у файл1, яких немає у файл2, і навпаки.\n"

#: src/comm.c:238
#, c-format
msgid "file %d is not in sorted order"
msgstr "файл %d не сортований"

#: src/comm.c:402 src/du.c:1137 src/ls.c:3067 src/wc.c:885
msgid "total"
msgstr "загалом"

#: src/comm.c:458
msgid "multiple output delimiters specified"
msgstr "задано декілька розділювачів виведених даних"

#: src/comm.c:496 src/join.c:1195
msgid "input is not in sorted order"
msgstr "вхідні дані подано неупорядкованими"

#: src/copy.c:230 src/copy.c:499
#, c-format
msgid "cannot lseek %s"
msgstr "не вдалося виконати lseek для %s"

#: src/copy.c:240 src/copy.c:605
#, c-format
msgid "error deallocating %s"
msgstr "помилка під час спроби скасування розміщення %s"

#: src/copy.c:278 src/dd.c:1928 src/dd.c:2264 src/du.c:1134 src/head.c:157
#: src/head.c:308 src/head.c:390 src/head.c:586 src/head.c:668 src/head.c:737
#: src/head.c:787 src/head.c:810 src/tail.c:464 src/tail.c:557 src/tail.c:606
#: src/tail.c:699 src/tail.c:827 src/tail.c:875 src/tail.c:912 src/tail.c:2037
#: src/tail.c:2070 src/uniq.c:461
#, c-format
msgid "error reading %s"
msgstr "помилка читання %s"

#: src/copy.c:311 src/dd.c:2327 src/dd.c:2389 src/head.c:185 src/tail.c:438
#, c-format
msgid "error writing %s"
msgstr "помилка запису %s"

#: src/copy.c:340
#, c-format
msgid "overflow reading %s"
msgstr "переповнення під час читання %s"

#: src/copy.c:453
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s: не вдалося отримати дані щодо розширень"

#: src/copy.c:525
#, c-format
msgid "%s: write failed"
msgstr "%s: помилка під час спроби запису"

#: src/copy.c:598 src/copy.c:1342
#, c-format
msgid "failed to extend %s"
msgstr "не вдалося розширити %s"

#: src/copy.c:840
#, c-format
msgid "clearing permissions for %s"
msgstr "очищення прав доступу для %s"

#: src/copy.c:875 src/copy.c:2791 src/cp.c:318
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "не вдалося зберегти власника %s"

#: src/copy.c:901
#, c-format
msgid "failed to lookup file %s"
msgstr "не вдалося найти файл %s"

#: src/copy.c:906
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "не вдалося зберегти автора %s"

#: src/copy.c:943 src/cp.c:1205 src/install.c:961 src/mkdir.c:269
#: src/mkfifo.c:144 src/mknod.c:200
#, c-format
msgid "failed to set default file creation context to %s"
msgstr "помилка встановлення типового контексту для створення файлів %s"

#: src/copy.c:973
#, c-format
msgid "failed to set default file creation context for %s"
msgstr "помилка встановлення типового контексту для створення файлів %s"

#: src/copy.c:999
#, c-format
msgid "failed to set the security context of %s"
msgstr "не вдалося встановити контекст захисту %s"

#: src/copy.c:1072 src/csplit.c:655 src/du.c:1026 src/fmt.c:439 src/head.c:889
#: src/split.c:1570 src/tail.c:2011 src/wc.c:770
#, c-format
msgid "cannot open %s for reading"
msgstr "не вдалося відкрити %s для читання"

#: src/copy.c:1078 src/copy.c:1231 src/dd.c:1853 src/dd.c:2401 src/dd.c:2536
#: src/head.c:848 src/tail.c:1851 src/tail.c:1914 src/truncate.c:114
#, c-format
msgid "cannot fstat %s"
msgstr "не вдалося виконати fstat для %s"

#: src/copy.c:1088
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "пропущено файл %s, оскільки він був замінений під час копіювання"

#: src/copy.c:1128 src/copy.c:2221 src/remove.c:263 src/remove.c:280
#: src/remove.c:406 src/remove.c:432
#, c-format
msgid "cannot remove %s"
msgstr "не вдалося вилучити %s"

#: src/copy.c:1133 src/copy.c:1830 src/copy.c:2226 src/remove.c:376
#, c-format
msgid "removed %s\n"
msgstr "вилучено %s\n"

#: src/copy.c:1185
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "запис через через висяче символьне посилання %s не виконується"

#: src/copy.c:1223
#, c-format
msgid "cannot create regular file %s"
msgstr "не вдалося створити звичайний файл %s"

#: src/copy.c:1244
#, c-format
msgid "failed to clone %s from %s"
msgstr "не вдалося клонувати %s з %s"

#: src/copy.c:1357 src/copy.c:2866
#, c-format
msgid "preserving times for %s"
msgstr "збереження відмітки про час %s"

#: src/copy.c:1437 src/copy.c:1443 src/head.c:897 src/sync.c:164
#: src/touch.c:173 src/truncate.c:381
#, c-format
msgid "failed to close %s"
msgstr "не вдалося закрити %s"

#: src/copy.c:1719
#, c-format
msgid "%s: replace %s, overriding mode %04lo (%s)? "
msgstr "%s: замінити %s, незважаючи на права доступу %04lo (%s)? "

#: src/copy.c:1720
#, c-format
msgid "%s: unwritable %s (mode %04lo, %s); try anyway? "
msgstr "%s: непридатний до запису %s (режим %04lo, %s); спробувати пори це? "

#: src/copy.c:1727
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: переписати %s? "

#: src/copy.c:1797
#, c-format
msgid " (backup: %s)"
msgstr " (резервна копія: %s)"

#: src/copy.c:1807
msgid "failed to restore the default file creation context"
msgstr "помилка при відновленні типового контексту при створенні файла"

#: src/copy.c:1825
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "не вдалося створити жорстке посилання %s на %s"

#: src/copy.c:1936
#, c-format
msgid "-r not specified; omitting directory %s"
msgstr "-r не вказано; пропускаємо каталог %s"

#: src/copy.c:1937
#, c-format
msgid "omitting directory %s"
msgstr "пропуск каталогу %s"

#: src/copy.c:1960
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "попередження: вхідний файл %s вказаний більше одного разу"

#: src/copy.c:2015 src/ln.c:275
#, c-format
msgid "%s and %s are the same file"
msgstr "%s та %s - один і той самий файл"

#: src/copy.c:2105
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "не можна перезаписати файл %s, що не є каталогом, каталогом %s"

#: src/copy.c:2123 src/ln.c:246
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "не переписується щойно створений %s %s"

#: src/copy.c:2141
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "не можна перезаписувати каталог %s файлом, що не є каталогом"

#: src/copy.c:2155
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "не можна перейменувати каталог на файл, що не є каталогом: %s -> %s"

#: src/copy.c:2182
#, c-format
msgid "backing up %s might destroy source;  %s not moved"
msgstr "збереження запасної копії %s може знищити оригінал; %s не перенесений"

#: src/copy.c:2183
#, c-format
msgid "backing up %s might destroy source;  %s not copied"
msgstr "збереження запасної копії %s може знищити оригінал; %s не скопійовано"

#: src/copy.c:2205 src/ln.c:305
#, c-format
msgid "cannot backup %s"
msgstr "не вдалося створити резервну копію для %s"

#: src/copy.c:2260
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "не буде копіюватися %s через щойно створене символьне посилання %s"

#: src/copy.c:2340
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "не вдалося скопіювати каталог, %s, у самого себе, %s"

#: src/copy.c:2348
#, c-format
msgid "warning: source directory %s specified more than once"
msgstr "попередження: каталог вхідних даних %s вказано декілька разів"

#: src/copy.c:2374
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "жорстке посилання %s на каталог %s не буде створено"

#: src/copy.c:2398
#, c-format
msgid "renamed "
msgstr "перейменовано "

#: src/copy.c:2436
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "не вдалося перенести %s у свій власний підкаталог, %s"

#: src/copy.c:2479
#, c-format
msgid "cannot move %s to %s"
msgstr "не вдалося перемістити %s у %s"

#: src/copy.c:2495
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr ""
"помилка при переміщенні з пристрою %s на пристрій %s: не вдалося вилучити "
"цільовий файл"

#: src/copy.c:2503
#, c-format
msgid "copied "
msgstr "скопійовано "

#: src/copy.c:2540
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "не вдалося скопіювати циклічне символьне посилання %s"

#: src/copy.c:2602
#, c-format
msgid "created directory %s\n"
msgstr "створено каталог %s\n"

#: src/copy.c:2665
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr ""
"%s: відносні символьні посилання можна створювати лише у поточному каталозі"

#: src/copy.c:2675
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "не вдалося створити символьне посилання %s на %s"

#: src/copy.c:2729 src/mkfifo.c:170
#, c-format
msgid "cannot create fifo %s"
msgstr "не вдалося створити чергу %s"

#: src/copy.c:2738
#, c-format
msgid "cannot create special file %s"
msgstr "не вдалося створити спеціальній файл %s"

#: src/copy.c:2749 src/ls.c:3648 src/stat.c:1477
#, c-format
msgid "cannot read symbolic link %s"
msgstr "не вдалося прочитати символьне посилання %s"

#: src/copy.c:2775
#, c-format
msgid "cannot create symbolic link %s"
msgstr "не вдалося створити символьне посилання %s"

#: src/copy.c:2807
#, c-format
msgid "%s has unknown file type"
msgstr "%s має невідомий тип файла"

#: src/copy.c:2972 src/ln.c:393
#, c-format
msgid "cannot un-backup %s"
msgstr "не вдалося відновити %s з резервної копії"

#: src/copy.c:2976
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (відновлення)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/coreutils.c:48
msgid "Alex Deymo"
msgstr "Alex Deymo"

#: src/coreutils.c:65
#, c-format
msgid "Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"
msgstr "Користування: %s --coreutils-prog=НАЗВА_ПРОГРАМИ [ПАРАМЕТРИ]... \n"

#: src/coreutils.c:68
msgid ""
"Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n"
"\n"
msgstr ""
"Виконати вбудовану програму НАЗВА_ПРОГРАМИ із вказаними параметрами "
"ПАРАМЕТРИ.\n"
"\n"

#: src/coreutils.c:86
#, c-format
msgid ""
"\n"
"Use: '%s --coreutils-prog=PROGRAM_NAME --help' for individual program help.\n"
msgstr ""
"\n"
"Користування: «%s --coreutils-prog=НАЗВА_ПРОГРАМИ --help» для отримання "
"довідки із вказаної програми.\n"

#: src/coreutils.c:178 src/coreutils.c:203
#, c-format
msgid "unknown program %s"
msgstr "невідома програма, %s"

#: src/cp.c:148 src/mv.c:292
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ДЖЕРЕЛО ЦІЛЬ\n"
"       або:    %s [КЛЮЧ]... ДЖЕРЕЛО... КАТАЛОГ\n"
"       або:    %s [КЛЮЧ]... -t КАТАЛОГ ДЖЕРЕЛО...\n"

#: src/cp.c:154
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr "Копіює ДЖЕРЕЛО у ЦІЛЬ, або декілька ДЖЕРЕЛ у КАТАЛОГ.\n"

#: src/cp.c:160
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive                те саме що та -dR --preserve=all\n"
"      --attributes-only        не копіювати даних файла, лише атрибути\n"
"      --backup[=CONTROL]       створити резервну копію перед вилученням\n"
"  -b                           те саме, що й --backup, але без аргументу\n"
"      --copy-contents          копіює зміст спеціальних файлів при\n"
"                               рекурсивному використанні\n"
"  -d                           те саме, що й --no-dereference --"
"preserve=link\n"

#: src/cp.c:169
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  якщо не можна відкрити існуючий файл,\n"
"                                 вилучити його та спробувати ще раз\n"
"                                 (буде проігноровано, якщо вказано\n"
"                                  параметр -n )\n"
"  -i, --interactive            запитувати підтвердження перед переписом\n"
"                                 (перевизначає раніше вказаний параметрі -"
"n )\n"
"  -H                           слідувати за символьним посиланням у ДЖЕРЕЛО\n"

#: src/cp.c:178
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   створювати жорсткі посилання, а не копіювати\n"
"  -L, --dereference            завжди слідувати за символічним посиланням у "
"ДЖЕРЕЛО\n"

#: src/cp.c:182
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber             не переписувати існуючий файл (перевизначає\n"
"                                 попередній параметр -i)\n"
"  -P, --no-dereference         ніколи не йти за символічними посиланнями у "
"ДЖЕРЕЛО\n"

#: src/cp.c:187
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p                           те саме, що й --preserve=mode,ownership,"
"timestamps\n"
"      --preserve[=СПИС_АТТР]   зберігати вказані атрибути (типово:\n"
"                                 mode,ownership,timestamps), якщо можливо\n"
"                                 додаткові атрибути: context, links, xattr, "
"all\n"

#: src/cp.c:195
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --no-preserve=СПИС_АТТР  не зберігати вказані атрибути\n"
"      --parents                добавить вихідний шлях до КАТАЛОГУ\n"

#: src/cp.c:199
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive          копіювати каталоги рекурсивно\n"
"      --reflink[=КОЛИ]         керувати копіями clone/CoW. Див. нижче.\n"
"      --remove-destination     вилучати кожен цільовий файл, перш ніж\n"
"                                 копіювати його (протилежність до --force)\n"

#: src/cp.c:205
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=КОЛИ            керує створенням розріджених файлів. Див. "
"нижче.\n"
"      --strip-trailing-slashes вилучає усі кінцеві похилі риски з кожного\n"
"                               аргументу ДЖЕРЕЛО\n"

#: src/cp.c:210
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link          створювати символьні посилання а не "
"копіювати\n"
"  -S, --suffix=СУФІКС          використовувати для запасних копій вказаний "
"СУФІКС\n"
"      --target-directory=КАТАЛОГ  скопіювати всі ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory    вважати ЦІЛЬ звичайним файлом\n"

#: src/cp.c:216
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 копіювати лише тоді коли вихідний файл\n"
"                                 новіший ніж цільовий файл, або коли\n"
"                                 цільовий файл відсутній\n"
"  -v, --verbose                пояснювати що зроблено\n"
"  -x, --one-file-system        залишатись у межах однієї файлової системи\n"

#: src/cp.c:223
msgid ""
"  -Z                           set SELinux security context of destination\n"
"                                 file to default type\n"
"      --context[=CTX]          like -Z, or if CTX is specified then set the\n"
"                                 SELinux or SMACK security context to CTX\n"
msgstr ""
"  -Z                   встановити типовий тип контексту безпеки SELinux\n"
"                         для файла призначення\n"
"      --context[=CTX]  подібний до -Z, якщо вказано CTX, встановити контекст "
"безпеки\n"
"                         SELinux або SMACK відповідно до вказаного значення\n"
"                         контексту CTX\n"

#: src/cp.c:231
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
msgstr ""
"\n"
"Типово розріджені файли ДЖЕРЕЛА розпізнається за допомогою грубої\n"
"евристичної процедури та відповідно створюється розріджений файл\n"
"ПРИЗНАЧЕННЯ. Таку поведінку можна визначити за допомогою\n"
"параметра --sparse=auto. З параметром --sparse=always ПРТИЗНАЧЕННЯ\n"
"завжди створюється розрідженим, незалежно від того, чи містить\n"
"файл ДЖЕРЕЛА довгі послідовності нульових байтів.\n"
"Скористайтеся параметром --sparse=never для заборони створення розріджених\n"
"файлів.\n"

#: src/cp.c:239
msgid ""
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
"Use --reflink=never to ensure a standard copy is performed.\n"
msgstr ""
"\n"
"Якщо вказано параметр --reflink[=always], буде виконано полегшене "
"копіювання,\n"
"за якого блоки даних копіюватимуться лише у разі внесення змін. Якщо це\n"
"неможливо, копіювання зазнає невдачі або, якщо вказано --reflink=auto,\n"
"повернеться до стандартного режиму.\n"
"Скористайтеся --reflink=never для забезпечення стандартного копіювання.\n"

#: src/cp.c:247
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"Коли вказані ключі -f та -b, та SOURCE збігається з DEST cp створює\n"
"резервну копію DEST.\n"

#: src/cp.c:306
#, c-format
msgid "failed to preserve times for %s"
msgstr "не вдалося зберегти мітки часу для %s"

#: src/cp.c:337
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "не вдалося зберегти права доступу для %s"

#: src/cp.c:473
#, c-format
msgid "cannot make directory %s"
msgstr "не вдалося створити каталог %s"

#: src/cp.c:522 src/cp.c:553
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s існує, але не є каталогом"

#: src/cp.c:585 src/cp.c:1087 src/install.c:407 src/install.c:942 src/ln.c:204
#: src/ln.c:231 src/ln.c:536 src/mv.c:160 src/mv.c:393
#, c-format
msgid "failed to access %s"
msgstr "не вдалося отримати доступ до %s"

#: src/cp.c:606 src/install.c:970 src/ln.c:567 src/mv.c:436 src/shred.c:1251
#: src/touch.c:430 src/truncate.c:318
#, c-format
msgid "missing file operand"
msgstr "пропущений операнд, що вказує файл"

#: src/cp.c:608 src/install.c:972 src/ln.c:590 src/mv.c:438
#, c-format
msgid "missing destination file operand after %s"
msgstr "після %s пропущений операнд, що вказує цільовий файл"

#: src/cp.c:617 src/install.c:981 src/mv.c:447
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr ""
"не можна використовувати водночас --target-directory (-t) і --no-target-"
"directory (-T)"

#: src/cp.c:635 src/cp.c:1090 src/install.c:409 src/install.c:945
#: src/install.c:994 src/ln.c:539 src/mv.c:396 src/mv.c:468
#, c-format
msgid "target %s is not a directory"
msgstr "вказана ціль %s не є каталогом"

#: src/cp.c:745
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "при заданому --parents ціль повинна бути каталогом"

#: src/cp.c:1082 src/install.c:882 src/ln.c:531 src/mv.c:388
msgid "multiple target directories specified"
msgstr "вказано декілька цільових каталогів"

#: src/cp.c:1124 src/install.c:918
#, c-format
msgid "warning: ignoring --context; it requires an SELinux-enabled kernel"
msgstr ""
"попередження: ігноруємо --context; для його використання потрібне ядро з "
"підтримкою SELinux"

#: src/cp.c:1145
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "не можна створювати жорстке та символьне посилання одночасно"

#: src/cp.c:1155 src/mv.c:478
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "параметри --backup і --no-clobber не можна використовувати одночасно"

#: src/cp.c:1161
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "--reflink можна використовувати лише разом з --sparse=auto"

#: src/cp.c:1166 src/install.c:950 src/ln.c:637 src/mv.c:483
msgid "backup type"
msgstr "тип резервної копії"

#: src/cp.c:1190 src/install.c:957
msgid "cannot set target context and preserve it"
msgstr "не можна одночасно встановлювати контекст призначення і зберігати його"

#: src/cp.c:1194
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "не можна зберігати контекст безпеки, якщо ядро не підтримує SELinux"

#: src/cp.c:1210
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr "не вдалося зберегти розширені атрибути, cp зібрано без підтримки xattr"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:44 src/dd.c:46
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:545
msgid "input disappeared"
msgstr "ввід став недоступний"

#: src/csplit.c:676 src/csplit.c:688
#, c-format
msgid "%s: line number out of range"
msgstr "%s: номер рядка поза допустимими межами"

#: src/csplit.c:718
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s: %s: номер рядка поза допустимими межами"

#: src/csplit.c:721 src/csplit.c:777
#, c-format
msgid " on repetition %s\n"
msgstr " при повторі %s\n"

#: src/csplit.c:771
#, c-format
msgid "%s: %s: match not found"
msgstr "%s: %s: відповідність не знайдено"

#: src/csplit.c:838 src/csplit.c:878 src/nl.c:357 src/tac.c:286
#, c-format
msgid "error in regular expression search"
msgstr "помилка пошуку регулярного виразу"

#: src/csplit.c:1007 src/csplit.c:1054
#, c-format
msgid "write error for %s"
msgstr "помилка запису для %s"

#: src/csplit.c:1089
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s: після розділювача очікується ціле число"

#: src/csplit.c:1106
#, c-format
msgid "%s: '}' is required in repeat count"
msgstr "%s: при вказуванні числа повторів слід додати «}»"

#: src/csplit.c:1117
#, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr "%s: між «{» та «}» має бути вказано ціле число"

#: src/csplit.c:1144
#, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr "%s: пропущено кінцевий роздільник «%c»"

#: src/csplit.c:1161
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: неприпустимий регулярний вираз: %s"

#: src/csplit.c:1193
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: неприпустимий шаблон"

#: src/csplit.c:1196
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: номер рядка повинен бути більше нуля"

#: src/csplit.c:1201
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "номер рядка %s менше номеру попереднього рядка, %s"

#: src/csplit.c:1207
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "попередження: номер рядка %s дорівнює попередньому номеру рядка"

#: src/csplit.c:1285
msgid "missing conversion specifier in suffix"
msgstr "пропущений специфікатор перетворення у суфіксі"

#: src/csplit.c:1290
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "неправильний специфікатор перетворення у суфіксі: %c"

#: src/csplit.c:1293
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "неправильний специфікатор перетворення у суфіксі: \\%.3o"

#: src/csplit.c:1298
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "некоректні прапорці у специфікації перетворення: %%%c%c"

#: src/csplit.c:1315
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "надто багато описів перетворення (%%) у суфіксі"

#: src/csplit.c:1329
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "пропущено опис перетворення (%%) у суфіксі"

#: src/csplit.c:1375 src/dd.c:1563 src/nproc.c:105 src/tail.c:2164
msgid "invalid number"
msgstr "некоректне число"

#: src/csplit.c:1482
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ ШАБЛОН...\n"

#: src/csplit.c:1486
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""
"Виводить частини ФАЙЛА, розділені ШАБЛОНОМ (ШАБЛОНАМИ), до файлів 'xx00',\n"
"'xx01', ... та виводить число байт у кожній частині на стандартний вивід.\n"

#: src/csplit.c:1490
msgid ""
"\n"
"Read standard input if FILE is -\n"
msgstr ""
"\n"
"Якщо ФАЙЛ вказано як -, читає стандартне введення.\n"

#: src/csplit.c:1497
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=ФОРМАТ використовувати ФОРМАТ як у sprintf замість "
"%02d\n"
"  -f, --prefix=ПРЕФІКС       використовувати ПРЕФІКС замість 'xx'\n"
"  -k, --keep-files           не вилучати файли виводу при помилках\n"

#: src/csplit.c:1502
msgid "      --suppress-matched     suppress the lines matching PATTERN\n"
msgstr ""
"      --suppress-matched     не виводити рядки, що відповідають зразку\n"

#: src/csplit.c:1505
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=ЦИФРИ         використовувати вказане число ЦИФР замість 2\n"
"  -s, --quiet, --silent      не виводити розміри вихідних файлів\n"
"  -z, --elide-empty-files    вилучати порожні файли виводу\n"

#: src/csplit.c:1512
msgid ""
"\n"
"Each PATTERN may be:\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required '+' or '-' followed by a positive integer.\n"
msgstr ""
"\n"
"\n"
"Варіанти параметра ШАБЛОН:\n"
"  ЦІЛЕ              копіювати до рядка з вказаним номером, але не включно\n"
"  /REGEXP/[ЗСУВ]    копіювати до відповідного рядка, але не включно\n"
"  %%REGEXP%%[ЗСУВ]  пропустити до відповідного рядка, але не включно\n"
"  {ЦІЛЕ}            повторити попередній шаблон вказане число раз\n"
"  {*}               повторити попередній шаблон максимальну кількість разів\n"
"\n"
"Додатковий ЗСУВ рядків -- це обов'язковий символ '+' або '-' з попереднім\n"
"додатнім цілим числом.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:45 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:147
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "Використання: %s КЛЮЧ... [ФАЙЛ]...\n"

#: src/cut.c:151
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr ""
"Виводить вибрані частини рядків з кожного ФАЙЛА на стандартний вивід.\n"

#: src/cut.c:158
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=СПИСОК             вибрати лише вказані байти\n"
"  -c, --characters=СПИСОК        вибрати лише вказані знаки\n"
"  -d, --delimiter=РОЗДІЛЮВАЧ     використовувати РОЗДІЛЮВАЧ для розділення\n"
"                                 полів замість табуляції\n"

#: src/cut.c:163
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=СПИСОК            вибрати лише вказані поля; також виводити\n"
"                                 всі рядки, що не містять розділювачів,\n"
"                                 якщо не вказаний ключ -s\n"
"  -n                             (ігнорується)\n"

#: src/cut.c:169
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr ""
"      --complement        доповнити множину вибраних байтів, знаків "
"або                             полів.\n"

#: src/cut.c:173
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited          не виводити рядки, що не містять "
"розділювачів\n"
"      --output-delimiter=РЯДОК  використовувати РЯДОК для розділення полів\n"
"                                при виводі, типово використовується\n"
"                                розділювач для вводу\n"

#: src/cut.c:183
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"Використовуйте один, і лише один, з ключів -b, -c чи -f.  Кожен СПИСОК\n"
"складається з одного діапазону, або кількох діапазонів, розділених комами.\n"
"Вибрані частини вхідного файла виводяться у тому порядку, у якому вони,\n"
"з'являються на вході, та виводяться рівно один раз.\n"

#: src/cut.c:189
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
msgstr ""
"Варіанти діапазонів:\n"
"\n"
"  Н     Н-ний байт, знак або поле; відлік ведеться від 1\n"
"  Н-    від Н-го байта, знаку або поля до кінця рядка\n"
"  Н-М   від Н-го до М-го (включно) байта, знаку або поля\n"
"  -М    від першого до М-го (включно) байта, знаку або поля\n"

#: src/cut.c:511 src/cut.c:519
msgid "only one type of list may be specified"
msgstr "можна вказати лише один тип списку"

#: src/cut.c:528 src/numfmt.c:1521
msgid "the delimiter must be a single character"
msgstr "розділювач повинен бути одним символом"

#: src/cut.c:567
msgid "you must specify a list of bytes, characters, or fields"
msgstr "треба вказати список байт, символів або полів"

#: src/cut.c:570
msgid "an input delimiter may be specified only when operating on fields"
msgstr "розділювач для вхідних даних можна вказувати лише при обробці полів"

#: src/cut.c:574
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"заборона виводу рядків, що не містять розділювачів,\n"
"має сенс лише при роботі з полями"

#: src/date.c:130
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [+ФОРМАТ]\n"
"       або:    %s [-u|--utc|--universal] [ММДДррхх[[СС]РР][.сс]]\n"

#: src/date.c:135
msgid "Display the current time in the given FORMAT, or set the system date.\n"
msgstr ""
"Показати поточний час у вказаному ФОРМАТі або встановити системну дату.\n"

#: src/date.c:141
msgid ""
"  -d, --date=STRING          display time described by STRING, not 'now'\n"
msgstr ""
"  -d, --date=РЯДОК          показати час, описаний РЯДКОМ, а не поточний.\n"

#: src/date.c:144
msgid ""
"      --debug                annotate the parsed date,\n"
"                              and warn about questionable usage to stderr\n"
msgstr ""
"      --debug                анотувати оброблену дату,\n"
"                              і попередити щодо проблем до stderr\n"

#: src/date.c:148
msgid ""
"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\n"
msgstr ""
"  -f, --file=ФАЙЛ_ДАТИ      подібний до --date для кожного з рядків "
"ФАЙЛ_ДАТИ\n"

#: src/date.c:151
msgid ""
"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n"
"                               FMT='date' for date only (the default),\n"
"                               'hours', 'minutes', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14T02:34:56-06:00\n"
msgstr ""
"  -I[СПЕЦЧАСУ], --iso-8601[=СПЕЦЧАСУ] вивести дату і час у форматі ISO "
"8601.\n"
"                            СПЕЦЧАСУ='date' визначає лише дату (типово),\n"
"                            'hours', 'minutes', 'seconds' і 'ns' -- дата і\n"
"                            час із відповідною точністю.\n"
"                            Приклад: 2006-08-14T02:34:56-06:00\n"

#: src/date.c:158
msgid ""
"  -R, --rfc-email            output date and time in RFC 5322 format.\n"
"                               Example: Mon, 14 Aug 2006 02:34:56 -0600\n"
msgstr ""
"  -R,  --rfc-email           виводити час відповідно до RFC 5322\n"
"                            Приклад: Mon, 14 Aug 2006 02:34:56 -0600\n"

#: src/date.c:162
msgid ""
"      --rfc-3339=FMT         output date/time in RFC 3339 format.\n"
"                               FMT='date', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14 02:34:56-06:00\n"
msgstr ""
"       --rfc-3339[=СПЕЦ]     вивести дату/час у форматі RFC 3339\n"
"                               СПЕЦ='date', 'seconds' або 'ns' для "
"отримання\n"
"                               дати та часу з вказаною точністю.\n"
"                               Приклад: 2006-08-14 02:34:56-06:00\n"

#: src/date.c:168
msgid ""
"  -r, --reference=FILE       display the last modification time of FILE\n"
msgstr "  -r,  --reference=ФАЙЛ     показати час останньої зміни ФАЙЛа\n"

#: src/date.c:171
msgid ""
"  -s, --set=STRING           set time described by STRING\n"
"  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n"
msgstr ""
"  -s,  --set=РЯДОК          встановити час, що описується РЯДКОМ\n"
"  -u, --utc, --universal    показати або встановити універсальний\n"
"                            координований час (UTC)\n"

#: src/date.c:177
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"ФОРМАТ керує виводом.  Розпізнаються послідовності:\n"
"\n"
"  %%   знак %\n"
"  %a   місцева скорочена назва дня тижня (напр., нед)\n"

#: src/date.c:184
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A   місцева повна назва дня тижня (напр., понеділок)\n"
"  %b   місцева скорочена назва місяця (напр., січ)\n"
"  %B   місцева повна назва місяця (напр., січень)\n"
"  %c   місцевий час та дата (напр., Чтв 3 Мар 23:05:25 2005)\n"

#: src/date.c:190
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C   століття; як %Y, але без двох останніх цифр (наприклад 20)\n"
"  %d   день місяця (наприклад 01)\n"
"  %D   дата; те саме, що і %m/%d/%y\n"
"  %e   день місяця, доповнений пробілами; те саме, що і %_d\n"

#: src/date.c:196
msgid ""
"  %F   full date; like %+4Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   повна дата; еквівалентно %+4Y-%m-%d\n"
"  %g   останні дві цифри року для номера тижня ISO (см. %G)\n"
"  %G   рік для номера тижня ISO (см. %V); звичайно буває корисно лише з %V\n"

#: src/date.c:201
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   те саме, що й %b\n"
"  %H   час (00..23)\n"
"  %I   час (01..12)\n"
"  %j   номер дня у році (001..366)\n"

#: src/date.c:207
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   час з доповненням пробілом ( 0..23); те саме, що і %_H\n"
"  %l   час з доповненням пробілом ( 1..12); те саме, що і %_I\n"
"  %m   місяць (01..12)\n"
"  %M   хвилини (00..59)\n"

#: src/date.c:213
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %q   quarter of year (1..4)\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n   новий рядок\n"
"  %N   наносекунди (000000000..999999999)\n"
"  %p   місцевий еквівалент AM або PM; пропускається якщо невідомо\n"
"  %P   як %p, але малими літерами\n"
"  %q   квартал року (від 1 до 4)\n"
"  %r   час відповідно до локалі, 12-годинний формат (напр., 11:11:04 PM)\n"
"  %R   години та хвилини відповідно до локалі, 24-годинний формат; аналог %H:"
"%M\n"
"  %s   число секунд, що минули з 1970-01-01 00:00:00  UTC\n"

#: src/date.c:223
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S   секунди (00..60)\n"
"  %t   табуляція\n"
"  %T   час, аналог %H:%M:%S\n"
"  %u   день тижня (1..7);  1 означає понеділок\n"

#: src/date.c:229
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   номер тижня у році, якщо перший день тижня -- неділя (00..53)\n"
"  %V   номер тижня по ISO, якщо перший день тижня -- понеділок (01..52)\n"
"  %w   день тижня (0..6), 0 означає неділю\n"
"  %W   номер тижня у році, якщо перший день тижня -- понеділок (00..53)\n"

#: src/date.c:235
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x   місцеве представлення дати (напр., дд/мм/рр)\n"
"  %X   місцеве представлення часу (напр.,  23:13:48)\n"
"  %y   останні дві цифри року (00..99)\n"
"  %Y   рік\n"

#: src/date.c:241
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z   +ггхх часовий пояс (наприклад -0400)\n"
"  %:z  +гг:хх часовий пояс (наприклад -04:00)\n"
"  %::z +гг:хх:сс часовий пояс (наприклад -04:00:00)\n"
"  %:::z часовий пояс з достатньою кількістю двокрапок (наприклад -04, "
"+05:30)\n"
"  %Z   алфавітне скорочення часового поясу (наприклад EDT)\n"
"\n"
"Типово date доповнює числові поля нулями.\n"

#: src/date.c:250
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  +  pad with zeros, and put '+' before future years with >4 digits\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"Після '%' можуть йти наступні необов'язкові ознаки:\n"
"\n"
"  - (дефіс) не доповнювати це поле\n"
"  _ (підкреслення) доповнювати пробілами\n"
"  0 (нуль) доповнювати нулями\n"
"  + доповнювати нулями і додавати + перед роками у майбутньому, у яких >4 "
"цифр\n"
"  ^ використовувати верхній регістр, якщо можливо\n"
"  # використовувати протилежний регістр, якщо можливо\n"

#: src/date.c:260
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"Після будь-якої з ознак йде необов'язкова ширина поля у вигляді "
"десяткового;\n"
"числа потім необов'язковий модифікатор, один з наступних:\n"
"E -- якщо можливо, вживати альтернативне представлення для поточної локалі\n"
"O -- якщо можливо, використовувати альтернативні числові символи локалі.\n"

#: src/date.c:267
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""
"\n"
"Приклади:\n"
"Перетворити секунди з початку епохи (1970-01-01 UTC) у дату\n"
"  $ date --date='@2147483647'\n"
"\n"
"Показати час у Києві США (скористайтеся tzselect(1) для визначення TZ)\n"
"  $ TZ='Europe/Kiev' date\n"
"\n"
"Показати локальний час для 9:00 наступної п'ятниці у Києві\n"
"  $ date --date='TZ=\"Europe/Kiev\" 09:00 next Fri'\n"

#: src/date.c:301 src/dd.c:2475 src/head.c:881 src/md5sum.c:672
#: src/md5sum.c:1107 src/od.c:915 src/od.c:1984 src/pr.c:1149 src/pr.c:1348
#: src/pr.c:1471 src/stty.c:1368 src/tac.c:574 src/tail.c:387 src/tee.c:174
#: src/tr.c:1911 src/tsort.c:535 src/wc.c:223
msgid "standard input"
msgstr "стандартний ввід"

#: src/date.c:330 src/date.c:558
#, c-format
msgid "invalid date %s"
msgstr "неправильна дата %s"

#: src/date.c:444 src/date.c:478
msgid "multiple output formats specified"
msgstr "задано декілька вихідних форматів"

#: src/date.c:456
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "ключі для виводу дати взаємно виключають друг друга"

#: src/date.c:463
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr ""
"ключі для встановлення та для відображення часу не можуть застосовуватись "
"разом"

#: src/date.c:484
#, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""
"аргумент %s не починається зі знаку '+';\n"
"При вказуванні дати, кожен аргумент, що не є ключем, повинен мати\n"
"символьний формат та починатись зі знаку '+'."

#: src/date.c:566
#, c-format
msgid "cannot set date"
msgstr "не вдалося встановити дату"

#: src/date.c:600 src/du.c:389
#, c-format
msgid "time %s is out of range"
msgstr "час %s поза допустимим діапазоном"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:44 src/factor.c:128 src/rm.c:40 src/tail.c:76 src/touch.c:42
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:558
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ОПЕРАНД]...\n"
"       або:    %s КЛЮЧ\n"

#: src/dd.c:563
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time (default: "
"512);\n"
"                  overrides ibs and obs\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"Копіює файл, перетворює та форматує залежно від операндів.\n"
"\n"
"  bs=ЧИСЛО        примусово вести запис і читання порціями у ЧИСЛО байтів "
"(типово 512);\n"
"                  має вищий пріоритет за ibs і obs\n"
"\n"
"  cbs=ЧИСЛО       перетворювати вказане ЧИСЛО байт за раз\n"
"  conv=СПИСОК     перетворювати файл відповідно до СПИСКУ символів,\n"
"                  елементи має бути розділено комами\n"
"  count=ЧИСЛО     копіювати лише вказане ЧИСЛО вхідних блоків\n"
"  ibs=ЧИСЛО       читати вказане ЧИСЛО байт за раз (типово 512)\n"

#: src/dd.c:573
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          skip N obs-sized blocks at start of output\n"
"  skip=N          skip N ibs-sized blocks at start of input\n"
"  status=LEVEL    The LEVEL of information to print to stderr;\n"
"                  'none' suppresses everything but error messages,\n"
"                  'noxfer' suppresses the final transfer statistics,\n"
"                  'progress' shows periodic transfer statistics\n"
msgstr ""
"  if=ФАЙЛ         читати ФАЙЛ, а не стандартне введення\n"
"  iflag=СПИСОК    читати відповідно до СПИСКУ символів,\n"
"                  пункти слід відокремлювати комами\n"
"  obs=ЧИСЛО       записувати вказане ЧИСЛО байт за раз (типово 512)\n"
"  of=ФАЙЛ         записувати у ФАЙЛ, а не у стандартне виведення\n"
"  oflag=СПИСОК    записувати відповідно до списку символів,\n"
"                  пункти слід відокремлювати комами\n"
"  seek=N          пропустити з початку виводу N блоків розміром obs\n"
"  skip=N          пропустити з початку вводу N блоків розміром ibs\n"
"  status=РЕЖИМ    РЕЖИМ придушення виведення даних до stderr;\n"
"                  «noxfer» — придушити виведення статистики передавання,\n"
"                  «none» — придушити виведення будь-яких даних,\n"
"                  «progress» — періодично показувати статистику роботи\n"

#: src/dd.c:586
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n"
"GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"Після ЧИСЛА і БАЙТів може бути вказано один з множників:\n"
"c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M,\n"
"GB =1000*1000*1000, G =1024*1024*1024 тощо для T, P, E, Z, Y.\n"
"Можна також використовувати двійкові префікси: KiB=K, MiB=M тощо.\n"
"\n"
"Кожен елемент СПИСКУ для conv може бути:\n"
"\n"

#: src/dd.c:596
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write all-NUL output blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii     з EBCDIC на ASCII\n"
"  ebcdic    з ASCII на EBCDIC\n"
"  ibm       з ASCII на альтернативну EBCDIC\n"
"  block     заповнювати записи, що закінчуються переносом рядка, пробілами\n"
"            до розміру cbs\n"
"  unblock   замінювати кінцеві пробіли у записах з розміром cbs переносом "
"рядка\n"
"  lcase     змінювати регістр з верхнього на нижній\n"
"  ucase     змінювати регістр з нижнього на верхній\n"
"  sparse    спробувати виконати позиціювання замість запису до виведення "
"вихідних\n"
"              блоків, які складаються лише із символів NUL\n"
"  swab      міняти місцями кожну пару вхідних байтів\n"
"  sync      доповнювати кожен вхідний блок нулями до розміру ibs; якщо\n"
"              вживається разом з block або unblock, доповнювати пробілами\n"

#: src/dd.c:609
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl      завершаться помилкою, якщо файл виводу уже існує\n"
"  nocreat   не створювати файл виводу\n"
"  notrunc   не обрізати файл виводу\n"
"  noerror   продовжувати після помилок читання\n"
"  fdatasync фізично записати файл виводу перед завершенням\n"
"  fsync     аналогічно, але записати також метадані\n"

#: src/dd.c:617
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"Символ-ОЗНАКА може бути таким:\n"
"\n"
"  append    режим додавання (має сенс для виводу; рекомендується  "
"conv=notrunc)\n"

#: src/dd.c:624
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio       використовувати конкурентне введення-виведення для дати\n"

#: src/dd.c:626
msgid "  direct    use direct I/O for data\n"
msgstr "  direct    використовувати прямий ввід/вивід для даних\n"

#: src/dd.c:628
msgid "  directory  fail unless a directory\n"
msgstr "  directory  помилка, якщо не є каталогом\n"

#: src/dd.c:630
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     використовувати синхронізований ввід/вивід для даних\n"

#: src/dd.c:632
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync      те саме, але також для метаданих\n"

#: src/dd.c:633
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock  акумулювати повні блоки вводу (лише iflag)\n"

#: src/dd.c:636
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock  використовувати ввід/вивід без блокування\n"

#: src/dd.c:638
msgid "  noatime   do not update access time\n"
msgstr "  noatime   не оновлювати час останнього доступу\n"

#: src/dd.c:641
msgid "  nocache   Request to drop cache.  See also oflag=sync\n"
msgstr ""
"  nocache   надіслати запит щодо відкидання кеш. Див. також oflag=sync\n"

#: src/dd.c:645
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty    не призначати керівний термінал з файла\n"

#: src/dd.c:648
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  не слідувати за символьним посиланням\n"

#: src/dd.c:650
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks   помилка, якщо знайдено декілька посилань\n"

#: src/dd.c:652
msgid "  binary    use binary I/O for data\n"
msgstr "  binary    використовувати двійковий ввід/вивід для даних\n"

#: src/dd.c:654
msgid "  text      use text I/O for data\n"
msgstr "  text      використовувати текстовий ввід/вивід для даних\n"

#: src/dd.c:656
msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
msgstr ""
"  count_bytes  вважати «count=N» визначенням кількості байтів (лише для "
"iflag)\n"

#: src/dd.c:659
msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
msgstr ""
"  skip_bytes  вважати «skip=N» визначенням кількості байтів (лише для "
"iflag)\n"

#: src/dd.c:662
msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
msgstr ""
"  seek_bytes  вважати «seek=N» визначенням кількості байтів (лише для "
"oflag)\n"

#: src/dd.c:666
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"Надсилання сигналу %s до запущеного процесу «dd» призводить до\n"
"виведення даних щодо введення-виведення до стандартного буфера\n"
"помилок з наступним відновленням копіювання.\n"
"\n"
"Параметри:\n"
"\n"

#: src/dd.c:702
#, c-format
msgid "memory exhausted by input buffer of size %<PRIuMAX> bytes (%s)"
msgstr ""
"пам'ять вичерпано буфером введення даних розміром у %<PRIuMAX> байтів (%s)"

#: src/dd.c:730
#, c-format
msgid "memory exhausted by output buffer of size %<PRIuMAX> bytes (%s)"
msgstr ""
"пам'ять вичерпано буфером виведення даних розміром у %<PRIuMAX> байтів (%s)"

#: src/dd.c:798 src/du.c:401
msgid "Infinity"
msgstr "Нескінченість"

#: src/dd.c:817
#, c-format
msgid "%<PRIuMAX> byte copied, %s, %s"
msgid_plural "%<PRIuMAX> bytes copied, %s, %s"
msgstr[0] "скопійовано %<PRIuMAX> байт, %s, %s"
msgstr[1] "скопійовано %<PRIuMAX> байти, %s, %s"
msgstr[2] "скопійовано %<PRIuMAX> байтів, %s, %s"

#: src/dd.c:823
#, c-format
msgid "%<PRIuMAX> bytes (%s) copied, %s, %s"
msgstr "скопійовано %<PRIuMAX> байтів (%s), %s, %s"

#: src/dd.c:826
#, c-format
msgid "%<PRIuMAX> bytes (%s, %s) copied, %s, %s"
msgstr "скопійовано %<PRIuMAX> байтів (%s, %s), %s, %s"

#: src/dd.c:858
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"%<PRIuMAX>+%<PRIuMAX> записів прочитано\n"
"%<PRIuMAX>+%<PRIuMAX> записів записано\n"

#: src/dd.c:864
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> обрізаний запис\n"
msgstr[1] "%<PRIuMAX> обрізані записи\n"
msgstr[2] "%<PRIuMAX> обрізаних записів\n"

#: src/dd.c:966
#, c-format
msgid "closing input file %s"
msgstr "закриття вхідного файла %s"

#: src/dd.c:973
#, c-format
msgid "closing output file %s"
msgstr "закриття файла виводу %s"

#: src/dd.c:1207
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "не вдалося вимкнути O_DIRECT: %s"

#: src/dd.c:1282 src/dd.c:2202
#, c-format
msgid "writing to %s"
msgstr "запис у %s"

#: src/dd.c:1452
#, c-format
msgid "warning: %s is a zero multiplier; use %s if that is intended"
msgstr ""
"попередження: %s є нульовим множником; скористайтеся %s, якщо так було "
"зроблено зумисне"

#: src/dd.c:1490 src/dd.c:1551
#, c-format
msgid "unrecognized operand %s"
msgstr "операнд %s не розпізнаний"

#: src/dd.c:1502
msgid "invalid conversion"
msgstr "неприпустиме перетворення"

#: src/dd.c:1505 src/dd.c:1594
msgid "invalid input flag"
msgstr "неприпустима ознака входу"

#: src/dd.c:1508 src/dd.c:1588 src/dd.c:1600
msgid "invalid output flag"
msgstr "неприпустимий ознака виводу"

#: src/dd.c:1511
msgid "invalid status level"
msgstr "некоректний рівень стану"

#: src/dd.c:1646
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "не можна одночасно використовувати будь-які два з {ascii,ebcdic,ibm}"

#: src/dd.c:1648
msgid "cannot combine block and unblock"
msgstr "не можна одночасно використовувати block та unblock"

#: src/dd.c:1650
msgid "cannot combine lcase and ucase"
msgstr "не можна одночасно використовувати lcase та ucase"

#: src/dd.c:1652
msgid "cannot combine excl and nocreat"
msgstr "не можна одночасно використовувати excl та nocreat"

#: src/dd.c:1655
msgid "cannot combine direct and nocache"
msgstr "не можна одночасно використовувати direct і nocache"

#: src/dd.c:1812
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"попередження: обходиться помилка lseek у ядрі для файла (%s)\n"
"  mt_type=0x%0lx -- см. <sys/mtio.h> для списку типів"

#: src/dd.c:1900
#, c-format
msgid "%s: cannot skip"
msgstr "%s: не вдалося пропустити"

#: src/dd.c:1902 src/dd.c:1933 src/dd.c:1994
#, c-format
msgid "%s: cannot seek"
msgstr "%s: не вдалося зсунути вказівник файла"

#: src/dd.c:1974
#, c-format
msgid "offset overflow while reading file %s"
msgstr "переповнення зсуву при читанні файла %s"

#: src/dd.c:1986
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "попередження: некоректний зсув файла після помилки читання"

#: src/dd.c:1990
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "не вдалося обійти помилку ядра"

#: src/dd.c:2129
#, c-format
msgid "setting flags for %s"
msgstr "встановлення ознак для %s"

#: src/dd.c:2183
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s: не вдалося перемістити вказівник позиції на вказану кількість"

#: src/dd.c:2412
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr "не вдалося обрізати до %<PRIdMAX> у файлі виведення даних %s"

#: src/dd.c:2425
#, c-format
msgid "fdatasync failed for %s"
msgstr "операція fdatasync для %s завершилась помилкою"

#: src/dd.c:2433
#, c-format
msgid "fsync failed for %s"
msgstr "операція fsync для %s завершилась помилкою"

#: src/dd.c:2481 src/dd.c:2511 src/nohup.c:157 src/nohup.c:159
#, c-format
msgid "failed to open %s"
msgstr "не вдалося відкрити %s"

#: src/dd.c:2521
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr ""
"зсув надто великий: не вдалося обрізати до величини seek=%<PRIuMAX> (%lu-"
"байтних) блоків"

#: src/dd.c:2542
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "не вдалося обрізати до %<PRIuMAX> у файлі виведення даних %s"

#: src/dd.c:2559 src/dd.c:2565
#, c-format
msgid "failed to discard cache for: %s"
msgstr "помилка під час відкидання кешу для %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:50 src/du.c:56 src/expr.c:153 src/kill.c:34 src/pathchk.c:31
#: src/shuf.c:41 src/sleep.c:35 src/sort.c:68
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:182
msgid "Filesystem"
msgstr "Ф. система"

#: src/df.c:185
msgid "Type"
msgstr "Тип"

#: src/df.c:188 src/df.c:602
msgid "blocks"
msgstr "блоків"

#: src/df.c:191
msgid "Used"
msgstr "Вик"

#: src/df.c:194
msgid "Available"
msgstr "Доступно"

#: src/df.c:197
msgid "Use%"
msgstr "Вик%"

#: src/df.c:200
msgid "Inodes"
msgstr "І-вузлів"

#: src/df.c:203
msgid "IUsed"
msgstr "Викор"

#: src/df.c:206
msgid "IFree"
msgstr "Вільн"

#: src/df.c:209
msgid "IUse%"
msgstr "Вик%"

#: src/df.c:212
msgid "Mounted on"
msgstr "змонтований на"

#: src/df.c:215
msgid "File"
msgstr "Файл"

#: src/df.c:442
#, c-format
msgid "option --output: field %s unknown"
msgstr "параметр --output: поле %s є невідомим"

#: src/df.c:449
#, c-format
msgid "option --output: field %s used more than once"
msgstr "параметр --output: поле %s використано декілька разів"

#: src/df.c:470 src/df.c:509
msgid "Size"
msgstr "Розм"

#: src/df.c:474 src/df.c:511
msgid "Avail"
msgstr "Дост"

#: src/df.c:534
msgid "Capacity"
msgstr "Всього"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:605 src/df.c:614
#, c-format
msgid "%s-%s"
msgstr "%s-%s"

#: src/df.c:1343
#, c-format
msgid "cannot access %s: over-mounted by another device"
msgstr "не вдалося отримати доступ до %s: повторно змонтовано іншим пристроєм"

#: src/df.c:1512
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr ""
"Показати інформацію про файлову систему, на якій розташований кожен\n"
"з ФАЙЛІВ, або, типово, про усі файлові системи.\n"

#. TRANSLATORS: The thousands and decimal separators are best
#. adjusted to an appropriate default for your locale.
#: src/df.c:1521
msgid ""
"  -a, --all             include pseudo, duplicate, inaccessible file "
"systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n"
"  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n"
msgstr ""
"  -a, --all             включати несправжні, дубльовані, недоступні файлові "
"системи\n"
"  -B, --block-size=РОЗМІР використовувати блоки вказаного РОЗМІРУ. Приклад:\n"
"                           «-BM» виводить розміри у одиницях у 1.048.576 "
"байтів.\n"
"                           Формат РОЗМІР описано нижче.\n"
"  -h, --human-readable  виводити розміри у зручному для людини вигляді\n"
"                         (наприклад, 1023M)\n"
"  -H, --si              те саме, але використовувати степені 1000 "
"(наприклад, 1.1G)\n"

#: src/df.c:1529
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes          вивести інформацію про індексні дескриптори, а не "
"про\n"
"                        використання блоків\n"
"  -k                    аналог --block-size=1K\n"
"  -l, --local           перерахувати лише локальні файлові системи\n"
"      --no-sync         не викликати sync перед отриманням інформації про\n"
"                        використання блоків (типово)\n"

#: src/df.c:1536
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
msgstr ""
"      --output[=СПИСОК_ПОЛІВ]  використовувати формат виведення, визначений "
"СПИСКОМ_ПОЛІВ,\n"
"                               або вивести всі поля, якщо СПИСОК_ПОЛІВ не "
"вказано.\n"
"  -P, --portability     виводити у форматі POSIX\n"
"      --sync            викликати sync перед отриманням інформації про\n"
"                        використання блоків\n"

#: src/df.c:1542
msgid ""
"      --total           elide all entries insignificant to available space,\n"
"                          and produce a grand total\n"
msgstr ""
"      --total           пропустити усі записи, які не пов’язано із доступним "
"місцем,\n"
"                          і вивести загальні підсумки\n"

#: src/df.c:1546
msgid ""
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -t, --type=ТИП        перерахувати лише файлові системи вказаного ТИПУ\n"
"  -T, --print-type      виводити тип файлової системи\n"
"  -x, --exclude-type=ТИП  виключати файлові системи вказаного ТИПУ\n"
"  -v                    (ігнорується)\n"

#: src/df.c:1556
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n"
msgstr ""
"\n"
"СПИСОК_ПОЛІВ — відокремлений комами список стовпчиків, які слід включити.\n"
"Можливі назви стовпчиків: 'source', 'fstype', 'itotal', 'iused', 'iavail', "
"'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file'  і 'target' (див. сторінку info).\n"

#: src/df.c:1593
#, c-format
msgid "options %s and %s are mutually exclusive"
msgstr "параметри %s і %s не можна використовувати одночасно"

#: src/df.c:1743
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "файлова система типа %s і вибрана, і виключена"

#: src/df.c:1802
msgid "Warning: "
msgstr "Попередження: "

#: src/df.c:1804 src/stat.c:944
msgid "cannot read table of mounted file systems"
msgstr "%помилка при читані змонтованих файлових систем"

#: src/df.c:1841
msgid "no file systems processed"
msgstr "не вказана жодна файлова система"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:37
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:100
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"Видає команди для встановлення змінної оточення LS_COLORS.\n"
"\n"
"Вказати формат виводу:\n"
"  -b, --sh, --bourne-shell    вивести код для встановлення LS_COLORS у\n"
"                               Bourne shell\n"
"  -c, --csh, --c-shell        вивести код для встановлення LS_COLORS у C "
"shell\n"
"  -p, --print-database        вивести типові параметри\n"
"      --help                  показати довідку та вийти\n"
"      --version               вивести інформацію про версію та вийти\n"

#: src/dircolors.c:110
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""
"\n"
"Якщо вказаний FILE, то читати його щоб дізнатись які кольори яким\n"
"розширенням призначені. Інакше використовувати типову базу даних. Для\n"
"докладнішого опису формату FILE запустите dircolors --print-database.\n"

#: src/dircolors.c:288
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: неправильний рядок; пропущена друга лексема"

#: src/dircolors.c:360
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu ключове слово %s не розпізнано"

#: src/dircolors.c:361
msgid "<internal>"
msgstr "<внутрішній>"

#: src/dircolors.c:442
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"ключі для виводу внутрішньої бази даних dircolors та ключі для вибору\n"
"синтаксису оболонки взаємно виключають друг друга"

#: src/dircolors.c:452
msgid "file operands cannot be combined with --print-database (-p)"
msgstr ""
"Операнди-файли не можна одночасно використовувати з --print-database (-p)"

#: src/dircolors.c:475
msgid "no SHELL environment variable, and no shell type option given"
msgstr "або змінна оточення SHELL відсутня, або не вказаний тип інтерпретатору"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "Використання: %s [КЛЮЧ] НАЗВА...\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""
"Виводить всі НАЗВИ, вилучаючи компоненту праворуч від останньої похилої "
"риски;\n"
"якщо НАЗВА не містить похилої риски, виводить «.» (тобто поточний каталог).\n"
"\n"

#: src/dirname.c:59
msgid "  -z, --zero     end each output line with NUL, not newline\n"
msgstr ""
"  -z, --zero     завершувати кожен рядок нуль-байтом замість розриву рядка\n"

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""
"\n"
"Приклади:\n"
"  %s /usr/bin/          -> «/usr»\n"
"  %s dir1/str dir2/str  -> «dir1», потім «dir2»\n"
"  %s stdio.h            -> «.»\n"

#: src/du.c:285 src/sort.c:415 src/wc.c:118
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"
"       або:    %s [КЛЮЧ]... --files0-from=Ф\n"

#: src/du.c:289
msgid ""
"Summarize disk usage of the set of FILEs, recursively for directories.\n"
msgstr ""
"Сумарне використання дискового простору набору ФАЙЛів, рекурсивно для "
"каталогів.\n"

#: src/du.c:295
msgid ""
"  -0, --null            end each output line with NUL, not newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -0, --null            завершувати кожен рядок виведених даних нуль-байтом "
"замість символу\n"
"                          нового рядка\n"
"  -a, --all             виводить обсяг для усіх файлів, а не лише каталогів\n"
"      --apparent-size   виводить дійсні розміри, а не зайнятий дисковий\n"
"                          простір; хоча справжній розмір звичайно менший,\n"
"                          іноді він може бути більшим через дірки у файлах,\n"
"                          внутрішньої фрагментації, непрямих блоків та т.і.\n"

#: src/du.c:304
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -B, --block-size=РОЗМІР використовувати блоки вказаного РОЗМІРУ. Приклад:\n"
"                           «-BM» виводить розміри у одиницях у 1.048.576 "
"байтів.\n"
"                           Формат РОЗМІР описано нижче.\n"
"  -b, --bytes           еквівалент «--apparent-size --block-size=1»\n"
"  -c, --total           підбивати підсумок\n"
"  -D, --dereference-args  розіменовувати символьні посилання у командному\n"
"                          рядку\n"
"  -d, --max-depth=Н     виводити підсумки для каталогу (або файла, якщо "
"вказано --all),\n"
"                          лише, якщо він перебуває на Н-му або нижчому рівні "
"відносно\n"
"                          аргументу командного рядка;  --max-depth=0 — те "
"саме, що і для\n"
"                          --summarize\n"

#: src/du.c:317
msgid ""
"      --files0-from=F   summarize disk usage of the\n"
"                          NUL-terminated file names specified in file F;\n"
"                          if F is -, then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --inodes          list inode usage information instead of block usage\n"
msgstr ""
"      --files0-from=Ф   вивести звіт про файли, чиї назви (завершені\n"
"                          нулем) перераховані у файлі Ф\n"
"                          Якщо Ф вказано - назви беруться зі стандартного "
"вводу\n"
"  -H                    еквівалент ключа --dereference-args (-D)\n"
"  -h, --human-readable  виводити розміри у зручному для людини вигляді\n"
"                          (наприклад 1K 234M 2G)\n"
"      --inodes          вивести дані щодо використання inode замість даних "
"щодо використання блоків\n"

#: src/du.c:326
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k                    як --block-size=1K\n"
"  -L, --dereference     розіменувати всі символічні посилання\n"
"  -l, --count-links     прочитати кожне жорстке посилання як окремий файл\n"
"  -m                    як --block-size=1M\n"

#: src/du.c:332
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   for directories do not include size of "
"subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -P, --no-dereference  не слідувати за символьним посиланням (типово)\n"
"  -S, --separate-dirs   не включати розмір підкаталогів\n"
"      --si              подібне до -h, але з використанням мір, кратних до "
"1000, а не 1024\n"
"  -s, --summarize       виводити лише зведення для кожного аргументу\n"

#: src/du.c:338
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using STYLE, which can be:\n"
"                            full-iso, long-iso, iso, or +FORMAT;\n"
"                            FORMAT is interpreted like in 'date'\n"
msgstr ""
"  -t, --threshold=РОЗМІР  виключити записи, менші за РОЗМІР, якщо додатне,\n"
"                          або записи, більші за РОЗМІР, якщо від'ємне\n"
"      --time            виводити час останньої зміни будь-якого файла у\n"
"                          каталозі або усіх його підкаталогів\n"
"      --time=СЛОВО      виводити вказаний у СЛОВО час, а не час \n"
"                          зміни: atime, access, use, ctime або status\n"
"      --time-style=СТИЛЬ виводити час, використовуючи СТИЛЬ:\n"
"                          full-iso, long-iso, iso, +ФОРМАТ\n"
"                          ФОРМАТ інтерпретується як у 'date'\n"

#: src/du.c:349
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""
"  -X, --exclude-from=ФАЙЛ  виключити файли, назви яких відповідають зразку з "
"ФАЙЛа\n"
"      --exclude=ЗРАЗОК     виключити файли, назви яких відповідають ЗРАЗКУ\n"
"  -x, --one-file-system    пропускати каталоги на різних файлових системах\n"

#: src/du.c:696
#, c-format
msgid "fts_read failed: %s"
msgstr "помилка fts_read: %s"

#: src/du.c:820
#, c-format
msgid "invalid maximum depth %s"
msgstr "неприпустима максимальна глибина %s"

#: src/du.c:849
msgid "invalid --threshold argument '-0'"
msgstr "некоректний аргумент --threshold «-0»"

#: src/du.c:932
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "не можна одночасно підбивати зведення та виводити всі елементи"

#: src/du.c:939
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "попередження: підбиття зведення це те ж саме, що й --max-depth=0"

#: src/du.c:945
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "попередження: підбиття зведення конфліктує з --max-depth=%lu"

#: src/du.c:956
#, c-format
msgid "warning: options --apparent-size and -b are ineffective with --inodes"
msgstr ""
"попередження: параметри --apparent-size і -b не працюватимуть з --inodes"

#: src/du.c:1021 src/sort.c:4598 src/wc.c:760
msgid "file operands cannot be combined with --files0-from"
msgstr "операнди-файли не можна використовувати разом з --files0-from"

#: src/du.c:1088 src/sort.c:4619 src/wc.c:838
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "при читанні імен файлів з stdin, не допускаються назви файлів %s"

#: src/du.c:1105 src/du.c:1113 src/wc.c:851 src/wc.c:859
msgid "invalid zero-length file name"
msgstr "неправильна назва файла нульової довжини"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:28
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:42
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Використання: %s [СКОРОЧЕНИЙ-ПАРАМЕТР]... [РЯДОК]...\n"
"  або  %s ДОВГИЙ-ПАРАМЕТР\n"

#: src/echo.c:46
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"Виводить РЯДОК(РЯДКА) на стандартний вивід.\n"
"\n"
"  -n             не виводити завершальне переведення рядка\n"

#: src/echo.c:52
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e             інтерпретувати керівні послідовності (типово)\n"
"  -E             не інтерпретувати керівні послідовності\n"

#: src/echo.c:55
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e             інтерпретувати керівні послідовності\n"
"  -E             не інтерпретувати керівні послідовності (типово)\n"

#: src/echo.c:61
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"Якщо задіяно -e, розпізнаються такі послідовності:\n"
"\n"

#: src/echo.c:66 src/printf.c:110
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\      зворотна риска\n"
"  \\a      дзвінок (BEL)\n"
"  \\b      backspace\n"
"  \\c      не виводити завершальний символ нового рядка\n"
"  \\e      escape\n"
"  \\f      нова сторінка\n"
"  \\n      новий рядок\n"
"  \\r      переведення каретки\n"
"  \\t      горизонтальна табуляція\n"
"  \\v      вертикальна табуляція\n"

#: src/echo.c:78
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   байт з вісімковим значенням NNN (від 1 до 3 цифр)\n"
"  \\xHH    байт з шістнадцятковим значенням HH (від 1 до 2 цифр)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:38 src/printenv.c:45 src/whoami.c:35
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:112
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-] [НАЗВА=ЗНАЧЕННЯ]... [КОМАНДА [АРГ]...]\n"

#: src/env.c:115
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr ""
"Встановлює кожній НАЗВІ відповідне ЗНАЧЕННЯ та запускає КОМАНДУ у цьому\n"
"середовищі.\n"

#: src/env.c:121
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with NUL, not newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"  -i, --ignore-environment   почати з порожнім оточенням\n"
"  -0, --null                 завершувати кожен з виведених рядків нуль-"
"байтом, а не розривом рядка\n"
"  -u, --unset=НАЗВА          вилучити з оточення НАЗВИ\n"

#: src/env.c:126
msgid "  -C, --chdir=DIR      change working directory to DIR\n"
msgstr "  -C, --chdir=КАТАЛОГ  змінити робочий каталог на вказаний\n"

#: src/env.c:129
msgid ""
"  -S, --split-string=S  process and split S into separate arguments;\n"
"                        used to pass multiple arguments on shebang lines\n"
msgstr ""
"  -S, --split-string=S  обробити і поділити S на окремі аргументи;\n"
"                        використовується для передавання декількох "
"аргументів\n"
"                        у рядках із #!\n"

#: src/env.c:133
msgid ""
"      --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\n"
msgstr ""
"      --block-signal[=СИГНАЛ] блокувати доставлення сигналів СИГНАЛ до "
"КОМАНДИ\n"

#: src/env.c:136
msgid ""
"      --default-signal[=SIG]  reset handling of SIG signal(s) to the "
"default\n"
msgstr ""
"      --default-signal[=СИГ]  відновити типовий режим обробки сигналів СИГ\n"

#: src/env.c:139
msgid ""
"      --ignore-signal[=SIG]   set handling of SIG signals(s) to do nothing\n"
msgstr ""
"      --ignore-signal[=СИГ]   встановити режим «нічого не робити» для "
"сигналів СИГ\n"

#: src/env.c:142
msgid ""
"      --list-signal-handling  list non default signal handling to stderr\n"
msgstr ""
"      --list-signal-handling  вивести список нетипової обробки сигналів до "
"stderr\n"

#: src/env.c:145
msgid ""
"  -v, --debug          print verbose information for each processing step\n"
msgstr ""
"  -v, --verbose          вивести діагностичні дані для кожного кроку "
"обробки\n"

#: src/env.c:150
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"Просто '-' -- синонім для '-i'.  Якщо не вказана КОМАНДА, виводить отримане\n"
"оточення.\n"

#: src/env.c:154
msgid ""
"\n"
"SIG may be a signal name like 'PIPE', or a signal number like '13'.\n"
"Without SIG, all known signals are included.  Multiple signals can be\n"
"comma-separated.\n"
msgstr ""
"\n"
"СИГ може бути назвою сигналу, як PIPE, або номером сигналу, як\n"
"13. Без значення СИГ, буде включено усі відомі сигнали. Сигнали\n"
"у списку слід відокремлювати комами.\n"

#: src/env.c:181
#, c-format
msgid "cannot unset %s"
msgstr "не вдалося вилучити %s"

#: src/env.c:315
msgid "'\\c' must not appear in double-quoted -S string"
msgstr "у рядку -S із подвійними лапками має бути «\\c»"

#: src/env.c:319
msgid "invalid backslash at end of string in -S"
msgstr "некоректна зворотна похила риска наприкінці рядка у -S"

#: src/env.c:322
#, c-format
msgid "invalid sequence '\\%c' in -S"
msgstr "некоректна послідовність «\\%c» у -S"

#: src/env.c:336
#, c-format
msgid "only ${VARNAME} expansion is supported, error at: %s"
msgstr "передбачено підтримку розгортання лише ${VARNAME}; помилка у: %s"

#: src/env.c:347
msgid "no terminating quote in -S string"
msgstr "немає завершальних лапок у рядку -S"

#: src/env.c:613 src/env.c:702 src/operand2sig.c:88
#, c-format
msgid "%s: invalid signal"
msgstr "%s: неправильний сигнал"

#: src/env.c:645
#, c-format
msgid "failed to get signal action for signal %d"
msgstr "не вдалося отримати дію за сигналом для сигналу %d"

#: src/env.c:653
#, c-format
msgid "failed to set signal action for signal %d"
msgstr "не вдалося встановити дію за сигналом для сигналу %d"

#: src/env.c:725 src/env.c:765
msgid "failed to get signal process mask"
msgstr "не вдалося отримати маску обробки сигналу"

#: src/env.c:754
msgid "failed to set signal process mask"
msgstr "не вдалося встановити маску обробки сигналу"

#: src/env.c:857
#, c-format
msgid "invalid option -- '%c'"
msgstr "некоректний параметр -- «%c»"

#: src/env.c:858 src/env.c:949
#, c-format
msgid "use -[v]S to pass options in shebang lines"
msgstr "скористайтеся -[v]S, щоб передати параметри у рядках із #!"

#: src/env.c:891
#, c-format
msgid "cannot set %s"
msgstr "не вдалося встановити %s"

#: src/env.c:901
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "не можна вказувати --null (-0) з командою"

#: src/env.c:907
#, c-format
msgid "must specify command with --chdir (-C)"
msgstr "слід вказати команду із --chdir (-C)"

#: src/env.c:932
#, c-format
msgid "cannot change directory to %s"
msgstr "не вдалося змінити каталог на %s"

#: src/expand-common.c:90
msgid "tabs are too far apart"
msgstr "позиції табуляції надто далеко одна від одної"

#: src/expand-common.c:103
#, c-format
msgid "'/' specifier only allowed with the last value"
msgstr "специфікатор «/» можна використовувати лише із останнім значенням"

#: src/expand-common.c:120
#, c-format
msgid "'+' specifier only allowed with the last value"
msgstr "специфікатор «+» можна використовувати лише із останнім значенням"

#: src/expand-common.c:172
#, c-format
msgid "'/' specifier not at start of number: %s"
msgstr "специфікатор «/» не розташовано перед числом: %s"

#: src/expand-common.c:183
#, c-format
msgid "'+' specifier not at start of number: %s"
msgstr "специфікатор «+» не розташовано перед числом: %s"

#: src/expand-common.c:204
#, c-format
msgid "tab stop is too large %s"
msgstr "розмір табуляції надто великий %s"

#: src/expand-common.c:212
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "розмір табуляції містить неприпустимий знак (знаки): %s"

#: src/expand-common.c:244
msgid "tab size cannot be 0"
msgstr "розмір табуляції не може дорівнювати нулю"

#: src/expand-common.c:246
msgid "tab sizes must be ascending"
msgstr "номера позицій табуляції повинні зростати"

#: src/expand-common.c:251
msgid "'/' specifier is mutually exclusive with '+'"
msgstr "«/» не можна використовувати разом із «+»"

#: src/expand-common.c:390
msgid "  -t, --tabs=LIST  use comma separated list of tab positions\n"
msgstr ""
"  -t, --tabs=СПИСОК використовувати розділений комами список позицій "
"табуляції\n"

#: src/expand-common.c:393
msgid ""
"                     The last specified position can be prefixed with '/'\n"
"                     to specify a tab size to use after the last\n"
"                     explicitly specified tab stop.  Also a prefix of '+'\n"
"                     can be used to align remaining tab stops relative to\n"
"                     the last specified tab stop instead of the first "
"column\n"
msgstr ""
"                     До останньої вказаної позиції можна додати префікс «/»\n"
"                     для визначення табуляції, якою слід скористатися після\n"
"                     останньої вказаної позиції табуляції. Також можна\n"
"                     вказати префікс «+» для вирівнювання решти табуляцій "
"до\n"
"                     останньої вказаної табуляції, а не до першого "
"стовпчика\n"

#: src/expand.c:73
msgid "Convert tabs in each FILE to spaces, writing to standard output.\n"
msgstr ""
"Перетворити табуляції у кожному з ФАЙЛів на пробіли, записати до\n"
"стандартного виведення.\n"

#: src/expand.c:80
msgid ""
"  -i, --initial    do not convert tabs after non blanks\n"
"  -t, --tabs=N     have tabs N characters apart, not 8\n"
msgstr ""
"  -i, --initial     не перетворювати знаки табуляції після знаків пробілів\n"
"  -t, --tabs=ЧИСЛО  встановлює ширину табуляції, типово 8\n"

#: src/expand.c:146 src/expand.c:165 src/unexpand.c:181 src/unexpand.c:226
msgid "input line is too long"
msgstr "вхідний рядок надто великий"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:51 src/mv.c:42 src/tee.c:36
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:37
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:345
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ВИРАЗ\n"
"       або:    %s КЛЮЧ\n"

#: src/expr.c:353
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"Виводить значення ВИРАЗУ на стандартний вивід.  Нижче порожніми рядками\n"
"розділені групи за зростанням пріоритету.  Можливі ВИРАЗИ:\n"
"\n"
"  АРГ1 | АРГ2       АРГ1, якщо він відмінний від нуля, інакше АРГ2\n"
"\n"
"  АРГ1 & АРГ2       АРГ1, якщо обидва відмінні від нуля, інакше 0\n"

#: src/expr.c:362
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  АРГ1 < АРГ2       АРГ1 менше АРГ2\n"
"  АРГ1 <= АРГ2      АРГ1 менше або дорівнює АРГ2\n"
"  АРГ1 = АРГ2       АРГ1 дорівнює АРГ2\n"
"  АРГ1 != АРГ2      АРГ1 не дорівнює АРГ2\n"
"  АРГ1 >= АРГ2      АРГ1 більше або дорівнює АРГ2\n"
"  АРГ1 > АРГ2       АРГ1 більше АРГ2\n"

#: src/expr.c:371
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  АРГ1 + АРГ2       арифметична сума АРГ1 та АРГ2\n"
"  АРГ1 - АРГ2       арифметична різниця АРГ1 та АРГ2\n"

#: src/expr.c:378
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  АРГ1 * АРГ2       арифметичний добуток АРГ1 та АРГ2\n"
"  АРГ1 / АРГ2       арифметична частка від АРГ1 та АРГ2\n"
"  АРГ1 % AРГ2       арифметичний залишок від ділення АРГ1 на АРГ2\n"

#: src/expr.c:384
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  РЯДОК : REGEXP   перевірка відповідності REGEXP початку або кінцю РЯДКА\n"
"\n"
"  match РЯДОК REGEXP        те саме, що та РЯДОК : REGEXP\n"
"  substr РЯДОК ПОЗ ДОВЖИНА  частина РЯДКА, позиція відраховується від 1\n"
"  index РЯДОК СИМВОЛИ       позиція у РЯДКУ, де першим знайдений будь-який\n"
"                            з СИМВОЛІВ, інакше 0\n"
"  length РЯДОК              довжина РЯДКА\n"

#: src/expr.c:393
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + ЛЕКСЕМА                  сприймати ЛЕКСЕМУ як рядок, навіть якщо це\n"
"                             ключове слово, як 'match', або оператор, як "
"'/'\n"
"\n"
"  ( ВИРАЗ )                  значення ВИРАЗУ\n"

#: src/expr.c:399
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"Пам'ятайте, що при використанні у оболонці деякі оператори повинні бути\n"
"взяті у дужки.  Якщо обидва аргументу АРГ є числами, то виконується\n"
"арифметичний порівняння, інакше вони порівнюються як рядки.  При "
"відповідності\n"
"шаблону повертається відповідний рядок рядок між \\( та \\) або порожній "
"рядок;\n"
"якщо \\( та \\) не використовуються, то повертається кількість відповідних "
"символів.\n"

#: src/expr.c:406
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"Статус завершення дорівнює 0, якщо ВИРАЗ не порожній та не 0; 1, якщо\n"
"ВИРАЗ порожній або 0; 2, якщо ВИРАЗ синтаксично неправильний; та 3,\n"
"якщо виникла помилка.\n"

#: src/expr.c:462
#, c-format
msgid "syntax error: unexpected argument %s"
msgstr "синтаксична помилка: неочікуваний аргумент %s"

#: src/expr.c:665
#, c-format
msgid "syntax error: missing argument after %s"
msgstr "синтаксична помилка: пропущено аргумент після %s"

#: src/expr.c:748 src/ptx.c:289
msgid "error in regular expression matcher"
msgstr "помилка у механізмі відповідності регулярних виразів"

#: src/expr.c:776
#, c-format
msgid "syntax error: expecting ')' after %s"
msgstr "синтаксична помилка: мало бути «)» після %s"

#: src/expr.c:779
#, c-format
msgid "syntax error: expecting ')' instead of %s"
msgstr "синтаксична помилка: мало бути «)», а не %s"

#: src/expr.c:785
msgid "syntax error: unexpected ')'"
msgstr "синтаксична помилка: неочікувана «)»"

#: src/expr.c:931 src/expr.c:968
msgid "non-integer argument"
msgstr "не цілочисловий аргумент"

#: src/expr.c:933 src/truncate.c:278
msgid "division by zero"
msgstr "ділення на нуль"

#: src/expr.c:1027 src/sort.c:2119
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "Щоб обійти цю проблему, встановіть LC_ALL='C'"

#: src/expr.c:1029
#, c-format
msgid "the strings compared were %s and %s"
msgstr "рядки, що порівнювались %s та %s."

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:130
msgid "Niels Moller"
msgstr "Niels Moller"

#: src/factor.c:1276 src/factor.c:1376 src/factor.c:1452
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr "Не вдалося перевірити простоту за тестом Люка. Цього не мало статися."

#: src/factor.c:2103
msgid "squfof queue overflow"
msgstr "переповнення черги squfof"

#: src/factor.c:2525
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s не є правильним цілим додатнім числом"

#: src/factor.c:2549 src/od.c:1697 src/od.c:1778
#, c-format
msgid "%s is too large"
msgstr "%s надто велике"

#: src/factor.c:2561
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ЧИСЛО]...\n"
"       або:    %s КЛЮЧ\n"

#: src/factor.c:2566
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"Виводить прості множники для кожного вказаного цілого ЧИСЛА. Якщо\n"
"числа не вказано у командному рядку, читати дані зі стандартного джерела.\n"
"\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "поточний каталог недоступний"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "не вдалося змінити каталог на %s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "не вдалося виконати stat для поточного каталогу (наразі %s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:37
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:269
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "Використання: %s [-ШИРИНА] [ПАРАМЕТР]... [ФАЙЛ]...\n"

#: src/fmt.c:270
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""
"Переформатує кожен абзац у ФАЙЛІ(ах) та виводить на стандартне виведення.\n"
"Параметр -ШИРИНА є скороченою формою --width=ЧИСЛО.\n"

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin       зберігати відступи двох перших рядків\n"
"  -p, --prefix=РЯДОК       форматувати лише рядки, що починаються з РЯДОК,\n"
"                             зберігаючи при цьому префікс рядків\n"
"  -s, --split-only         розбивати довгі рядки, але не заповнювати\n"

#: src/fmt.c:287
#, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""
"  -t, --tagged-paragraph   відступ першого рядка, відмінний від другого\n"
"  -u, --uniform-spacing    один пробіл після слова, два після речення\n"
"  -w, --width=ЧИСЛО        максимальна довжина рядка (типово 75 позицій)\n"
"  -g, --goal=ДОВЖИНА       остаточна довжина (типово 93% довжини)\n"

#: src/fmt.c:355
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr ""
"неправильний ключ -- %c; -ШИРИНА розпізнається, лише якщо це перший\n"
"аргумент, у іншому випадку вказуйте -w N"

#: src/fmt.c:399 src/fmt.c:406
msgid "invalid width"
msgstr "некоректна ширина"

#: src/fold.c:70
msgid "Wrap input lines in each FILE, writing to standard output.\n"
msgstr ""
"Розбиває рядки у ФАЙЛІ(ах) та виводить результат до стандартного\n"
"виведення.\n"

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         прочитати байти, а не стовпчики\n"
"  -s, --spaces        розбивати лише на пробілах\n"
"  -w, --width=ЧИСЛО   використовувати вказане ЧИСЛО стовпчиків, а не 80\n"

#: src/fold.c:284 src/pr.c:841
msgid "invalid number of columns"
msgstr "некоректна кількість стовпчиків"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:30 src/md5sum.c:107 src/realpath.c:33 src/stdbuf.c:38
#: src/timeout.c:78 src/truncate.c:38
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "Використання: %s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"Ліміти платформи виводу обмежені у форматі придатному для використання у "
"сценаріях.\n"
"\n"

#: src/group-list.c:68 src/id.c:401
#, c-format
msgid "failed to get groups for user %s"
msgstr "помилка при отриманні груп користувачів %s"

#: src/group-list.c:73 src/id.c:404
#, c-format
msgid "failed to get groups for the current process"
msgstr "не вдалося отримати групи для поточного процесу"

#: src/group-list.c:113
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "не вдалося визначити назву групи для ID %lu"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]...\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"Вивести дані щодо участі у групах для кожного ІМЕНІ КОРИСТУВАЧА, якщо імені "
"не\n"
"вказано, буде показано дані для поточного процесу (може бути іншим, якщо "
"було\n"
"змінено базу даних груп).\n"

#: src/groups.c:106 src/id.c:289
msgid "cannot get real UID"
msgstr "не вдалося встановити справжній UID"

#: src/groups.c:111 src/id.c:297
msgid "cannot get effective GID"
msgstr "не вдалося отримати ефективний GID"

#: src/groups.c:116 src/id.c:302
msgid "cannot get real GID"
msgstr "не вдалося встановити справжній GID"

#: src/groups.c:130 src/id.c:255
#, c-format
msgid "%s: no such user"
msgstr "%s: такого користувача не існує"

#: src/head.c:114
#, c-format
msgid ""
"Print the first %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Виводить перші %d рядків кожного з ФАЙЛІВ до стандартного виведення.\n"
"Якщо задано декілька ФАЙЛІВ, спочатку виводить перед даними заголовок із "
"назвою файла.\n"

#: src/head.c:122
#, c-format
msgid ""
"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM bytes of each file\n"
"  -n, --lines=[-]NUM       print the first NUM lines instead of the first "
"%d;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM lines of each file\n"
msgstr ""
"  -c, --bytes=[-]K         вивести перші K байтів кожного файла;\n"
"                             якщо перед K стоїть «-», вивести всі, крім K\n"
"                             останніх байтів кожного файла\n"
"  -n, --lines=[-]K         вивести перші K рядків кожного файла, а не %d;\n"
"                             якщо перед K стоїть «-», вивести всі, крім K\n"
"                             останніх рядків кожного файла\n"

#: src/head.c:130
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent   не виводити заголовки з назвами файлів\n"
"  -v, --verbose           завжди виводити заголовки з назвами файлів\n"

#: src/head.c:139
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"Після ЧИСЛА блоків та байт може стоять один з множників:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"
"Можна також використовувати двійкові префікси: KiB=K, MiB=M тощо.\n"

#: src/head.c:160
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s: файл надто скоротився"

#: src/head.c:232 src/tail.c:507
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: не вдалося перейти до позиції %s"

#: src/head.c:233 src/tail.c:511
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: не вдалося перемістити вказівник позиції на %s"

#: src/head.c:275
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s: число байт надто великий"

#: src/head.c:913 src/split.c:1368 src/split.c:1535 src/tail.c:2205
msgid "invalid number of lines"
msgstr "неправильна кількість рядків"

#: src/head.c:914 src/head.c:1078 src/split.c:1360 src/split.c:1376
#: src/tail.c:2206
msgid "invalid number of bytes"
msgstr "неправильна кількість байт"

#: src/head.c:1004 src/head.c:1066
#, c-format
msgid "invalid trailing option -- %c"
msgstr "неправильний завершальний ключ -- '%c'"

#: src/hostid.c:41
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"Використання: %s [ПАРАМЕТР]\n"
"Вивести числовий ідентифікатор (шістнадцяткове) для поточного вузла.\n"
"\n"

#: src/hostname.c:56
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"Використання: %s [НАЗВА]\n"
"       або:    %s КЛЮЧ\n"
"Виводить або встановлює назву цієї системи.\n"
"\n"

#: src/hostname.c:93
#, c-format
msgid "cannot set name to %s"
msgstr "не вдалося встановити назву у %s"

#: src/hostname.c:97
msgid "cannot set hostname; this system lacks the functionality"
msgstr "не вдалося встановити основну назву -- ця система не має такої функції"

#: src/hostname.c:105
msgid "cannot determine hostname"
msgstr "не вдалося визначити назву машини"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:41 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:96 src/pinky.c:489
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]...\n"

#: src/id.c:97
msgid ""
"Print user and group information for each specified USER,\n"
"or (when USER omitted) for the current user.\n"
"\n"
msgstr ""
"Вивести дані щодо користувача і групи для кожного вказаного користувача\n"
"або (якщо користувача не вказано) для поточного користувача.\n"
"\n"

#: src/id.c:102
msgid ""
"  -a             ignore, for compatibility with other versions\n"
"  -Z, --context  print only the security context of the process\n"
"  -g, --group    print only the effective group ID\n"
"  -G, --groups   print all group IDs\n"
"  -n, --name     print a name instead of a number, for -ugG\n"
"  -r, --real     print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user     print only the effective user ID\n"
"  -z, --zero     delimit entries with NUL characters, not whitespace;\n"
"                   not permitted in default format\n"
msgstr ""
"  -a              ігнорувати, визначено лише для сумісності\n"
"  -Z, --context   виводити лише контекст безпеки процесу\n"
"  -g, --group     виводити лише ID групи\n"
"  -G, --groups    виводити лише додаткові групи\n"
"  -n, --name      виводити назва замість номера, для ключів -ugG\n"
"  -r, --real      виводити дійсні, а не ефективні ID, для ключів -ugG\n"
"  -u, --user      виводити лише ID користувача\n"
"  -z, --zero      розмежовувати записи символами NUL, а не пробілами;\n"
"                    не можна використовувати у типовому форматі\n"

#: src/id.c:115
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"Якщо КЛЮЧІ не вказані, виводить стандартний набір корисних відомостей.\n"

#: src/id.c:153
msgid "--context (-Z) works only on an SELinux/SMACK-enabled kernel"
msgstr "--context (-Z) працює, якщо ядро має підтримку SELinux або SMACK"

#: src/id.c:158
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) працює, якщо ядро має підтримку SELinux"

#: src/id.c:192
msgid "cannot print security context when user specified"
msgstr "не можна виводити контекст безпеки, коли вказано користувача"

#: src/id.c:195
msgid "cannot print \"only\" of more than one choice"
msgstr "не можна виводити \"only\" для більш ніж одного варіанту"

#: src/id.c:204
msgid "cannot print only names or real IDs in default format"
msgstr "не можна виводити лише назви або дійсні ID у типовому форматі"

#: src/id.c:208
msgid "option --zero not permitted in default format"
msgstr "у типовому форматі не можна використовувати параметр --zero"

#: src/id.c:224
msgid "can't get process context"
msgstr "не можна отримати контекст процесу"

#: src/id.c:280
msgid "cannot get effective UID"
msgstr "не вдалося отримати ефективний UID"

#: src/id.c:344
#, c-format
msgid "cannot find name for user ID %s"
msgstr "не вдалося визначити ім'я користувача для ID %s"

#: src/id.c:362
#, c-format
msgid "uid=%s"
msgstr "uid=%s"

#: src/id.c:367
#, c-format
msgid " gid=%s"
msgstr " gid=%s"

#: src/id.c:374
#, c-format
msgid " euid=%s"
msgstr " euid=%s"

#: src/id.c:382
#, c-format
msgid " egid=%s"
msgstr " egid=%s"

#: src/id.c:410
msgid " groups="
msgstr " групи="

#: src/id.c:426
#, c-format
msgid " context=%s"
msgstr " контекст=%s"

#: src/install.c:378
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "попередження: %s: не вдалося змінити контекст у %s"

#: src/install.c:420
#, c-format
msgid "creating directory %s"
msgstr "створення каталогу %s"

#: src/install.c:432 src/mkdir.c:128 src/mkdir.c:161
#, c-format
msgid "failed to set default creation context for %s"
msgstr "помилка встановлення типового контексту для створення %s"

#: src/install.c:462 src/mkdir.c:181
#, c-format
msgid "failed to restore context for %s"
msgstr "не вдалося зберегти мітки часу для %s"

#: src/install.c:510
#, c-format
msgid "cannot change ownership of %s"
msgstr "не вдалося змінити власника %s"

#: src/install.c:534
#, c-format
msgid "cannot set timestamps for %s"
msgstr "не вдалося встановити часові позначки для %s"

#: src/install.c:556 src/split.c:523 src/timeout.c:506
#, c-format
msgid "fork system call failed"
msgstr "системний виклик fork завершився помилкою"

#: src/install.c:560
#, c-format
msgid "cannot run %s"
msgstr "не вдалося запустити %s"

#: src/install.c:563
#, c-format
msgid "waiting for strip"
msgstr "очікування strip"

#: src/install.c:565
#, c-format
msgid "strip process terminated abnormally"
msgstr "процес strip завершився помилкою"

#: src/install.c:589
#, c-format
msgid "invalid user %s"
msgstr "неправильний користувач %s"

#: src/install.c:627
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ДЖЕРЕЛО ПРИЗНАЧЕННЯ\n"
"       або    %s [КЛЮЧ]... ДЖЕРЕЛО... КАТАЛОГ\n"
"       або    %s [КЛЮЧ]... -t КАТАЛОГ ДЖЕРЕЛО...\n"
"       або    %s [КЛЮЧ]... -d КАТАЛОГ...\n"

#: src/install.c:634
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""
"\n"
"Ця програма для встановлення копіює файли (часто щойно зібрані) до "
"вказаного\n"
"вами місця призначення. Якщо вам потрібно отримати і встановити готовий до\n"
"використання пакунок у системі GNU/Linux, вам краще скористатися програмою\n"
"для керування пакунками, зокрема yum(1) або apt-get(1).\n"
"\n"
"У перших трьох формах копіює ДЖЕРЕЛО до ПРИЗНАЧЕННЯ або декілька\n"
"ДЖЕРЕЛ до вже створеного КАТАЛОГу, встановлюючи режими доступу та\n"
"власника/групу.  В четвертій формі створює всі компоненти вказаних\n"
"КАТАЛОГІВ.\n"

#: src/install.c:648
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTROL]  створити резервну копію перед вилученням\n"
"  -b                  те саме, що і --backup, але без аргументу\n"
"  -c                  (ігнорується)\n"
"  -C, --compare       порівняти кожну пару файлів джерела і призначення і,\n"
"                        за певних умов, не змінювати призначення\n"
"  -d, --directory     вважати всі аргументи каталогами; створювати всі\n"
"                        компоненти вказаних каталогів\n"

#: src/install.c:657
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        or all components of --target-directory,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                  створювати всі початкові складові ЦІЛІ крім\n"
"                        останньої, або усі компоненти --target-directory,\n"
"                        потім копіювати ДЖЕРЕЛО у ЦІЛЬ\n"
"  -g, --group=ГРУПА   встановлювати ГРУПУ, а не групу поточного процесу\n"
"  -m, --mode=РЕЖИМ    встановлювати РЕЖИМ (як chmod), а не rwxr-xr-x\n"
"  -o, --owner=ВЛАСНИК встановлювати ВЛАСНИКА (лише для суперкористувача)\n"

#: src/install.c:665
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps встановлювати цільовим файлам час\n"
"                        доступу/зміни як у їх файлів-ДЖЕРЕЛ\n"
"  -s, --strip         вилучати таблиці символів\n"
"      --strip-program=ПРОГРАМА  програма, що використовується для вилучення\n"
"  -S, --suffix=СУФІКС використовувати для резервних копій заданий СУФІКС\n"
"  -t, --target-directory=КАТАЛОГ копіювати всі аргументи-ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory вважати ЦІЛЬ звичайним файлом\n"
"  -v, --verbose       виводити назву кожного створюваного каталогу\n"

#: src/install.c:675
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z                      set SELinux security context of destination\n"
"                            file and each created directory to default type\n"
"      --context[=CTX]     like -Z, or if CTX is specified then set the\n"
"                            SELinux or SMACK security context to CTX\n"
msgstr ""
"      --preserve-context  зберігати контекст безпеки SELinux\n"
"      -Z                  встановити типовий тип контексту безпеки SELinux\n"
"                            для файла призначення і кожного створеного "
"каталогу\n"
"      --context[=CTX]     подібний до -Z, якщо вказано CTX, встановити "
"контекст безпеки\n"
"                            SELinux або SMACK відповідно до вказаного "
"значення\n"
"                            контексту CTX\n"

#: src/install.c:711 src/unlink.c:85
#, c-format
msgid "cannot unlink %s"
msgstr "не вдалося вилучити посилання %s"

#: src/install.c:892
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr ""
"Попередження: --preserve-context ігнорується; ядро не підтримує SELinux."

#: src/install.c:932
msgid "the strip option may not be used when installing a directory"
msgstr "при встановленні каталогу не можна вживати ключ strip"

#: src/install.c:935
msgid "target directory not allowed when installing a directory"
msgstr "при встановленні каталогу не можна вказувати цільовий каталог"

#: src/install.c:1002 src/mkdir.c:284 src/stdbuf.c:352
#, c-format
msgid "invalid mode %s"
msgstr "неправильний режим %s"

#: src/install.c:1009
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr ""
"ПОПЕРЕДЖЕННЯ: ігноруємо параметр --strip-program, оскільки параметр -s не "
"вказано"

#: src/install.c:1014
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr ""
"параметри --compare (-C) і --preserve-timestamps не можна використовувати "
"одночасно"

#: src/install.c:1021
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "параметри --compare (-C) і --strip не можна використовувати одночасно"

#: src/install.c:1027
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr ""
"параметр --compare (-C) пропускається, якщо ви вкажете режим з заборонними "
"бітами"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:41 src/sort.c:67
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:196
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited by blanks.\n"
msgstr ""
"Для кожної пари вхідних рядків з однаковими полями виводить рядок\n"
"до стандартного виведення. Типово спільне поле вважається першим, поля\n"
"розділюються знаками пробілів.\n"

#: src/join.c:205
msgid ""
"\n"
"  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"\n"
"  -a НОМЕР           виводити рядки що не мають пари з файла з вказаним\n"
"                       номером (1 або 2)\n"
"  -e РЯДОК           замінювати при виводі порожні рядки вказаним РЯДКОМ\n"

#: src/join.c:211
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case  ігнорувати регістр літер при порівнянні полів\n"
"  -j ПОЛЕ            еквівалентно '-1 ПОЛЕ -2 ПОЛЕ'\n"
"  -o ФОРМАТ          виводити відповідно до ФОРМАТУ\n"
"  -t ЗНАК            використовувати ЗНАК розділення полів вводу та виводу\n"

#: src/join.c:217
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""
"  -v НОМЕР          як -а НОМЕР, але не виводити наявні пари рядків\n"
"  -1 ПОЛЕ           вважати спільним вказане ПОЛЕ файла 1\n"
"  -2 ПОЛЕ           вважати спільним вказане ПОЛЕ файла 2\n"
"  --check-order     перевірити, чи впорядковано належним чином введення,\n"
"                      навіть якщо для всіх вхідних рядків є пари\n"
"  --nocheck-order   не перевіряти, чи впорядковано вхідні дані\n"
"  --header          вважати перший рядок кожного файла заголовками полів,\n"
"                      вивести їх без спроб знайти для них пари\n"

#: src/join.c:227 src/shuf.c:83 src/sort.c:500 src/uniq.c:201
msgid "  -z, --zero-terminated     line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     завершувати рядки нульовим байтом, а не символом "
"нового рядка\n"

#: src/join.c:232
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"Якщо не вказано -t ЗНАК, початкові знаки пробілів розділяють поля та\n"
"ігноруються, у іншому випадку поля розділюються ЗНАКОМ. ПОЛЕ — це\n"
"номер поля, що відраховується від 1. ФОРМАТ — це один або декілька\n"
"розділених комами або знаками пробілів описів формату:\n"
"«НОМЕР_ФАЙЛА.ПОЛЕ» або «0». Типово ФОРМАТ виводить спільне поле,\n"
"інші поля з ФАЙЛА1 та інші поля з ФАЙЛА2, розділені ЗНАКом.\n"
"Якщо ФОРМАТом є ключове слово «auto», перший рядок кожного з файлів\n"
"визначає кількість полів виведення для кожного рядка.\n"
"\n"
"Важливе: ФАЙЛ1 та ФАЙЛ2 має бути впорядковано за спільними полями.\n"
"Наприклад, скористайтеся командою « sort -k 1b,1 » якщо «join» вказано без\n"
"параметрів, або « join -t '' », якщо «sort» вказано без параметрів.\n"
"Зауважте, що під час порівняння буде використано правила, вказані за\n"
"допомогою змінної LC_COLLATE. Якщо вхідні дані не впорядковано і\n"
"якісь з рядків не може бути об'єднано, буде показано повідомлення\n"
"з попередженням про це.\n"

#: src/join.c:417
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr "%s:%<PRIuMAX>: не впорядковано: %.*s"

#: src/join.c:848 src/join.c:1046
#, c-format
msgid "invalid field number: %s"
msgstr "неправильний номер поля: %s"

#: src/join.c:869 src/join.c:878
#, c-format
msgid "invalid field specifier: %s"
msgstr "неправильна специфікація поля: %s"

#: src/join.c:885
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "неправильний номер файла у специфікації поля: %s"

#: src/join.c:929
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "поля об'єднання %lu, %lu несумісні"

#: src/join.c:1057
msgid "conflicting empty-field replacement strings"
msgstr "конфліктуючі рядки заміни для порожнього поля"

#: src/join.c:1109 src/sort.c:4535
#, c-format
msgid "multi-character tab %s"
msgstr "багатознакова табуляція %s"

#: src/join.c:1113 src/sort.c:4540
msgid "incompatible tabs"
msgstr "несумісна табуляція"

#: src/join.c:1186
msgid "both files cannot be standard input"
msgstr "замість обох файлів не можна вказувати одночасно стандартний ввід"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"Використання: %s [-s СИГНАЛ | -СИГНАЛ] PID...\n"
"      або:  %s -l [СИГНАЛ]...\n"
"      або:  %s -t [СИГНАЛ]...\n"

#: src/kill.c:83
msgid "Send signals to processes, or list signals.\n"
msgstr "Надсилає процесам сигнали або виводить сигнали.\n"

#: src/kill.c:89
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=СИГНАЛ, -СИГНАЛ\n"
"              вказує назву або номер сигналу, що надсилається\n"
"  -l, --list  виводить назви сигналів або переводить назви у номери та "
"назад\n"
"  -t, --table виводить таблицю з інформацією про сигнали\n"

#: src/kill.c:97
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"СИГНАЛ може бути назвою сигналу, як HUP, або номером сигналу, як\n"
"'1', або кодом завершення процесу, перерваного сигналом.\n"
"PID є цілим числом; якщо воно є від'ємним, то означає групу\n"
"процесів.\n"

#: src/kill.c:206
#, c-format
msgid "%s: invalid process id"
msgstr "%s: неправильний ідентифікатор процесу"

#: src/kill.c:260
#, c-format
msgid "invalid option -- %c"
msgstr "неправильний ключ -- '%c'"

#: src/kill.c:269
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: задано декілька сигналів"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "задано декілька ключів -l або -t"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "не можна об'єднувати сигнал з -l або -t"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "не вказаний ідентифікатор процесу"

#: src/libstdbuf.c:108
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "некоректний режим буферизації %s для %s\n"

#: src/libstdbuf.c:120
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "не вдалося розмістити буфер stdio у %<PRIuMAX> байтів\n"

#: src/libstdbuf.c:130
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "не вдалося змінити режим буферизації %s у значення %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:52
msgid "Michael Stone"
msgstr "Michael Stone"

#: src/link.c:45
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФАЙЛ1 ФАЙЛ2\n"
"       або:    %s КЛЮЧ\n"

#: src/link.c:48
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"Викликає функцію link для створення посилання з назвою ФАЙЛ2 на існуючий "
"ФАЙЛ1.\n"
"\n"

#: src/link.c:89
#, c-format
msgid "cannot create link %s to %s"
msgstr "не вдалося створити посилання %s на %s"

#: src/ln.c:213
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: не допускається створювати жорсткі посилання на каталоги"

#: src/ln.c:238
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: не вдалося перезаписати каталог"

#: src/ln.c:285
#, c-format
msgid "%s: replace %s? "
msgstr "%s: замінити %s? "

#: src/ln.c:380
#, c-format
msgid "failed to create symbolic link %s"
msgstr "не вдалося створити символічне посилання %s"

#: src/ln.c:381
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "не вдалося створити символічне посилання %s -> %s"

#: src/ln.c:383
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "не вдалося створити жорстке посилання на %.0s%s"

#: src/ln.c:386
#, c-format
msgid "failed to create hard link %s"
msgstr "не вдалося створити жорстке посилання %s"

#: src/ln.c:387
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "не вдалося створити жорстке посилання %s => %s"

#: src/ln.c:409
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME\n"
"  or:  %s [OPTION]... TARGET\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [-T] ПРИЗНАЧЕННЯ ПОСИЛАННЯ\n"
"         або  %s [КЛЮЧ]... ПРИЗНАЧЕННЯ\n"
"         або  %s [КЛЮЧ]... ПРИЗНАЧЕННЯ... КАТАЛОГ\n"
"         або  %s [КЛЮЧ]... -t КАТАЛОГ ПРИЗНАЧЕННЯ...\n"

#: src/ln.c:416
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""
"У першій формі створюється посилання на ПРИЗНАЧЕННЯ з назвою ПОСИЛАННЯ.\n"
"У другий формі створюється посилання на ПРИЗНАЧЕННЯ у поточному каталозі.\n"
"У третій та четвертій формах створюється посилання на кожне ПРИЗНАЧЕННЯ у\n"
"вказаному КАТАЛОЗІ. Типово створюються жорсткі посилання, а з ключем --"
"symbolic\n"
"— символічні. Типово, кожне призначення (назва нового посилання) не повинно\n"
"існувати. У разі створення жорстких посилань кожне ПРИЗНАЧЕННЯ має "
"існувати.\n"
"Символічні посилання можуть містити довільний текст. Під час пізнішого\n"
"визначення ПРИЗНАЧЕННЯ відносне посилання визначатиметься на основі\n"
"батьківського каталогу посилання.\n"

#: src/ln.c:429
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=КОНТРОЛЬ]     робити резервну копію кожного цільового файла\n"
"  -b                          те ж, що й --backup, але не приймає аргумент\n"
"  -d, -F, --directory         дозволяє суперкористувачу створювати жорсткі\n"
"                              посилання на каталоги (примітка: ймовірно, це\n"
"                              не вийде через системні обмеження, навіть для\n"
"                              суперкористувача)\n"
"  -f, --force                 вилучати вже створені цільові файли\n"

#: src/ln.c:437
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              create symbolic links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive           запитувати, чи слід вилучати призначення\n"
"  -L, --logical               розіменувати призначення, які є символічними\n"
"                                посиланнями\n"
"  -n, --no-dereference        вважати посилання звичайним файлом, якщо воно\n"
"                                є символічним посиланням на каталог\n"
"  -P, --physical              створювати жорсткі посилання безпосередньо на\n"
"                                символічні посилання\n"
"  -r, --relative              створювати символічні посилання відносно "
"розташування\n"
"                                посилання\n"
"  -s, --symbolic              створювати символічні посилання, замість "
"жорстких\n"

#: src/ln.c:446
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=СУФІКС         вказує СУФІКС для резервних копій\n"
"  -t, --target-directory=КАТАЛОГ  вказує КАТАЛОГ, у якому створювати\n"
"                                 посилання\n"
"  -T, --no-target-directory   завжди вважати НАЗВУ_ПОСИЛАННЯ звичайним "
"файлом\n"
"  -v, --verbose               виводити назву кожного файла перед створенням "
"посилання\n"

#: src/ln.c:456
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""
"\n"
"Використання -s призводить до ігнорування -L і -P. Інакше, останній "
"параметр\n"
"визначає роботу програми, якщо призначенням є символічне посилання.\n"
"Типове значення: %s.\n"

#: src/ln.c:572
msgid "cannot do --relative without --symbolic"
msgstr "не можна виконувати --relative без --symbolic"

#: src/ln.c:584
msgid "cannot combine --target-directory and --no-target-directory"
msgstr ""
"не можна одночасно використовувати --target-directory і --no-target-directory"

#: src/ln.c:632
#, c-format
msgid "target %s"
msgstr "призначення — %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME: невідомо"

#: src/logname.c:39
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "Використання: %s [КЛЮЧ]\n"

#: src/logname.c:40
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"Виводить ім'я поточного користувача.\n"
"\n"

#: src/logname.c:78
msgid "no login name"
msgstr "реєстраційне ім'я відсутнє"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:777
msgid "%b %e  %Y"
msgstr "%b %e  %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:790
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1930
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr "проігноровано неправильну довжину змінної середовища COLUMNS: %s"

#: src/ls.c:1955
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr ""
"проігноровано неправильний розмір табуляції змінної оточення TABSIZE: %s"

#: src/ls.c:2074
msgid "invalid line width"
msgstr "некоректна довжина рядка"

#: src/ls.c:2142
msgid "invalid tab size"
msgstr "некоректний розмір табуляції"

#: src/ls.c:2376
#, c-format
msgid "invalid time style format %s"
msgstr "неправильний формат часу %s"

#: src/ls.c:2400
msgid "Valid arguments are:\n"
msgstr "Коректні аргументи:\n"

#: src/ls.c:2404
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr "  - +ФОРМАТ (наприклад +%H:%M) для формату у стилі 'date'\n"

#: src/ls.c:2778
#, c-format
msgid "unrecognized prefix: %s"
msgstr "не розпізнаний префікс: %s"

#: src/ls.c:2808
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "незрозуміле значення змінної оточення LS_COLORS"

#: src/ls.c:2838 src/stat.c:1046
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr "проігноровано неправильне значення змінної оточення QUOTING_STYLE: %s"

#: src/ls.c:2905 src/pwd.c:164
#, c-format
msgid "cannot open directory %s"
msgstr "не вдалося відкрити каталог %s"

#: src/ls.c:2920
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "не вдалося визначити пристрій та inode для %s"

#: src/ls.c:2929
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s: пропущено вже перелічений каталогу"

#: src/ls.c:2954 src/ls.c:3390 src/selinux.c:127 src/selinux.c:300
#, c-format
msgid "error canonicalizing %s"
msgstr "помилка під час спроби перетворити у канонічну форму %s"

#: src/ls.c:3017 src/ls.c:3032 src/pwd.c:232
#, c-format
msgid "reading directory %s"
msgstr "читання каталогу %s"

#: src/ls.c:3048
#, c-format
msgid "closing directory %s"
msgstr "закриття каталогу %s"

#: src/ls.c:3765
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "не вдалося порівняти назви файлів %s та %s"

#: src/ls.c:5343
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""
"Виводить дані щодо ФАЙЛів (типово у поточному каталозі).\n"
"Впорядковує у алфавітному порядку, якщо не вказано ні --sort, ні один з\n"
"параметрів -cftuSUX.\n"

#: src/ls.c:5350
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all                  не ігнорувати записи, що починаються з .\n"
"  -A, --almost-all           не виводити неявні . і ..\n"
"      --author               разом з -l, виводити автора кожного файла\n"
"  -b, --escape               виводити вісімкові керівні послідовності\n"
"                             замість неграфічних знаків\n"

#: src/ls.c:5356
msgid ""
"      --block-size=SIZE      with -l, scale sizes by SIZE when printing "
"them;\n"
"                               e.g., '--block-size=M'; see SIZE format "
"below\n"
msgstr ""
"      --block-size=РОЗМІР    якщо вкзаано -l, використовувати блоки розміром "
"РОЗМІР.\n"
"\n"
"                               Наприклад, «--block-size=M». Формат РОЗМІРу "
"наведено\n"
"                               нижче.\n"

#: src/ls.c:5360
msgid ""
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information);\n"
"                               with -l: show ctime and sort by name;\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""
"  -B, --ignore-backups       не виводити файли, що закінчуються на ~\n"
"  -c                         з -lt: сортувати за часом зміни; з -l:\n"
"                              виводити час зміни та впорядкувати за назвою,\n"
"                              у іншому випадку впорядкувати за часом зміни,\n"
"                              найновіші — перші\n"

#: src/ls.c:5367
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output; WHEN can be "
"'always' (default\n"
"                               if omitted), 'auto', or 'never'; more info "
"below\n"
"  -d, --directory            list directories themselves, not their "
"contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         виводити список у декілька колонок\n"
"      --color[=КОЛИ]         вказує, чи позначати типи файлів кольором.\n"
"                               КОЛИ може бути «never», «auto» або\n"
"                               «always» (типовий, якщо не вказано)\n"
"  -d, --directory            виводити назви каталогів, а не їх зміст, а\n"
"                               також не слідувати за символічним посиланням\n"
"  -D, --dired                створити виведені дані у режимі Emacs dired\n"

#: src/ls.c:5376
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append '*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         не сортувати, вмикає -aU, вимикає -lst\n"
"  -F, --classify             додавати до назви індикатор (один з */=>@|)\n"
"      --file-type            аналогічно, але не додавати '*'\n"
"      --format=СЛОВО         across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            виводити повну дату та час\n"

#: src/ls.c:5384
msgid "  -g                         like -l, but do not list owner\n"
msgstr "  -g                         як і -l, але не виводити власника\n"

#: src/ls.c:5387
msgid ""
"      --group-directories-first\n"
"                             group directories before files;\n"
"                               can be augmented with a --sort option, but "
"any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"                             показувати каталоги перед файлами.\n"
"                               розширюється за допомогою параметра --sort,\n"
"                               але використання --sort=none (-U) вимикає\n"
"                               групування\n"

#: src/ls.c:5393
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
msgstr "  -G, --no-group             у довгих списках не виводити назв груп\n"

#: src/ls.c:5396
msgid ""
"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G "
"etc.\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -h, --human-readable       з -l і -s, виводити розміри у зручному для "
"людини вигляді\n"
"                               (наприклад, 1K 234M 2G)\n"
"      --si                   те саме, але виводити степені 1000, а не 1024\n"

#: src/ls.c:5400
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                               that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             слідувати за символьними посиланнями у "
"командному\n"
"                             рядку\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             слідувати за усіма символьними посиланнями у\n"
"                             командному рядку, які вказують на каталог\n"
"      --hide=ШАБЛОН          не виводити файли, що відповідають ШАБЛОНУ\n"
"                             оболонки (скасовується ключами -a або -A)\n"

#: src/ls.c:5410
msgid ""
"      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
"                               (default if omitted), 'auto', or 'never'\n"
msgstr ""
"      --hyperlink[=УМОВА]    гіперпосилання для назв файлів; УМОВА: always\n"
"                               (завжди, типово, якщо не вказано), auto "
"(авто) або never (ніколи)\n"

#: src/ls.c:5414
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
msgstr ""
"      --indicator-style=СТИЛЬ додавати до назв елементів індикатор з\n"
"                               вказаним СТИЛЕМ: none (типово), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                з -l, виводити номер i-вузла кожного файла\n"
"  -I, --ignore=ШАБЛОН        не виводити файли, що відповідають ШАБЛОНУ\n"

#: src/ls.c:5423
msgid ""
"  -k, --kibibytes            default to 1024-byte blocks for disk usage;\n"
"                               used only with -s and per directory totals\n"
msgstr ""
"  -k, --kibibytes            типово використовувати 1024-байтові блоки;\n"
"                               використовується лише з -s та для загальних "
"даних каталогів\n"

#: src/ls.c:5427
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l                         використовувати широкий формат\n"
"  -L, --dereference          показувати інформацію про символьні посилання,\n"
"                               виводити інформацію про файл, на який\n"
"                               посилається посилання\n"
"  -m                         виводити список на всю ширину через кому\n"

#: src/ls.c:5435
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print entry names without quoting\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      як -l, але виводити числові UID та GID\n"
"  -N, --literal              виводити назви записів без лапок\n"
"  -o                         як -l, але не виводити інформацію про групу\n"
"  -p,  --indicator-style=slash  додавати індикатор / до каталогів\n"

#: src/ls.c:5442
msgid ""
"  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
"      --show-control-chars   show nongraphic characters as-is (the default,\n"
"                               unless program is 'ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
"                               (overrides QUOTING_STYLE environment "
"variable)\n"
msgstr ""
"  -q, --hide-control-chars   виводити ? замість не графічних символів\n"
"      --show-control-chars   виводити недруковані символи (типово\n"
"                              якщо програма не 'ls' та вивід йде не на\n"
"                              термінал).\n"
"  -Q, --quote-name           взяти назву файла у дужки\n"
"      --quoting-style=СЛОВО  використовувати вид оточення дужками СЛОВО:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
"                               (має вищий пріоритет за змінну середовища "
"QUOTING_STYLE)\n"

#: src/ls.c:5453
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse              зворотний порядок сортування\n"
"  -R, --recursive            рекурсивно виводити каталоги\n"
"  -s, --size                 виводити розмір кожного файла, у блоках\n"

#: src/ls.c:5458
msgid ""
"  -S                         sort by file size, largest first\n"
"      --sort=WORD            sort by WORD instead of name: none (-U), size (-"
"S),\n"
"                               time (-t), version (-v), extension (-X)\n"
"      --time=WORD            change the default of using modification "
"times;\n"
"                               access time (-u): atime, access, use;\n"
"                               change time (-c): ctime, status;\n"
"                               birth time: birth, creation;\n"
"                             with -l, WORD determines which time to show;\n"
"                             with --sort=time, sort by WORD (newest first)\n"
msgstr ""
"  -S                         упорядкувати за розміром файлів, найбільші "
"спочатку\n"
"      --sort=СЛОВО           режим упорядковування (замість «за назвою»):\n"
"                              none (-U), size (-S), time (-t),\n"
"                              version (-v), extension (-X)\n"
"      --time=СЛОВО           з -l, виводити замість часу зміни час,\n"
"                              вказаний СЛОВОМ; час доступу: atime, access, "
"use (-u),\n"
"                              час внесення змін: ctime, status (-"
"c),                               час виникнення: birth, creation; якщо --"
"sort=time,\n"
"                              використовувати вказаний час як ключ "
"сортування\n"
"                              (найновіші спочатку)\n"

#: src/ls.c:5470
msgid ""
"      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE "
"below\n"
msgstr ""
"      --time-style=СТИЛЬ_ЧАСУ формат часу і дати у -l; див. СТИЛЬ_ЧАСУ "
"нижче\n"

#: src/ls.c:5473
msgid ""
"  -t                         sort by time, newest first; see --time\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         впорядковувати за часом, найновіші спочатку; "
"див. --time\n"
"  -T, --tabsize=ЧИСЛО        крок табуляції дорівнює ЧИСЛУ замість 8\n"

#: src/ls.c:5477
msgid ""
"  -u                         with -lt: sort by, and show, access time;\n"
"                               with -l: show access time and sort by name;\n"
"                               otherwise: sort by access time, newest first\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u                         з -lt: сортувати та виводити час доступу\n"
"                              з -l: виводити час доступу та впорядкувати\n"
"                              за назвою\n"
"                              інакше: впорядкувати за часом доступу, "
"найновіші спочатку\n"
"  -U                         не впорядковувати; виводити відповідно до\n"
"                              фізичного розташування\n"
"  -v                         впорядкувати за номерами (версією) у "
"текстовому\n"
"                              форматі\n"

#: src/ls.c:5484
msgid ""
"  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any security context of each file\n"
"  -1                         list one file per line.  Avoid '\\n' with -q or "
"-b\n"
msgstr ""
"  -w, --width=ЧИСЛО          задає ширину екрана. 0 — без обмежень\n"
"  -x                         вивід списку рядками, а не стовпчиками\n"
"  -X                         сортувати за розширенням у алфавітному порядку\n"
"  -Z, --context              виводити контекст безпеки для кожного файла\n"
"  -1                         виводити по одному файлу у рядку. Прибрати \\n\n"
"                             можна за допомогою -q або -b\n"

#: src/ls.c:5495
msgid ""
"\n"
"The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n"
"FORMAT is interpreted like in date(1).  If FORMAT is "
"FORMAT1<newline>FORMAT2,\n"
"then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n"
"TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX "
"locale.\n"
"Also the TIME_STYLE environment variable sets the default style to use.\n"
msgstr ""
"\n"
"Значенням аргументу СТИЛЬ_ЧАСУ може бути full-iso, long-iso, iso, locale або "
"+ФОРМАТ.\n"
"Значення ФОРМАТ обробляється як у date(1). Якщо замість ФОРМАТ вказано\n"
"ФОРМАТ1<новий_рядок>ФОРМАТ2, ФОРМАТ1 буде застосовано до файлів, які не є "
"недавніми,\n"
"а ФОРМАТ2 до недавніх файлів. Запис СТИЛЬ_ЧАСУ із префіксом «posix-» працює "
"лише\n"
"за межами локалі POSIX. Крім того, змінна середовища TIME_STYLE встановлює\n"
"типовий стиль, який використовує програма.\n"

#: src/ls.c:5503
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"Використання кольорів для позначення типів файлів вимкнено типово і за\n"
"допомогою --color=never. Якщо визначено --color=auto, ls видаватиме\n"
"коди кольорів, лише якщо стандартне виведення пов'язано з терміналом.\n"
"Змінити параметри можна за допомогою змінної середовища LS_COLORS.\n"
"Для встановлення цієї змінної скористайтеся командою dircolors.\n"

#: src/ls.c:5510
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"Коди виходу:\n"
" 0  все добре,\n"
" 1  незначні проблеми (наприклад, не вдалося отримати доступ до "
"підкаталогу),\n"
" 2  значні проблеми (наприклад, не вдалося отримати доступ до аргументу "
"командного рядка).\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:108
msgid "Samuel Neves"
msgstr "Samuel Neves"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:111 src/seq.c:48
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:112
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:113
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:229
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
msgstr ""
"Користування: %s [ПАРАМЕТР]... [ФАЙЛ]...\n"
"Вивести або перевірити %s (%d-бітові) контрольні суми.\n"

#: src/md5sum.c:239
msgid ""
"\n"
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"\n"
"  -b, --binary         читати у двійковому режимі (типово, якщо\n"
"                        читається не термінальне введення)\n"

#: src/md5sum.c:244
msgid ""
"\n"
"  -b, --binary         read in binary mode\n"
msgstr ""
"\n"
"  -b, --binary         читати у двійковому режимі\n"

#: src/md5sum.c:249
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr "  -c, --check          читати суми %s з ФАЙЛІВ та порівняти їх\n"

#: src/md5sum.c:253
msgid ""
"  -l, --length         digest length in bits; must not exceed the maximum "
"for\n"
"                       the blake2 algorithm and must be a multiple of 8\n"
msgstr ""
"  -l, --length         довжина контрольної суми у бітах; має не перевищувати "
"максимуму\n"
"                       для алгоритму blake2 і бути кратною до 8\n"

#: src/md5sum.c:258
msgid "      --tag            create a BSD-style checksum\n"
msgstr "      --tag            створити контрольну суму у форматі BSD\n"

#: src/md5sum.c:262
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr ""
"  -t, --text           читати у текстовому режимі (типово, якщо\n"
"                          читається термінальний ввід)\n"

#: src/md5sum.c:266
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text           читати у текстовому режимі (типово)\n"

#: src/md5sum.c:269
msgid ""
"  -z, --zero           end each output line with NUL, not newline,\n"
"                       and disable file name escaping\n"
msgstr ""
"  -z, --zero     завершувати кожен рядок нуль-байтом замість розриву рядка\n"
"                 і вимкнути екранування назв файлів\n"

#: src/md5sum.c:273
msgid ""
"\n"
"The following five options are useful only when verifying checksums:\n"
"      --ignore-missing  don't fail or report status for missing files\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"      --strict         exit non-zero for improperly formatted checksum "
"lines\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"П’ять наведених нижче параметрів використовуються лише під час перевірки "
"контрольних сум:\n"
"      --ignore-missing  не завершувати роботу і не повідомляти про стан для "
"файлів, які\n"
"                         не виявлено\n"
"      --quiet          не виводити підтвердження для кожного успішно "
"перевіреного\n"
"                         файла\n"
"      --status         не виконувати вивід, код завершення показує\n"
"                         успіх перевірки\n"
"      --strict         виводити ненульовий код завершення для рядків "
"контрольних\n"
"                         сум з помилками у форматуванні\n"
"  -w, --warn           попереджувати про неправильно сформовані рядки у\n"
"                         списку контрольних сум\n"
"\n"

#: src/md5sum.c:285
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print a\n"
"line with checksum, a space, a character indicating input mode ('*' for "
"binary,\n"
"' ' for text or where binary is insignificant), and name for each FILE.\n"
"\n"
"Note: There is no difference between binary mode and text mode on GNU "
"systems.\n"
msgstr ""
"\n"
"Метод обчислення контрольних сум описано у %s. Вхідними даними при\n"
"перевірці мають бути отримані раніше дані виводу цієї програми.\n"
"Типово виводить рядок з контрольною сумою, пробіл, символ, що вказує на\n"
"тип файла («*» для двійкових, « » для текстових або тих, де двійкові\n"
"дані є несуттєвими) та назву кожного ФАЙЛа.\n"
"\n"
"Зауваження: У системах GNU немає відмінностей між двійковим і текстовими "
"режимами.\n"

#: src/md5sum.c:697
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s: надто багато рядків контрольних сум"

#: src/md5sum.c:720
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s: %<PRIuMAX>: неправильно складений рядок контрольної суми %s"

#: src/md5sum.c:752
msgid "FAILED open or read"
msgstr "не вдалося відкрити або прочитати"

#: src/md5sum.c:790
msgid "FAILED"
msgstr "ПОМИЛКА"

#: src/md5sum.c:792
msgid "OK"
msgstr "Гаразд"

#: src/md5sum.c:816
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: не знайдено правильно складених рядків контрольних сум %s"

#: src/md5sum.c:826
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядок має помилкове форматування"
msgstr[1] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядки мають помилкове форматування"
msgstr[2] "ПОПЕРЕДЖЕННЯ: %<PRIuMAX> рядків мають помилкове форматування"

#: src/md5sum.c:834
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказаний файл"
msgstr[1] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказані файли"
msgstr[2] "ПОПЕРЕДЖЕННЯ: не вдалося прочитати %<PRIuMAX> вказаних файлів"

#: src/md5sum.c:842
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "ПОПЕРЕДЖЕННЯ: НЕ збіглась %<PRIuMAX> обчислена контрольна сума"
msgstr[1] "ПОПЕРЕДЖЕННЯ: НЕ збіглись %<PRIuMAX> обчислені контрольні суми"
msgstr[2] "ПОПЕРЕДЖЕННЯ: НЕ збіглись %<PRIuMAX> обчислених контрольних сум"

#: src/md5sum.c:848
#, c-format
msgid "%s: no file was verified"
msgstr "%s: не перевірено жодного файла"

#: src/md5sum.c:898
msgid "invalid length"
msgstr "некоректна довжина"

#: src/md5sum.c:902 src/md5sum.c:954
#, c-format
msgid "invalid length: %s"
msgstr "некоректна довжина: %s"

#: src/md5sum.c:903
msgid "length is not a multiple of 8"
msgstr "довжина не є кратною до 8"

#: src/md5sum.c:956
#, c-format
msgid "maximum digest length for %s is %<PRIuMAX> bits"
msgstr "максимальною довжиною контрольної суми для %s є %<PRIuMAX> бітів"

#: src/md5sum.c:974
#, c-format
msgid "--tag does not support --text mode"
msgstr "підтримки --tag у режимі --text не передбачено"

#: src/md5sum.c:980
#, c-format
msgid "the --zero option is not supported when verifying checksums"
msgstr ""
"підтримки параметра --zero при перевірці контрольних сум не передбачено"

#: src/md5sum.c:987
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "ключ --tag не має сенсу під час перевірки контрольних сум"

#: src/md5sum.c:994
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "ключі --binary та --text не мають сенсу при перевірці контрольних сум"

#: src/md5sum.c:1002
#, c-format
msgid "the --ignore-missing option is meaningful only when verifying checksums"
msgstr "параметр --ignore-missing має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:1010
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "ключ --status має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:1017
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "ключ --warn має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:1024
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "ключ --quiet має сенс лише при перевірці контрольних сум"

#: src/md5sum.c:1031
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "ключ --strict має сенс лише при перевірці контрольних сум"

#: src/mkdir.c:59 src/rmdir.c:164
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "Використання: %s [КЛЮЧ]... КАТАЛОГ...\n"

#: src/mkdir.c:60
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr "Створює DIRECTORY, якщо він ще не існує.\n"

#: src/mkdir.c:66
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""
"  -m, --mode=MODE   встановити код доступу (як у chmod)\n"
"  -p, --parents     не виводити помилок якщо каталог існує,\n"
"                     при потребі створювати батьківські каталоги\n"
"  -v, --verbose     виводити повідомлення про кожен створений каталог\n"

#: src/mkdir.c:71
msgid ""
"  -Z                   set SELinux security context of each created "
"directory\n"
"                         to the default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   встановити типовий тип контексту безпеки SELinux для "
"усіх\n"
"                         створених каталогів\n"
"      --context[=CTX]  подібний до -Z, якщо вказано CTX, встановити контекст "
"безпеки\n"
"                         SELinux або SMACK відповідно до вказаного значення\n"
"                         контексту CTX\n"

#: src/mkdir.c:221
#, c-format
msgid "created directory %s"
msgstr "створений каталог %s"

#: src/mkdir.c:239 src/mkfifo.c:117 src/mknod.c:134
#, c-format
msgid ""
"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel"
msgstr ""
"попередження: ігноруємо --context; для його використання потрібне ядро з "
"підтримкою SELinux або SMACK"

#: src/mkfifo.c:54 src/pathchk.c:88
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "Використання: %s [КЛЮЧ]... НАЗВА...\n"

#: src/mkfifo.c:55
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr "Створює іменовані канали (FIFO) для вказаного NAME.\n"

#: src/mkfifo.c:61 src/mknod.c:63
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=РЕЖИМ   встановити права доступу у РЕЖИМ, а не  a=rw - umask\n"

#: src/mkfifo.c:64 src/mknod.c:66
msgid ""
"  -Z                   set the SELinux security context to default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   встановити типовий тип контексту безпеки SELinux\n"
"      --context[=CTX]  подібний до -Z, якщо вказано CTX, встановити контекст "
"безпеки\n"
"                         SELinux або SMACK відповідно до вказаного значення\n"
"                         контексту CTX\n"

#: src/mkfifo.c:154 src/mknod.c:151
msgid "invalid mode"
msgstr "неправильний режим"

#: src/mkfifo.c:161 src/mknod.c:158
msgid "mode must specify only file permission bits"
msgstr "режим повинен визначати лише біти прав доступу до файла"

#: src/mkfifo.c:175 src/mknod.c:271
#, c-format
msgid "cannot set permissions of %s"
msgstr "не вдалося встановити права доступу до %s"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "Використання: %s [КЛЮЧ]... НАЗВА ТИП [ОСНОВНИЙ ДРУГОРЯДНИЙ]\n"

#: src/mknod.c:57
msgid "Create the special file NAME of the given TYPE.\n"
msgstr "Створює спеціальній файл з назвою NAME та типом TYPE.\n"

#: src/mknod.c:73
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"Якщо ТИП -- це b, c або u, необхідно вказувати як ОСНОВНИЙ, так і\n"
"ДРУГОРЯДНИЙ, а якщо ТИП дорівнює p, їх не можна вказувати.  Якщо ОСНОВНИЙ\n"
"або ДРУГОРЯДНИЙ починаються з 0x або 0X, вони інтерпретуються як\n"
"шістнадцяткові числа; якщо починаються з 0 - як вісімкові;\n"
"інакше як десяткові.  ТИП може приймати наступні значення:\n"

#: src/mknod.c:80
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      створити файл блокового пристрою (буферизований)\n"
"  c, u   створити файл символьного пристрою (не буферизований)\n"
"  p      створити іменований канал\n"

#: src/mknod.c:176
msgid "Special files require major and minor device numbers."
msgstr ""
"Для спеціального файла повинні бути вказані основний та другорядний номери "
"пристрою."

#: src/mknod.c:186
msgid "Fifos do not have major and minor device numbers."
msgstr "У файлів-черг немає основного та другорядного числа пристрою."

#: src/mknod.c:211
msgid "block special files not supported"
msgstr "блокові спеціальні файли не підтримуються"

#: src/mknod.c:220
msgid "character special files not supported"
msgstr "знакові спеціальні файли не підтримуються"

#: src/mknod.c:236
#, c-format
msgid "invalid major device number %s"
msgstr "неправильне основне число пристрою %s"

#: src/mknod.c:241
#, c-format
msgid "invalid minor device number %s"
msgstr "неправильне другорядне число пристрою %s"

#: src/mknod.c:246
#, c-format
msgid "invalid device %s %s"
msgstr "неправильний пристрій %s %s"

#: src/mknod.c:266
#, c-format
msgid "invalid device type %s"
msgstr "неправильний тип пристрою %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:67
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "Використання: %s [КЛЮЧ]... [ШАБЛОН]\n"

#: src/mktemp.c:68
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"Створити у безпечний спосіб файл або каталог і вивести їхню назву.\n"
"ШАБЛОН має складатися принаймні з трьох «X» поспіль у останньому\n"
"компоненті. Якщо ШАБЛОН не вказано, використовується tmp.XXXXXXXXXX і\n"
"додається параметр --tmpdir.\n"

#: src/mktemp.c:73
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""
"Файли буде створено з правами u+rw, каталоги — u+rwx, мінус обмеження "
"umask.\n"

#: src/mktemp.c:77
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     створити каталог, а не файл\n"
"  -u, --dry-run       не створювати нічого; лише вивести назву (не є "
"безпечним)\n"
"  -q, --quiet         вимкнути діагностику щодо помилок створення файлів і "
"каталогів\n"

#: src/mktemp.c:82
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X\n"
msgstr ""
"      --suffix=СУФФ   додавати СУФФ до ШАБЛОНу. СУФФ не повинен містити "
"символів\n"
"                      похилої риски.\n"
"                        Цей параметр буде використано, якщо ШАБЛОН не "
"завершується на X.\n"

#: src/mktemp.c:86
msgid ""
"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name;\n"
"                        unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""
"  -p КАТ, --tmpdir[=КАТ] інтерпретувати ШАБЛОН відносно каталогу КАТ. Якщо "
"КАТ не\n"
"                     вказано, використовується $TMPDIR, якщо значення не\n"
"                     задане, використовується /tmp., ШАБЛОН не повинен бути\n"
"                     абсолютною назвою. На відміну від -t, ШАБЛОН може\n"
"                     містити похилі риски, але mktemp створюватиме лише\n"
"                     останній компонент таких записів.\n"

#: src/mktemp.c:93
msgid ""
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -t                  вважати ШАБЛОН одиночним компонентом назви файла,\n"
"                        відносно каталогу: $TMPDIR, якщо встановлено; у "
"іншому\n"
"                        разі каталог вказується у -p; інакше /tmp "
"[застаріло]\n"

#: src/mktemp.c:211
#, c-format
msgid "too many templates"
msgstr "надто багато шаблонів"

#: src/mktemp.c:231
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "у разі визначення --suffix, шаблон %s має завершувати на X"

#: src/mktemp.c:256 src/split.c:1345
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "некоректний шаблон, %s, містить символ розділення каталогів"

#: src/mktemp.c:261
#, c-format
msgid "too few X's in template %s"
msgstr "надто мало символів X у шаблоні %s"

#: src/mktemp.c:277
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "неправильний шаблон, %s, містить символ розділення каталогів"

#: src/mktemp.c:291
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "неправильний шаблон, %s; з --tmpdir, він не може бути абсолютним"

#: src/mktemp.c:312
#, c-format
msgid "failed to create directory via template %s"
msgstr "не вдалося створити каталог через шаблон %s"

#: src/mktemp.c:323
#, c-format
msgid "failed to create file via template %s"
msgstr "не вдалося створити файл через шаблон %s"

#: src/mv.c:298
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr ""
"Перейменовує ДЖЕРЕЛО у ПРИЗНАЧЕННЯ, або переміщує ДЖЕРЕЛА до КАТАЛОГУ.\n"

#: src/mv.c:304
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=КОНТРОЛЬ]      створювати резервні копії цільових файлів\n"
"  -b                           те саме, що та --backup, але без аргументу\n"
"  -f, --force                  переписувати існуючі файли без підтвердження\n"
"  -i, --interactive            запитувати підтвердження, перш ніж\n"
"                                 переписувати\n"
"  -n, --no-clobber             не переписувати вже створені файли\n"
"Якщо буде вказано декілька -i, -f, -n, братиметься до уваги лише останній\n"
"параметр.\n"

#: src/mv.c:313
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes вилучає всі кінцеві косі риски з кожного\n"
"                               аргументу ДЖЕРЕЛО\n"
"  -S, --suffix=СУФІКС          перевизначає суфікс для резервних копій\n"

#: src/mv.c:318
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -Z, --context                set SELinux security context of destination\n"
"                                 file to default type\n"
msgstr ""
"  -t, --target-directory=КАТАЛОГ перемістити всі ДЖЕРЕЛА у КАТАЛОГ\n"
"  -T, --no-target-directory    вважати ЦІЛЬ звичайним файлом\n"
"  -u, --update                 переміщувати лише тоді коли файл ДЖЕРЕЛО\n"
"                                 новіший ніж цільовий файл, або коли\n"
"                                 цільовий файл відсутній\n"
"  -v, --verbose                пояснювати виконувані дії\n"
"  -Z, --context                встановити типовий тип контексту захисту "
"SELinux\n"
"                                 для призначення\n"

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "Використання: %s [КЛЮЧ] [КОМАНДА [АРГ]...]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""
"Запускає КОМАНДУ зі зміненим значенням поступливості, що впливає на "
"пріоритет\n"
"для планувальника.  Якщо КОМАНДУ не вказано, виводиться поточне значення\n"
"поступливості. Допустимі межі: від %d (найбільший пріоритет) до %d\n"
"(найменший).\n"

#: src/nice.c:83
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"  -n, --adjustment=N   збільшити поступливість на ціле число N (типово 10)\n"

#: src/nice.c:173
#, c-format
msgid "invalid adjustment %s"
msgstr "неправильна поправка %s"

#: src/nice.c:182
#, c-format
msgid "a command must be given with an adjustment"
msgstr "якщо вказана поправка, треба вказати команду"

#: src/nice.c:189 src/nice.c:200
msgid "cannot get niceness"
msgstr "не вдалося дізнатись поступливість"

#: src/nice.c:206
#, c-format
msgid "cannot set niceness"
msgstr "не вдалося встановити значення поступливості"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:41
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:180
msgid "Write each FILE to standard output, with line numbers added.\n"
msgstr ""
"Вивести кожне ФАЙЛ до стандартного виведення із додаванням номерів рядків.\n"

#: src/nl.c:187
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for logical page delimiters\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=СТИЛЬ      використовувати СТИЛЬ нумерації рядків "
"тіла\n"
"  -d, --section-delimiter=СС      використовувати СС для розділення\n"
"                                  логічних сторінок\n"
"  -f, --footer-numbering=СТИЛЬ    використовувати СТИЛЬ нумерації рядків\n"
"                                  нижнього колонтитулу\n"

#: src/nl.c:192
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers for each "
"section\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=СТИЛЬ    використовувати СТИЛЬ нумерації рядків\n"
"                                  верхнього колонтитула\n"
"  -i, --page-increment=ЧИСЛО      крок збільшення номерів рядків\n"
"  -l, --join-blank-lines=ЧИСЛО    вказане ЧИСЛО порожніх рядків вважати\n"
"                                  одним\n"
"  -n, --number-format=ФОРМАТ      використовувати ФОРМАТ для номерів рядків\n"
"  -p, --no-renumber               не починати нумерацію з початку після\n"
"                                  кожного розділу\n"
"  -s, --number-separator=РЯДОК    додавати РЯДОК після номера\n"

#: src/nl.c:200
msgid ""
"  -v, --starting-line-number=NUMBER  first line number for each section\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=ЧИСЛО перший номер рядка для кожного розділу\n"
"  -w, --number-width=ЧИСЛО        використовувати вказане ЧИСЛО стовпчиків\n"
"                                  для номерів рядків\n"

#: src/nl.c:206
msgid ""
"\n"
"Default options are: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n"
"\n"
"CC are two delimiter characters used to construct logical page delimiters;\n"
"a missing second character implies ':'.\n"
msgstr ""
"\n"
"Типовими є такі параметри: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -"
"w6\n"
"\n"
"СС - це два знаки, які використовуються для відокремлення логічних "
"сторінок.\n"
"Якщо вказаний лише один, використовується «:».\n"

#: src/nl.c:213
msgid ""
"\n"
"STYLE is one of:\n"
"\n"
"  a      number all lines\n"
"  t      number only nonempty lines\n"
"  n      number no lines\n"
"  pBRE   number only lines that contain a match for the basic regular\n"
"         expression, BRE\n"
msgstr ""
"\n"
"Значенням параметра СТИЛЬ є один з таких рядків:\n"
"\n"
"  a         нумерувати всі рядки\n"
"  t         нумерувати лише не порожні рядки\n"
"  n         не нумерувати рядки\n"
"  pБФВ      нумерувати лише рядки, частина яких збігається з базовим\n"
"            формальним виразом БФВ\n"

#: src/nl.c:223
msgid ""
"\n"
"FORMAT is one of:\n"
"\n"
"  ln     left justified, no leading zeros\n"
"  rn     right justified, no leading zeros\n"
"  rz     right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"ФОРМАТ вказується як один з наступних рядків:\n"
"\n"
"  ln   вирівнювати по лівому краю, не виводити початкові нулі\n"
"  rn   вирівнювати по правому краю, не виводити початкові нулі\n"
"  rz   вирівнювати по правому краю, виводити початкові нулі\n"
"\n"

#: src/nl.c:281
msgid "line number overflow"
msgstr "переповнення номера рядка"

#: src/nl.c:484
#, c-format
msgid "invalid header numbering style: %s"
msgstr "неправильний стиль нумерації заголовка: %s"

#: src/nl.c:492
#, c-format
msgid "invalid body numbering style: %s"
msgstr "неправильний стиль нумерації тіла: %s"

#: src/nl.c:500
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "неправильний стиль нумерації нижнього колонтитула: %s"

#: src/nl.c:507
msgid "invalid starting line number"
msgstr "неправильний номер початкового рядка"

#: src/nl.c:512
msgid "invalid line number increment"
msgstr "неправильний приріст номера рядка"

#: src/nl.c:519
msgid "invalid line number of blank lines"
msgstr "неправильна кількість порожніх рядків"

#: src/nl.c:526
msgid "invalid line number field width"
msgstr "неправильна ширина поля для номера рядка"

#: src/nl.c:537
#, c-format
msgid "invalid line numbering format: %s"
msgstr "неправильний формат нумерації рядків: %s"

#: src/nohup.c:50
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s КОМАНДА [АРГУМЕНТ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/nohup.c:56
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"Виконує КОМАНДУ ігноруючи сигнали обриву термінальної лінії.\n"
"\n"

#: src/nohup.c:62
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from an unreadable file.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"Якщо стандартне введення відбувається з термінала, перенаправте його з "
"непридатного до читання файла.\n"
"Якщо стандартний вивід відбувається до термінала, якщо можливо, допишіть\n"
"виведене до 'ohup.out' або '$HOME/nohup.out', якщо першим варіантом не можна "
"скористатися.\n"
"Якщо стандартний потік помилок виводиться на екран, перенаправте його до\n"
"стандартного потоку виведення. Щоб зберегти виведене до ФАЙЛа, скористайтеся "
"командою «%s КОМАНДА > ФАЙЛ».\n"

#: src/nohup.c:123
#, c-format
msgid "failed to render standard input unusable"
msgstr ""
"не вдалося обробити, не вдалося використати стандартне джерело введення"

#: src/nohup.c:125
#, c-format
msgid "ignoring input"
msgstr "всі аргументи проігноровані"

#: src/nohup.c:169
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "вивід додається у %s"

#: src/nohup.c:170
#, c-format
msgid "appending output to %s"
msgstr "виведення додається до %s"

#: src/nohup.c:188
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "ігнорується ввід та перенаправлення stderr на stdout"

#: src/nohup.c:189
#, c-format
msgid "redirecting stderr to stdout"
msgstr "переспрямування stderr до stdout"

#: src/nohup.c:193
#, c-format
msgid "failed to redirect standard error"
msgstr "не вдалося перенаправити стандартний потік помилок"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33 src/sync.c:34
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:121 src/whoami.c:44
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "Використання: %s [КЛЮЧ]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"Виводить кількість модулів обробки, доступних поточному процесу,\n"
"може бути меншим за кількість процесорів, які працюватимуть.\n"
"\n"

#: src/nproc.c:63
msgid ""
"      --all      print the number of installed processors\n"
"      --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"     --all      вивести кількість встановлених процесорів\n"
"     --ignore=N  якщо можна, виключити N модулів обробки\n"

#: src/numfmt.c:694
#, c-format
msgid "value too large to be converted: %s"
msgstr "значення є надто великим для перетворення: %s"

#: src/numfmt.c:698
#, c-format
msgid "invalid number: %s"
msgstr "некоректне число: %s"

#: src/numfmt.c:702
#, c-format
msgid "rejecting suffix in input: %s (consider using --from)"
msgstr ""
"відкидаємо суфікс %s у вхідних даних (варто використовувати --from для його "
"збереження)"

#: src/numfmt.c:706
#, c-format
msgid "invalid suffix in input: %s"
msgstr "некоректний суфікс у вхідних даних: %s"

#: src/numfmt.c:710
#, c-format
msgid "missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)"
msgstr "у вхідних даних не вистачає суфікса «i»: %s (наприклад Ki/Mi/Gi)"

#: src/numfmt.c:757 src/numfmt.c:809
#, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr "не вдалося приготувати значення «%Lf» для виводу"

#: src/numfmt.c:858
#, c-format
msgid "invalid unit size: %s"
msgstr "некоректна одиниця розміру: %s"

#: src/numfmt.c:884
#, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr "Користування: %s [ПАРАМЕТР]... [ЧИСЛО]...\n"

#: src/numfmt.c:887
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""
"Виконати переформатування числа ЧИСЛО або чисел зі стандартного джерела "
"даних, якщо ЧИСЛО не вказано.\n"

#: src/numfmt.c:891
msgid "      --debug          print warnings about invalid input\n"
msgstr ""
"      --debug          виводити попередження щодо некоректних вхідних даних\n"

#: src/numfmt.c:894
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr ""
"  -d, --delimiter=X    використовувати X замість пробілу для відокремлення "
"полів\n"

#: src/numfmt.c:897
msgid ""
"      --field=FIELDS   replace the numbers in these input fields "
"(default=1)\n"
"                         see FIELDS below\n"
msgstr ""
"      --field=ПОЛЯ     замінити номери у вказаних полях вхідних даних "
"(типово=1)\n"
"                         див. ПОЛЯ нижче\n"

#: src/numfmt.c:901
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""
"      --format=ФОРМАТ  використовувати форматування у стилі printf;\n"
"                         див. докладний опис форматів нижче\n"

#: src/numfmt.c:905
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""
"      --from=ОДИНИЦЯ   автоматично масштабувати вхідні числа за ОДИНИЦЕЮ; "
"типове значення -- 'none';\n"
"                         див. опис одиниць нижче\n"

#: src/numfmt.c:909
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr ""
"      --from-unit=N    вказати розмірність одиниці у вхідних даних (замість "
"типової 1)\n"

#: src/numfmt.c:912
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""
"      --grouping       групувати цифри відповідно до правил локалі, "
"наприклад 1.000.000\n"
"                         (не працюватиме у локалі C/POSIX)\n"

#: src/numfmt.c:916
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""
"      --header[=N]     вивести (без перетворення) перші N рядків заголовка;\n"
"                         якщо не вказано, типовим значенням є 1\n"

#: src/numfmt.c:920
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""
"      --invalid=РЕЖИМ режим обробки некоректних символів. Можливі режими:\n"
"                  abort (перервати обробку, типовий), fail (обробити з "
"помилками),\n"
"                  warn (попередити), ignore (ігнорувати).\n"

#: src/numfmt.c:924
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""
"      --padding=N     доповнити виведені дані до N символів.\n"
"                      Використання додатного N призведе до вирівнювання "
"праворуч\n"
"                      Від'ємні N вирівнюватимуть дані ліворуч.\n"
"                      Зауваження: якщо виведені дані будуть довшими за N,\n"
"                      доповнення не відбуватиметься. Типовим є автоматичне "
"доповнення,\n"
"                      якщо буде виявлено пробіли.\n"

#: src/numfmt.c:931
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""
"      --round=СПОСІБ  спосіб округлення під час масштабування. Варіанти:\n"
"                         up (до більшого), down (до меншого), from-zero (до "
"дальшого\n"
"                         до нуля, типовий), towards-zero (до ближчого до "
"нуля),\n"
"                         nearest (до найближчого цілого\n"

#: src/numfmt.c:935
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""
"      --suffix=СУФІКС додати СУФІКС до виведених чисел і використовувати "
"СУФІКС\n"
"                         у вхідних даних.\n"

#: src/numfmt.c:939
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""
"      --to=ОДИНИЦЯ     автоматично масштабувати виведені числа за ОДИНИЦЕЮ; "
"див. опис одиниць нижче\n"

#: src/numfmt.c:942
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr ""
"      --to-unit=N      розмірність одиниці у виведених даних (замість "
"типової 1)\n"

#: src/numfmt.c:951
msgid ""
"\n"
"UNIT options:\n"
msgstr ""
"\n"
"Параметри одиниць:\n"

#: src/numfmt.c:954
msgid "  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr ""
"  none       без автоматичного масштабування; використання суфіксів призведе "
"до повідомлення про помилку\n"

#: src/numfmt.c:957
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""
"  auto       приймати додаткові одно-/дволітерні суфікси:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"

#: src/numfmt.c:963
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""
"  si         приймати додаткові однолітерні суфікси:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"

#: src/numfmt.c:968
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""
"  iec        приймати додаткові однолітерні суфікси:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"

#: src/numfmt.c:973
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""
"  iec-i      приймати додаткові дволітерні суфікси:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"

#: src/numfmt.c:979
msgid ""
"\n"
"FIELDS supports cut(1) style field ranges:\n"
"  N    N'th field, counted from 1\n"
"  N-   from N'th field, to end of line\n"
"  N-M  from N'th to M'th field (inclusive)\n"
"  -M   from first to M'th field (inclusive)\n"
"  -    all fields\n"
"Multiple fields/ranges can be separated with commas\n"
msgstr ""
"\n"
"У значенні ПОЛЯ передбачено підтримку стилю cut(1) діапазонів полів:\n"
"  N    N-те поле, відлік від 1\n"
"  N-   з поля N до кінця рядка\n"
"  N-M  з поля N до поля M (включно)\n"
"  -M   від першого поля до поля M (включно)\n"
"  -    усі поля\n"
"Можна вказати декілька полів/діапазонів, відокремивши їх комами\n"

#: src/numfmt.c:989
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional zero (%010f) width\n"
"will zero pad the number. Optional negative values (%-10f) will left align.\n"
"Optional precision (%.1f) will override the input determined precision.\n"
msgstr ""
"\n"
"ФОРМАТ має відповідати виведенню одного аргументу з рухомою крапкою -- "
"«%f».\n"
"Використання лапки (%'f) увімкне параметр --grouping (якщо він підтримується "
"поточною локаллю).\n"
"Додаткове визначення довжини (%10f) призведе до доповнення виведених даних.\n"
"Додаткова нульова довжина (%010f) призведе до нульового доповнення числа. "
"Додаткові від'ємні\n"
"значення довжини (%-10f) вирівнюватимуть виведення ліворуч.\n"
"Додатковий параметр точності (%.1f) перевизначає точність, визначену "
"вхідними даними.\n"

#: src/numfmt.c:997
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""
"\n"
"Станом виходу буде 0, якщо всі числа у вхідних даних було успішно "
"перетворено.\n"
"Типово, %s припинить обробку після першої ж помилки зі станом виходу 2.\n"
"Якщо буде вказано --invalid='fail', для кожної помилки перетворення буде\n"
"виведено попередження, а станом виходу буде 2. Якщо буде вказано\n"
"--invalid='warn', буде виявлено всіх помилки перетворення, але станом "
"виходу\n"
"буде 0. Якщо буде вказано --invalid='ignore', про помилки перетворення не\n"
"повідомлятиметься, а станом виходу буде 0.\n"

#: src/numfmt.c:1006
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""
"\n"
"Прикладиs:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"

#: src/numfmt.c:1059 src/seq.c:248
#, c-format
msgid "format %s has no %% directive"
msgstr "формат %s не містить директиву %%"

#: src/numfmt.c:1086
#, c-format
msgid "invalid format %s (width overflow)"
msgstr "некоректний формат %s (переповнення ширини)"

#: src/numfmt.c:1091
#, c-format
msgid "--format padding overriding --padding"
msgstr "--format доповнення перевизначає --padding"

#: src/numfmt.c:1110 src/seq.c:265
#, c-format
msgid "format %s ends in %%"
msgstr "формат %s закінчується у %%"

#: src/numfmt.c:1126
#, c-format
msgid "invalid precision in format %s"
msgstr "некоректна точність у форматуванні %s"

#: src/numfmt.c:1132
#, c-format
msgid "invalid format %s, directive must be %%[0]['][-][N][.][N]f"
msgstr "некоректний формат %s, інструкцією має бути %%[0]['][-][N][.][N]f"

#: src/numfmt.c:1140 src/seq.c:272
#, c-format
msgid "format %s has too many %% directives"
msgstr "формат %s має надто багато директив %%"

#: src/numfmt.c:1183
#, c-format
msgid "invalid suffix in input %s: %s"
msgstr "некоректний суфікс у вхідних даних %s: %s"

#: src/numfmt.c:1212
#, c-format
msgid ""
"value/precision too large to be printed: '%Lg/%<PRIuMAX>' (consider using --"
"to)"
msgstr ""
"значення або точність є надто великим для виведення: «%Lg/%<PRIuMAX>» (варто "
"скористатися --to)"

#: src/numfmt.c:1216
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr ""
"значення є надто великим для виведення: «%Lg» (варто скористатися --to)"

#: src/numfmt.c:1225
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr ""
"значення є надто великим для виведення: «%Lg» (обробка значень більше 999Y "
"неможлива)"

#: src/numfmt.c:1311
#, c-format
msgid "large input value %s: possible precision loss"
msgstr "занадто велике вхідне значення, %s, можлива втрата точності"

#: src/numfmt.c:1500
#, c-format
msgid "invalid padding value %s"
msgstr "некоректне значення доповнення %s"

#: src/numfmt.c:1513
msgid "multiple field specifications"
msgstr "специфікація використання декількох полів"

#: src/numfmt.c:1547
#, c-format
msgid "invalid header value %s"
msgstr "некоректне значення заголовка, %s"

#: src/numfmt.c:1574
msgid "--grouping cannot be combined with --format"
msgstr "--grouping не можна використовувати разом з --format"

#: src/numfmt.c:1577 src/sort.c:4686
#, c-format
msgid "failed to set locale"
msgstr "не вдалося встановити локаль"

#: src/numfmt.c:1582
#, c-format
msgid "no conversion option specified"
msgstr "не вказано параметра перетворення"

#: src/numfmt.c:1590
msgid "grouping cannot be combined with --to"
msgstr "grouping не можна використовувати разом з --to"

#: src/numfmt.c:1592
#, c-format
msgid "grouping has no effect in this locale"
msgstr "групування не діє у цій локалі"

#: src/numfmt.c:1605
#, c-format
msgid "--header ignored with command-line input"
msgstr ""
"--header проігноровано, оскільки вхідні дані надходять з командного рядка"

#: src/numfmt.c:1632
#, c-format
msgid "error reading input"
msgstr "помилка під час спроби читання вхідних даних"

#: src/numfmt.c:1643
#, c-format
msgid "failed to convert some of the input numbers"
msgstr "не вдалося перетворити деякі з вхідних чисел"

#: src/od.c:323
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]...\n"
"       або:    %s [-abcdfilosx]... [ФАЙЛ] [[+]ЗСУВ[.][b]]\n"
"       або:    %s --traditional [КЛЮЧ]... [ФАЙЛ] [[+]ЗСУВ[.][b] [+][МІТКА][.]"
"[b]]\n"

#: src/od.c:329
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
msgstr ""
"\n"
"Виводить однозначне (типово байтове вісімкове) представлення ФАЙЛА\n"
"на стандартне виведення. Якщо вказано декілька аргументів ФАЙЛ,\n"
"сполучає їх до одного фрагмента даних у вказаному порядку для\n"
"формування результатів.\n"
"\n"

#: src/od.c:337
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"Якщо застосовуються й перша, й друга форми виклику, вважається друга\n"
"форма, якщо останній операнд починається на + або (якщо вказані два\n"
"операнда) на цифру.  Операнд ЗСУВ означає -j ЗСУВ.  МІТКА --\n"
"це псевдоадреса першого виведеного байту, збільшується у процесі\n"
"виводу.  Префікс 0x або 0X задає ЗСУВ або МІТКУ як\n"
"шістнадцяткові числа, суфікс . -- як вісімкові, а суфікс b\n"
"помножує на 512.\n"

#: src/od.c:349
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"      --endian={big|little}   swap input bytes according the specified "
"order\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=ОСНОВА  виводити зсув у файлах використовуючи\n"
"                              вказану систему числення\n"
"\n"
"                              ОСНОВОЮ може бути одна з літер [doxn],\n"
"                              десяткова, вісімкова, шістнадцяткова або\n"
"                              ніяка\n"
"      --endian={big|little}   встановити вказаний порядок байтів\n"
"  -j, --skip-bytes=Н          пропустить перші Н байт\n"

#: src/od.c:355
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars;\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""
"  -N, --read-bytes=N          читати лише N байтів у кожному файлі\n"
"  -S, --strings[=N]           виводити рядки довжиною принаймні N байтів\n"
"                              графічних знаків\n"
"                                Якщо N не вказано, буде використано 3\n"
"  -t, --format=ТИП            вибір формату або форматів виводу\n"
"  -v, --output-duplicates     не позначати знаком * рядки, що не виводяться\n"
"  -w[N], --width[=N]          виводити N байтів у кожному рядку виводу\n"
"                                Якщо N не вказано, буде використано 32\n"
"      --traditional           приймати аргументи у традиційній формі\n"

#: src/od.c:368
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select printable characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"\n"
"Традиційні специфікації формату можна змішувати, вони акумулюються:\n"
"  -a   синонім -t a,  іменовані знаки\n"
"  -b   синонім -t o1, вісімкові байти\n"
"  -c   синонім -t c,  придатні до показу симовли або керівні послідовності з "
"'\\'\n"
"  -d   синонім -t u2, беззнакові десяткові двобайтові одиниці\n"

#: src/od.c:377
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f   синонім -t fF, числа з рухомою комою\n"
"  -i   синонім -t dI, десяткові цілі\n"
"  -l   синонім -t dL, десяткові довгі цілі\n"
"  -o   синонім -t o2, вісімкові двобайтові одиниці\n"
"  -s   синонім -t d2, десяткові двобайтові одиниці\n"
"  -x   синонім -t x2, шістнадцяткові двобайтові одиниці\n"

#: src/od.c:385
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          printable character or backslash escape\n"
msgstr ""
"\n"
"\n"
"ТИП може складатись з одного або більше наступних описів:\n"
"  a          іменований знак\n"
"  c          придатний до показу символ або керівна послідовність з '\\'\n"

#: src/od.c:392
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per float\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[ЧИСЛО]   знакове десяткове ціле розміром вказане ЧИСЛО байт\n"
"  f[ЧИСЛО]   число з рухомою крапкою розміром вказане ЧИСЛО байт\n"
"  o[ЧИСЛО]   вісімкове ціле розміром вказане ЧИСЛО байт\n"
"  u[ЧИСЛО]   беззнакове десяткове ціле розміром вказане ЧИСЛО байт\n"
"  x[ЧИСЛО]   шістнадцяткове ціле розміром вказане ЧИСЛО байт\n"

#: src/od.c:399
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"Якщо ТИП -- одна з літер [doux], ЧИСЛО можна вказувати як C (char), S "
"(short),\n"
"I (int) або L (long), якщо ТИП дорівнює f, ЧИСЛО може бути F (float),\n"
"D (double) або L (long double).\n"

#: src/od.c:406
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""
"\n"
"Додавання суфікса z до будь-якого типу призведе до виведення видимих "
"символів\n"
"наприкінці кожного рядка виведених даних.\n"

#: src/od.c:411
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"\n"
"Після ЧИСЛА блоків та байт може стояти один з суфіксів-множників:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"тощо для G, T, P, E, Z, Y.\n"
"Можна також використовувати двійкові префікси: KiB=K, MiB=M тощо.\n"

#: src/od.c:685 src/od.c:805
#, c-format
msgid "invalid type string %s"
msgstr "неправильний рядок типу %s"

#: src/od.c:695
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"неправильно вказаний рядок типу %s;\n"
"ця система не підтримує %lu-байтове цілого типу"

#: src/od.c:816
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"неправильно вказаний тип %s;\n"
"ця система не підтримує %lu-байтове типу з рухомою комою"

#: src/od.c:874
#, c-format
msgid "invalid character '%c' in type string %s"
msgstr "неправильний знак '%c' у рядку типу %s"

#: src/od.c:1110
msgid "cannot skip past end of combined input"
msgstr "неможливо перейти за межу останнього вхідного файла"

#: src/od.c:1660
#, c-format
msgid "invalid output address radix '%c'; it must be one character from [doxn]"
msgstr ""
"неправильно вказана основа системи числення '%c', повинна бути одним з "
"символів [doxn]"

#: src/od.c:1798
msgid "no type may be specified when dumping strings"
msgstr "при дампі рядків не можна вказувати тип"

#: src/od.c:1873
msgid "compatibility mode supports at most one file"
msgstr "у режимі сумісності підтримується не більше одного файла."

#: src/od.c:1894
msgid "skip-bytes + read-bytes is too large"
msgstr "значення skip-bytes + read-bytes надто велике"

#: src/od.c:1937
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "попередження: неправильна ширина %lu; буде використана %d"

#: src/paste.c:222
msgid "standard input is closed"
msgstr "стандартний ввід закритий"

#: src/paste.c:440
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
msgstr ""
"Вивести рядки, що складаються з послідовності відповідних рядків із\n"
"кожного ФАЙЛа, відокремлені табуляціями, до стандартного виведення.\n"

#: src/paste.c:448
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=СПИСОК  використовувати замість табуляції знаки зі "
"СПИСКУ\n"
"  -s, --serial             обробляти файли послідовно\n"

#: src/paste.c:518
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "список роздільників завершується неекранованою зворотною рискою: %s"

#: src/pathchk.c:89
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"Виявляє некоректні та непереносні конструкції у назвах файлів.\n"
"\n"
"  -p                  перевірка для більшості POSIX-систем\n"
"  -P                  перевірка на порожні назви та початковий «-»\n"
"      --portability   перевірка для усіх POSIX-систем (еквівалентно до -p -"
"P)\n"

#: src/pathchk.c:169
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr "початковий '-' у компоненті назві файла %s"

#: src/pathchk.c:195
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "непереносний знак %s у назві файла %s"

#: src/pathchk.c:271
#, c-format
msgid "empty file name"
msgstr "порожня назва файла"

#: src/pathchk.c:313
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s: не вдалося визначити максимальну довжину назви файла"

#: src/pathchk.c:324
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "межу %lu перевищено довжиною %lu у назві файла %s"

#: src/pathchk.c:410
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr "перевищено обмеження %lu довжиною %lu у компоненті імені файла %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:37 src/uptime.c:45 src/users.c:35 src/who.c:50
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:39 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:241
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:265
msgid "?????"
msgstr "?????"

#: src/pinky.c:313
#, c-format
msgid "Login name: "
msgstr "Реєстраційна назва: "

#: src/pinky.c:316
#, c-format
msgid "In real life: "
msgstr "У реальному житті: "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:320
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:340
#, c-format
msgid "Directory: "
msgstr "Каталог: "

#: src/pinky.c:342
#, c-format
msgid "Shell: "
msgstr "Оболонка: "

#: src/pinky.c:361
#, c-format
msgid "Project: "
msgstr "Проект: "

#: src/pinky.c:385
#, c-format
msgid "Plan:\n"
msgstr "План:\n"

#: src/pinky.c:404
msgid "Login"
msgstr "Реєстраційне ім'я'"

#: src/pinky.c:406
msgid "Name"
msgstr "Назва"

#: src/pinky.c:407
msgid " TTY"
msgstr " Термінал"

#: src/pinky.c:409
msgid "Idle"
msgstr "Неактивний"

#: src/pinky.c:410
msgid "When"
msgstr "Коли"

#: src/pinky.c:413
msgid "Where"
msgstr "Де"

#: src/pinky.c:490
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              використовувати докладний формат виводу\n"
"  -b              опустити у докладному форматі початковий каталог та\n"
"                  оболонку цього користувача\n"
"  -h              опустити у докладному форматі файл проекту цього\n"
"                  користувача\n"
"  -p              опустити у докладному форматі файл плану цього\n"
"                  користувача\n"
"  -s              короткий формат виводу, типово використовується\n"

#: src/pinky.c:498
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              опустити у короткому форматі рядок з заголовками колонок\n"
"  -w              опустити у короткому форматі повне ім'я користувача\n"
"  -i              опустити у короткому форматі повне ім'я користувача та\n"
"                  назву віддаленої машини\n"
"  -q              опустити у короткому форматі повне ім'я користувача,\n"
"                  назву віддаленої машини та час неактивності\n"

#: src/pinky.c:507
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"Спрощена програма 'finger';  виводить відомості про користувача.\n"
"У складі файла utmp буде використовуватися %s.\n"

#: src/pinky.c:591
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr ""
"не вказано ім'я користувача; при використанні ключа -l треба вказати хоча б "
"одне"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:332
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:333
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:778
msgid "integer overflow"
msgstr "переповнення цілочислової змінної"

#: src/pr.c:917
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "'--pages=ПЕРША_СТОР[:ОСТАННЯ_СТОР]' пропущений аргумент"

#: src/pr.c:919
#, c-format
msgid "invalid page range %s"
msgstr "некоректний діапазон сторінок %s"

#: src/pr.c:979
msgid "'-l PAGE_LENGTH' invalid number of lines"
msgstr "«-l ДОВЖИНА_СТОРІНКИ» — неправильна кількість рядків"

#: src/pr.c:994
msgid "'-N NUMBER' invalid starting line number"
msgstr "«-N НОМЕР» — неправильний номер початкового рядка"

#: src/pr.c:998
msgid "'-o MARGIN' invalid line offset"
msgstr "«-o ПОЛЕ» — неправильний зсув"

#: src/pr.c:1035
msgid "'-w PAGE_WIDTH' invalid number of characters"
msgstr "«-w ШИРИНА_СТОРІНКИ» неправильна кількість знаків"

#: src/pr.c:1044
msgid "'-W PAGE_WIDTH' invalid number of characters"
msgstr "«-W ШИРИНА_СТОРІНКИ» неправильна кількість знаків"

#: src/pr.c:1073
msgid "cannot specify number of columns when printing in parallel"
msgstr "неможливо вказати кількість позицій під час паралельного друку"

#: src/pr.c:1077
msgid "cannot specify both printing across and printing in parallel"
msgstr "не можна одночасно вказувати друк вздовж і паралельно."

#: src/pr.c:1180
#, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr "'-%c' зайві знаки або неправильне число у аргументі: %s"

#: src/pr.c:1282
msgid "page width too narrow"
msgstr "сторінка надто вузька"

#: src/pr.c:2338
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr ""
"номер початкової сторінки %<PRIuMAX> перевищує загальну кількість сторінок "
"%<PRIuMAX>"

#: src/pr.c:2365
msgid "page number overflow"
msgstr "переповнення номеру сторінок"

#: src/pr.c:2370
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "Сторінка %<PRIuMAX>"

#: src/pr.c:2742
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr "Розбиває ФАЙЛ(и) на сторінки або колонки під час виведення.\n"

#: src/pr.c:2749
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +ПЕРША_СТОРІНКА[:ОСТАННЯ_СТОРІНКА], --pages=ПЕРША_СТОРІНКА[:"
"ОСТАННЯ_СТОРІНКА]\n"
"                    почати [завершити] друк на ПЕРШІЙ_[ОСТАННІЙ_]СТОРІНЦІ\n"
"  -КІЛЬКІСТЬ, --columns=КІЛЬКІСТЬ\n"
"                    виводити вказану КІЛЬКІСТЬ колонок та виводити їх вниз,\n"
"                    лише коли не вказаний ключ -a.  Балансувати кількість\n"
"                    рядків у колонці на кожній сторінці.\n"

#: src/pr.c:2757
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across      виводити колонки поперек, а не вниз; використовується\n"
"                    разом з ключем -ЧИСЛО\n"
"  -c, --show-control-chars\n"
"                    використовувати запис з шапочкою (^G) або зворотною\n"
"                    косою рискою (та вісімковим кодом)\n"
"  -d,  --double-space\n"
"                    вставляти порожній рядок після кожного виведеного рядка\n"

#: src/pr.c:2765
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=ФОРМАТ\n"
"                    використовувати для дати у заголовку вказаний ФОРМАТ\n"
"  -e[ЗНАК[ЧИСЛО]], --expand-tabs[=ЗНАК[ЧИСЛО]]\n"
"                    перетворювати вхідні ЗНАКИ (табуляцію) у вказане ЧИСЛО\n"
"                    пробілів (8)\n"
"  -F, -f, --form-feed\n"
"                    для розділення сторінок вживати знак переносу сторінки,\n"
"                    а не нового рядка (з трьохрядковим заголовком, якщо є\n"
"                    ключ -F, та п'ятирядковим заголовком та кінцівкою, якщо\n"
"                    ключ -F не вказаний)\n"

#: src/pr.c:2775
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h ЗАГОЛОВОК, --header=ЗАГОЛОВОК\n"
"                   використовувати для сторінок центрований ЗАГОЛОВОК, а не\n"
"                   назву файла;  -h \"\" виводить порожній рядок; не\n"
"                   використовуйте -h \"\"\n"
"  -i[ЗНАК[ШИРИНА]], --output-tabs[=ЗНАК[ШИРИНА]]\n"
"                   замінити пробіли ЗНАКАМИ (табуляцію) вказаної ШИРИНИ (8)\n"
"  -J, --join-lines об'єднувати повні рядки, вимкнути урізання рядків (-W),\n"
"                   не вирівнювати колонки, --sep-string[=РЯДОК]\n"
"                   задає розділювачі\n"

#: src/pr.c:2784
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63).\n"
"                    implies -t if PAGE_LENGTH <= 10\n"
msgstr ""
"  -l, --length=ДОВЖИНА_СТОРІНКИ\n"
"                    встановити ДОВЖИНУ_СТОРІНКИ (66)\n"
"                    (типово кількість рядків тексту рівно 56, а з -F 63).\n"
"                    Використовує -t, якщо ДОВЖИНА_СТОРІНКИ <= 10\n"

#: src/pr.c:2790
msgid ""
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -m, --merge       виводити всі файли паралельно, по одному у стовпчику,\n"
"                    урізати рядка, але з'єднувати повні рядки при -J\n"

#: src/pr.c:2794
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[РОЗД[ЧИСЛО]], --number-lines[=РОЗД[ЧИСЛО]]\n"
"                    нумерувати рядки, використовуючи вказане ЧИСЛО (5) цифр\n"
"                    та РОЗДілювач (табуляцію); типово нумерація починається\n"
"                    з першого вхідного рядка\n"
"  -N, --first-line-number=НОМЕР\n"
"                    почати нумерацію з НОМЕРА з першого рядка першої\n"
"                    сторінки, що виводиться (дивіться +ПЕРША_СТОРІНКА)\n"

#: src/pr.c:2802
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=ПОЛЕ\n"
"                    зсувати кожен рядок на ПОЛЕ (нуль) пробілів (не впливає\n"
"                    на -w або -W); ПОЛЕ додається до ШИРИНА_СТОРІНКИ\n"
"  -r, --no-file-warnings\n"
"                    не попереджати про неможливість відкриття файла\n"

#: src/pr.c:2809
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -"
"w.\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[ЗНАК],--separator[=ЗНАК]\n"
"                    розділяти колонки одним знаком, типово ЗНАК дорівнює\n"
"                    табуляції, без ключа -w, та порожній, якщо є ключ -w.\n"
"                    -s[ЗНАК] вимикає урізання рядків для усіх трьох ключів\n"
"                    для колонок (-ЧИСЛО |-a -ЧИСЛО|-m), якщо немає ключа -"
"w.\n"

#: src/pr.c:2817
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
msgstr ""
"  -S[РЯДОК], --sep-string[=РЯДОК]\n"
"                    розділяти колонки РЯДКОМ;\n"
"                    без -S: розділювач — табуляція, якщо вказано\n"
"                    ключ -J, інакше пробіл (те саме, що -S\" \"); не "
"впливає\n"
"                    на параметри для колонок\n"

#: src/pr.c:2823
msgid ""
"  -t, --omit-header  omit page headers and trailers;\n"
"                     implied if PAGE_LENGTH <= 10\n"
msgstr ""
"  -t, --omit-header  пропускати заголовки і кінцівки сторінок;\n"
"                     використовується, якщо ДОВЖИНА_СТОРІНКИ <= 10\n"

#: src/pr.c:2827
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    не виводити заголовки, ігнорувати символи розриву\n"
"                    сторінки у вхідних файлах\n"
"  -v, --show-nonprinting\n"
"                    використовувати запис з «\\» та вісімковим кодом\n"
"  -w, --width=ШИРИНА_СТОРІНКИ\n"
"                    встановити ШИРИНУ_СТОРІНКИ (72) у стовпчиках для\n"
"                    виводу у декілька колонок, -s[знак] вимикає (72)\n"

#: src/pr.c:2837
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=ШИРИНА_СТОРІНКИ\n"
"                    встановити ШИРИНУ_СТОРІНКИ (72) символи, усікати рядки,\n"
"                    якщо не вказаний ключ -J; не змінюється ключами -S чи -"
"s\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"Використання: %s [ПАРАМЕТР]... [ЗМІННА]...\n"
"Виводить значення вказаних змінних середовища.\n"
"Якщо параметр ЗМІННА не вказано, виводить пари назва-значення для всіх.\n"
"\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with NUL, not newline\n"
msgstr ""
"  -0, --null     завершувати кожен рядок нуль-байтом замість розриву рядка\n"

#: src/printf.c:84
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr ""
"попередження: %s: знаки, наступні за знаковою константою, проігноровані"

#: src/printf.c:93
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФОРМАТ [АРГУМЕНТ]...\n"
"       або:    %s КЛЮЧ\n"

#: src/printf.c:98
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"Виводить АРГУМЕНТ(и) відповідно до ФОРМАТ, або або виконати відповідно до "
"OPTION:\n"
"\n"

#: src/printf.c:104
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"ФОРМАТ керує виводом так само, як у функції C printf.\n"
"Приймаються наступні послідовності:\n"
"\n"
"  \\\"     подвійні лапки\n"

#: src/printf.c:122
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN    байт з вісімковим значенням NNN (від 1 до 3 цифр)\n"
"  \\xНН    байт з шістнадцятковим кодом НН (від 1 до 2 цифр)\n"
"  \\uНННН  знак Unicode (ISO/IEC 10646) з шістнадцятковим кодом НННН (4 "
"цифри)\n"
"  \\UНННННННН  знак Unicode з шістнадцятковим кодом НННННННН (8 цифр)\n"

#: src/printf.c:128
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"  %q      ARGUMENT is printed in a format that can be reused as shell "
"input,\n"
"          escaping non-printable characters with the proposed POSIX $'' "
"syntax.\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%      один символ %\n"
"  %b      АРГУМЕНТом є рядок із обробкою послідовностей «\\»,\n"
"          окрім вісімкових послідовностей у форматі \\0 або \\0NNN\n"
"  %q      АРГУМЕНТ виводиться у форматі, який можна використати для\n"
"          вхідних даних оболонки, із екрануванням непридатних до\n"
"          друку символів на основі запропоновано синтаксису POSIX $''.\n"
"\n"
"усі специфікації формату C, що завершуються на один із символів "
"diouxXfeEgGcs, разом із АРГУМЕНТОМ спочатку приводяться до належного типу.\n"
"Обробляються також знаки змінної ширини.\n"

#: src/printf.c:155
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: очікується числове значення"

#: src/printf.c:157
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: значення перетворене не повністю"

#: src/printf.c:254 src/printf.c:281
msgid "missing hexadecimal number in escape"
msgstr "неправильна шістнадцяткове число у escape-послідовності"

#: src/printf.c:293
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "неправильна універсальна назва знаку \\%c%0*x"

#: src/printf.c:566
#, c-format
msgid "invalid field width: %s"
msgstr "неправильна ширина поля: %s"

#: src/printf.c:601
#, c-format
msgid "invalid precision: %s"
msgstr "неправильна точність: %s"

#: src/printf.c:628
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s: неправильна специфікація перетворення"

#: src/printf.c:711
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "попередження: зайві аргументи проігноровані, починаючи з %s"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "Ф. Пінард"

#: src/ptx.c:424
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (для регулярного виразу %s)"

#: src/ptx.c:823
#, c-format
msgid "error: regular expression has a match of length zero: %s"
msgstr "помилка: формальний вираз має відповідник довжини нуль: %s"

#: src/ptx.c:1814
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ВХІД]... (без -G)\n"
"       або:    %s -G [КЛЮЧ]... [ВХІД [ВИХІД]]\n"

#: src/ptx.c:1818
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr ""
"Виводить переставлений алфавітний вказівник слів вхідних файлів, включаючи "
"контекст.\n"

#: src/ptx.c:1825
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
msgstr ""
"  -A, --auto-reference           виводити автоматично згенеровані посилання\n"
"  -G, --traditional              увімкнути режим сумісності з System V "
"(ptx)\n"

#: src/ptx.c:1829
msgid ""
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
"                                 The default is '/'\n"
msgstr ""
"  -F, --flag-truncation=РЯДОК    використовувати РЯДОК для позначення\n"
"                                 обрізаних рядків. Типовим є «/».\n"

#: src/ptx.c:1833
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=РЯДОК         назва макросу, яку слід використовувати\n"
"                                 замість 'xx'\n"
"  -O, --format=roff              генерувати вивід у вигляді директив roff\n"
"  -R, --right-side-refs          поміщати посилання справа, не діє при -w\n"
"  -S, --sentence-regexp=REGEXP   для кінця рядків або кінця речень\n"
"  -T, --format=tex               генерувати вивід у вигляді директив TeX\n"

#: src/ptx.c:1840
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=REGEXP       регулярний вираз для ключових слів\n"
"  -b, --break-file=ФАЙЛ          ФАЙЛ з символами-розділювачами слів\n"
"  -f, --ignore-case              перетворювати до верхнього регістру при\n"
"                                 сортуванні\n"
"  -g, --gap-size=ЧИСЛО           розмір проміжку між полями виводу,\n"
"                                 виражений у стовпчиках\n"
"  -i, --ignore-file=ФАЙЛ         прочитати перелік ігнорованих слів з ФАЙЛА\n"
"  -o, --only-file=ФАЙЛ           лише прочитати список слів з заданого "
"ФАЙЛА\n"

#: src/ptx.c:1848
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               перше поле у кожній рядку є посиланням\n"
"  -t, --typeset-mode               - не реалізовано -\n"
"  -w, --width=ЧИСЛО              ширина виводу у стовпчиках, без урахування "
"посилань\n"

#: src/ptx.c:1945
#, c-format
msgid "invalid gap width: %s"
msgstr "неправильна ширина інтервалу: %s"

#: src/ptx.c:1972
#, c-format
msgid "invalid line width: %s"
msgstr "неправильна довжина рядка: %s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"Виводить повну назву поточного робочого каталогу.\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical   використовувати PWD з середовища, навіть якщо там "
"містяться символічні посилання\n"
"  -P, --physical  пропустити всі символічні посилання\n"

#: src/pwd.c:68
msgid ""
"\n"
"If no option is specified, -P is assumed.\n"
msgstr ""
"\n"
"Якщо не вказано параметрів, буде використано параметр -P.\n"

#: src/pwd.c:169
#, c-format
msgid "failed to chdir to %s"
msgstr "помилка зміни каталогу на %s"

#: src/pwd.c:173 src/pwd.c:280 src/split.c:469
#, c-format
msgid "failed to stat %s"
msgstr "помилка отримання атрибутів %s"

#: src/pwd.c:238
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "у %s не знайдено запис каталогу з відповідним i-node"

#: src/pwd.c:367
#, c-format
msgid "ignoring non-option arguments"
msgstr "аргументи, що не є ключами проігноровані"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/shred.c:170 src/stat.c:1691
#: src/touch.c:213
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "Використання: %s [КЛЮЧ]... ФАЙЛ...\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"Виводить значення символічного посилання або канонічну назву файла\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize            отримати канонічну назву файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням в усіх компонентах шляху;\n"
"                                всі компоненти пути, крім останнього,\n"
"                                повинні існувати\n"
"  -e, --canonicalize-existing   отримати канонічну назву файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням у кожній компоненті вказаного "
"пути;\n"
"                                всі компоненти шляху повинні існувати\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet\n"
"  -s, --silent                  suppress most error messages (on by "
"default)\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    end each output line with NUL, not newline\n"
msgstr ""
"  -m, --canonicalize-missing    отримати канонічну назва файла шляхом\n"
"                                рекурсивного слідування по усім символьним\n"
"                                посиланням в усіх компонентах шляху;\n"
"                                компоненти не обов'язково мають існувати\n"
"  -n, --no-newline              не виводити кінцевий роздільник\n"
"  -q, --quiet\n"
"  -s, --silent                  не виводити повідомлення про помилки "
"(типово\n"
"                                 увімкнено)\n"
"  -v, --verbose                 повідомляти про помилки\n"
"  -z, --zero                    відокремлювати виведені рядки нуль-байтом,\n"
"                                 а не символом нового рядка\n"

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr "ігноруємо --no-newline з декількома аргументами"

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""
"Вивести визначену абсолютну назву файла;\n"
"всі компоненти, окрім останньої, має бути вже створено\n"
"\n"

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no path components need exist or be a "
"directory\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=DIR        print the resolved path relative to DIR\n"
"      --relative-base=DIR      print absolute paths unless paths below DIR\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   end each output line with NUL, not newline\n"
"\n"
msgstr ""
"  -e, --canonicalize-existing  всі компоненти шляху мають існувати\n"
"  -m, --canonicalize-missing   не повинно існувати жодного компонента або "
"каталогу\n"
"  -L, --logical                обробляти компоненти '..' до символічних "
"посилань\n"
"  -P, --physical               обробляти символічні посилання (типово)\n"
"  -q, --quiet                  придушити більшість повідомлень про помилки\n"
"      --relative-to=КАТ        вивести визначений шлях відносно каталогу "
"КАТ\n"
"      --relative-base=КАТ      вивести абсолютні шляхи, якщо вони не є "
"підлеглими каталогу КАТ\n"
"  -s, --strip, --no-symlinks   не розгортати символічні посилання\n"
"  -z, --zero                   відокремлювати частини результату NUL, а не "
"символом нового рядка\n"
"\n"

#: src/relpath.c:130
msgid "generating relative path"
msgstr "створення відносного шляху"

#: src/remove.c:273
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: спуститься у захищений від запису каталог %s? "

#: src/remove.c:274
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: спуститься у каталог %s? "

#. TRANSLATORS: In the next two strings the second %s is
#. replaced by the type of the file.  To avoid grammatical
#. problems, it may be more convenient to translate these
#. strings instead as: "%1$s: %3$s is write-protected and
#. is of type '%2$s' -- remove it? ".
#: src/remove.c:291
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: вилучити захищений від запису %s %s? "

#: src/remove.c:292
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: вилучити %s %s? "

#: src/remove.c:375
#, c-format
msgid "removed directory %s\n"
msgstr "вилучено каталог %s\n"

#: src/remove.c:447
#, c-format
msgid "refusing to remove %s or %s directory: skipping %s"
msgstr "відмовлено у вилученні каталогу %s або %s: пропускаємо %s"

#: src/remove.c:476
#, c-format
msgid "failed to stat %s: skipping %s"
msgstr "помилка отримання атрибутів %s: пропускаємо %s"

#: src/remove.c:489 src/remove.c:539
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "припущено %s, оскільки він розташований на іншому пристрої"

#: src/remove.c:491
#, c-format
msgid "and --preserve-root=all is in effect"
msgstr "і використовується --preserve-root=all"

#: src/remove.c:559
#, c-format
msgid "traversal failed: %s"
msgstr "помилка під час обходу: %s"

#: src/remove.c:565
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"неочікувана помилка: fts_info=%d: %s\n"
"повідомте %s"

#: src/rm.c:117
#, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr "Спробуйте «%s ./%s», щоб вилучити файл %s.\n"

#: src/rm.c:134
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"Вилучення ФАЙЛІВ (символічних посилань).\n"
"\n"
"  -f, --force           ігнорувати файли і аргументи, яких не існує, ніколи "
"не питати\n"
"  -i                    питати перед кожним вилученням\n"

#: src/rm.c:140
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively; less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i); without WHEN, prompt always\n"
msgstr ""
"  -I                    питати перед вилученням більш ніж трьох файлів або\n"
"                          при рекурсивному вилученні.  Менш набридливий ніж\n"
"                          -i, хоча забезпечує захист від більшості помилок\n"
"      --interactive[=КОЛИ]  питати КОЛИ: never, once (-I), \n"
"                          always (-i).  Без значення КОЛИ — питати завжди\n"

#: src/rm.c:147
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system  при вилученні ієрархії рекурсивно, пропускати\n"
"                          каталоги, що лежать на інших файлових системах,\n"
"                          ніж вказані аргументами командного рядку\n"

#: src/rm.c:152
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root[=all]  do not remove '/' (default);\n"
"                              with 'all', reject any command line argument\n"
"                              on a separate device from its parent\n"
msgstr ""
"      --no-preserve-root    не обробляти / особливим чином\n"
"      --preserve-root[=all] не вилучати / (типова поведінка);\n"
"                              з «all», відкидати усі аргументи командного "
"рядка\n"
"                              на окремому пристрої з його батьківського "
"запису\n"

#: src/rm.c:158
msgid ""
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"  -r, -R, --recursive   рекурсивно вилучати каталоги та їх вміст\n"
"  -d, --dir             вилучати порожні каталоги\n"
"  -v, --verbose         пояснювати дії, що виконуються\n"

#: src/rm.c:165
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"Зазвичай rm не вилучає каталоги.  Використовуйте ключ --recursive (-r\n"
"або -R), щоб вилучити всі перелічені каталоги разом з їхнім\n"
"змістом.\n"

#: src/rm.c:170
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"Для вилучення файла, що починається з «-» (приклад: «-foo»),\n"
"використовуйте одну з наступних команд:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"

#: src/rm.c:179
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"Зауважте, що при використанні rm для вилучення файла його вміст\n"
"зазвичай можна відновити. Використовуйте shred, якщо потрібна більша\n"
"впевненість у неможливості відновлення вмісту.\n"

#: src/rm.c:297
msgid "you may not abbreviate the --no-preserve-root option"
msgstr "не можна скорочувати параметр --no-preserve-root"

#: src/rm.c:309
#, c-format
msgid "unrecognized --preserve-root argument: %s"
msgstr "невідомий аргумент --preserve-root: %s"

#: src/rm.c:359
#, c-format
msgid "%s: remove %<PRIuMAX> argument recursively? "
msgid_plural "%s: remove %<PRIuMAX> arguments recursively? "
msgstr[0] "%s: вилучити %<PRIuMAX> аргумент рекурсивно? "
msgstr[1] "%s: вилучити %<PRIuMAX> аргументи рекурсивно? "
msgstr[2] "%s: вилучити %<PRIuMAX> аргументів рекурсивно? "

#: src/rm.c:362
#, c-format
msgid "%s: remove %<PRIuMAX> argument? "
msgid_plural "%s: remove %<PRIuMAX> arguments? "
msgstr[0] "%s: вилучити %<PRIuMAX> аргумент? "
msgstr[1] "%s: вилучити %<PRIuMAX> аргументи? "
msgstr[2] "%s: вилучити %<PRIuMAX> аргументів? "

#: src/rmdir.c:133 src/rmdir.c:233
#, c-format
msgid "removing directory, %s"
msgstr "вилучення каталогу, %s"

#: src/rmdir.c:148
#, c-format
msgid "failed to remove directory %s"
msgstr "помилка при вилученні каталогу %s"

#: src/rmdir.c:165
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"Вилучає КАТАЛОГИ, якщо вони порожні.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ігнорувати всі помилки, коли каталог не порожній\n"

#: src/rmdir.c:172
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' "
"is\n"
"                    similar to 'rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   вилучити КАТАЛОГ і підлеглі каталоги. Наприклад, «rmdir -p "
"a/b/c»\n"
"                  робить те ж саме, що й «rmdir a/b/c a/b a».\n"
"  -v, --verbose   виводити повідомлення для кожного обробленого каталогу\n"

#: src/rmdir.c:243
#, c-format
msgid "failed to remove %s"
msgstr "не вдалося вилучити %s"

#: src/runcon.c:78
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"Використання: %s КОНТЕКСТ КОМАНДА [аргументи]\n"
"  або:  %s [ -c ] [-u КОРИСТУВАЧ] [-r РОЛЬ] [-t ТИП] [-l ДІАПАЗОН] КОМАНДА "
"[аргументи]\n"

#: src/runcon.c:82
msgid ""
"Run a program in a different SELinux security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""
"Запустити програму з іншим контекстом захисту SELinux.\n"
"якщо не вказано ні КОНТЕКСТ, ані КОМАНДА, виводиться поточний контекст "
"безпеки.\n"

#: src/runcon.c:89
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""
"  КОНТЕКСТ              Повний контекст безпеки\n"
"  -c, --compute         обчислити процес переходу контексту перед зміною\n"
"  -t, --type=ТИП        тип (для тієї ж ролі, що й у батьківському)\n"
"  -u, --user=КОРИСТУВАЧ користувач\n"
"  -r, --role=РОЛЬ       роль\n"
"  -l, --range=ДІАПАЗОН  діапазон рівня\n"
"\n"

#: src/runcon.c:139
msgid "multiple roles"
msgstr "множинні ролей"

#: src/runcon.c:144
msgid "multiple types"
msgstr "множинні типи"

#: src/runcon.c:149
msgid "multiple users"
msgstr "множинні користувачі"

#: src/runcon.c:154
msgid "multiple levelranges"
msgstr "множинні діапазони"

#: src/runcon.c:172 src/runcon.c:208
msgid "failed to get current context"
msgstr "помилка при отриманні поточного контексту"

#: src/runcon.c:182
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "слід вказати -c, -t, -u, -l, -r, або контекст"

#: src/runcon.c:190
#, c-format
msgid "no command specified"
msgstr "не вказано команду"

#: src/runcon.c:195
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "%s можна використовувати лише у середовищі з підтримкою SELinux у ядрі"

#: src/runcon.c:222
msgid "failed to compute a new context"
msgstr "помилка при обчисленні нового контексту"

#: src/runcon.c:236
#, c-format
msgid "failed to set new user: %s"
msgstr "помилка при встановленні нового користувача: %s"

#: src/runcon.c:239
#, c-format
msgid "failed to set new type: %s"
msgstr "помилка при встановленні нового типу: %s"

#: src/runcon.c:242
#, c-format
msgid "failed to set new range: %s"
msgstr "помилка при встановленні нового діапазону: %s"

#: src/runcon.c:245
#, c-format
msgid "failed to set new role: %s"
msgstr "помилка при встановленні нової ролі: %s"

#: src/runcon.c:254
#, c-format
msgid "unable to set security context %s"
msgstr "не вдалося встановити контекст безпеки %s"

#: src/seq.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"Використання: %s [КЛЮЧ]... ОСТАННЄ\n"
"       або:    %s [КЛЮЧ]... ПЕРШЕ ОСТАННЄ\n"
"       або:    %s [КЛЮЧ]... ПЕРШЕ ПРИРІСТ ОСТАННЄ\n"

#: src/seq.c:85
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr "Виводить числа від ПЕРШОГО до ОСТАННЬОГО з кроком ПРИРІСТ.\n"

#: src/seq.c:91
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"  -f, --format ФОРМАТ      використовувати ФОРМАТ у стилі printf\n"
"  -s, --separator РЯДОК    використовувати РЯДОК як розділювач (типово \\n)\n"
"  -w, --equal-width        вирівнювати за шириною з додаванням початкових "
"нулів\n"

#: src/seq.c:98
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"
msgstr ""
"\n"
"Якщо не вказані ПЕРШЕ або ПРИРІСТ, типово використовується 1. Тобто\n"
"ПРИРІСТ типово приймається за 1, навіть якщо ОСТАННІЙ менше\n"
"ПЕРШОГО. Послідовність обривається, коли сума поточного числа і\n"
"ПРИРОСТУ перевищує число ОСТАННІЙ.\n"
"ПЕРШИЙ, ОСТАННІЙ та ПРИРІСТ вважаються числами з рухомою\n"
"комою. ПРИРІСТ має бути додатним, якщо ПЕРШИЙ менше\n"
"ОСТАННЬОГО, та від'ємним у іншому випадку.\n"
"ПРИРІСТ має бути ненульовим; усі значення ПЕРШИЙ, ПРИРІСТ, ОСТАННІЙ\n"
"мають бути обчислюваними (не NaN).\n"

#: src/seq.c:109
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"ФОРМАТ повинен бути придатний для друку одного аргументу типу 'double';\n"
"типове значення %.PRECf якщо ПЕРШЕ, ПРИРІСТ, та ОСТАННЄ є числами \n"
"з рухомою комою з максимальною точністю ТОЧН, та %g у іншому випадку.\n"

#: src/seq.c:155
#, c-format
msgid "invalid floating point argument: %s"
msgstr "неправильний аргумент з рухомою комою: %s"

#: src/seq.c:161
#, c-format
msgid "invalid %s argument: %s"
msgstr "некоректний аргумент %s: %s"

#: src/seq.c:268
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "формат містить %s невідому директиву %%%c"

#: src/seq.c:648
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr "при виводі рядків однакової ширини формат можна не вказувати"

#: src/seq.c:693
#, c-format
msgid "invalid Zero increment value: %s"
msgstr "некоректне нульове значення кроку збільшення: %s"

#: src/set-fields.c:167
msgid "invalid byte or character range"
msgstr "некоректний діапазон байтів або символів"

#: src/set-fields.c:168
msgid "invalid field range"
msgstr "некоректний діапазон полів"

#: src/set-fields.c:175 src/set-fields.c:221
msgid "byte/character positions are numbered from 1"
msgstr "позиції байтів та символів нумеруються з 1"

#: src/set-fields.c:176 src/set-fields.c:222
msgid "fields are numbered from 1"
msgstr "поля нумеруються з 1"

#: src/set-fields.c:196
msgid "invalid range with no endpoint: -"
msgstr "неправильний діапазон без кінцевого значення: -"

#: src/set-fields.c:210
msgid "invalid decreasing range"
msgstr "неприпустимий спадаючий діапазон"

#: src/set-fields.c:259
#, c-format
msgid "byte/character offset %s is too large"
msgstr "байтовий зсув або зсув символів %s надто великий"

#: src/set-fields.c:260
#, c-format
msgid "field number %s is too large"
msgstr "номер поля %s надто великий"

#: src/set-fields.c:271
#, c-format
msgid "invalid byte/character position %s"
msgstr "некоректна позиція байта або символу %s"

#: src/set-fields.c:272
#, c-format
msgid "invalid field value %s"
msgstr "некоректне значення поля, %s"

#: src/set-fields.c:280
msgid "missing list of byte/character positions"
msgstr "пропущено список позицій байтів або символів"

#: src/set-fields.c:281
msgid "missing list of fields"
msgstr "відсутній список полів"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:171
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr ""
"Перезаписує декілька раз вказані файли, щоб ускладнити відновлення\n"
"навіть з використанням дуже коштовного обладнання.\n"

#: src/shred.c:175
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ вказано як -, розрізати стандартне виведення.\n"

#: src/shred.c:182
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force    змінювати права, дозволяючи запис, якщо потрібно\n"
"  -n, --iterations=N  переписати N разів замість (%d) типово\n"
"      --random-source=ФАЙЛ  брати випадкові дані з ФАЙЛа\n"
"  -s, --size=N   очистити N байт (можливі суфікси, подібні до K, M, G)\n"

#: src/shred.c:188
msgid ""
"  -u             deallocate and remove file after overwriting\n"
"      --remove[=HOW]  like -u but give control on HOW to delete;  See below\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u             скасувати розміщення та вилучити файл після перезапису\n"
"      --remove[=СПОСІБ]  подібне до -u, але надає змогу вказати спосіб "
"вилучення. Див. нижче.\n"
"  -v, --verbose  виводити поступ\n"
"  -x, --exact    не округляти розміри файлів до наступного цілого блоку;\n"
"                   типово для незвичних файлів\n"
"  -z, --zero     перезаписати у конці нулями, щоб сховати змішування\n"

#: src/shred.c:198
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.\n"
"The optional HOW parameter indicates how to remove a directory entry:\n"
"'unlink' => use a standard unlink call.\n"
"'wipe' => also first obfuscate bytes in the name.\n"
"'wipesync' => also sync each obfuscated byte to disk.\n"
"The default mode is 'wipesync', but note it can be expensive.\n"
"\n"
msgstr ""
"\n"
"Вилучає ФАЙЛИ, якщо вказано --remove (-u).  Типово файли не\n"
"вилучаються, оскільки часто обробляються файли-пристрої, подібні до\n"
"/dev/hda, а такі файли не треба вилучати.\n"
"За допомогою необов'язкового параметра СПОСІБ можна визначити спосіб "
"вилучення\n"
"запису каталогу:\n"
"'unlink' => використати стандартний виклик unlink.\n"
"'wipe' => також виконати змішування байтів у назві.\n"
"'wipesync' => також синхронізувати усі змішані байти з диском.\n"
"Типовим є режим 'wipesync', але варто пам'ятати, що цей режим може бути "
"доволі\n"
"вимогливим до ресурсів комп'ютера.\n"
"\n"

#: src/shred.c:210
msgid ""
"CAUTION: shred assumes the file system and hardware overwrite data in "
"place.\n"
"Although this is common, many platforms operate otherwise.  Also, backups\n"
"and mirrors may contain unremovable copies that will let a shredded file\n"
"be recovered later.  See the GNU coreutils manual for details.\n"
msgstr ""
"ПОПЕРЕДЖЕННЯ: у shred передбачено перезапис даних файлової системи та "
"апаратної\n"
"частини на місці.\n"
"Хоча відповідні конфігурації є типовими, на багатьох платформах роботу\n"
"побудовано у інший спосіб. Крім того, у резервних копіях та на дзеркалах\n"
"можуть міститися непридатні до вилучення копії, з яких витертий файл можна "
"буде\n"
"відновити. Докладніший опис можна знайти у підручнику з coreutils GNU.\n"

#: src/shred.c:310
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s: операція fdatasync завершилась невдало"

#: src/shred.c:321
#, c-format
msgid "%s: fsync failed"
msgstr "%s: операція fsync завершилась невдало"

#: src/shred.c:438
#, c-format
msgid "%s: cannot rewind"
msgstr "%s: не вдалося відкотитись"

#: src/shred.c:458
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s: прохід %lu/%lu (%s)..."

#: src/shred.c:509
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: помилка записи за зсувом %s"

#: src/shred.c:530
#, c-format
msgid "%s: lseek failed"
msgstr "%s: операція lseek завершилась помилкою"

#: src/shred.c:542
#, c-format
msgid "%s: file too large"
msgstr "%s: файл надто великий"

#: src/shred.c:566
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: прохід %lu/%lu (%s)...%s"

#: src/shred.c:582
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: прохід %lu/%lu (%s)...%s/%s %d%%"

#: src/shred.c:840
#, c-format
msgid "%s: fstat failed"
msgstr "%s: операція fstat завершилась помилкою"

#: src/shred.c:851
#, c-format
msgid "%s: invalid file type"
msgstr "%s: неправильний тип файла"

#: src/shred.c:856
#, c-format
msgid "%s: file has negative size"
msgstr "%s: файл має від'ємний розмір"

#: src/shred.c:952 src/sort.c:972 src/split.c:475
#, c-format
msgid "%s: error truncating"
msgstr "%s: помилка при скороченні"

#: src/shred.c:971
#, c-format
msgid "%s: fcntl failed"
msgstr "%s: операція fcntl завершилась помилкою"

#: src/shred.c:976
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: не вдалося нарізати файловий дескриптор з лише з правом додавання"

#: src/shred.c:1059
#, c-format
msgid "%s: removing"
msgstr "%s:  вилучення"

#: src/shred.c:1084
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: перейменований на %s"

#: src/shred.c:1093
#, c-format
msgid "%s: failed to remove"
msgstr "%s: не вдалося вилучити"

#: src/shred.c:1097
#, c-format
msgid "%s: removed"
msgstr "%s: вилучено"

#: src/shred.c:1104 src/shred.c:1147
#, c-format
msgid "%s: failed to close"
msgstr "%s: не вдалося закрити"

#: src/shred.c:1140
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s: не вдалося відкрити для читання"

#: src/shred.c:1203
msgid "invalid number of passes"
msgstr "некоректна кількість проходів"

#: src/shred.c:1208 src/shuf.c:462 src/sort.c:4508
msgid "multiple random sources specified"
msgstr "вказано декілька форматів виводу"

#: src/shred.c:1222
msgid "invalid file size"
msgstr "некоректний розмір файла"

#: src/shuf.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"
"  або:  %s -e [КЛЮЧ]... [АРГУМЕНТ]...\n"
"  або:  %s -i НИЖ-ВИЩ [КЛЮЧ]...\n"

#: src/shuf.c:68
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr "Виводить випадково переставлені вхідні рядки на стандартний вивід.\n"

#: src/shuf.c:75
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -r, --repeat              output lines can be repeated\n"
msgstr ""
"  -e, --echo                вважати кожен АРГУМЕНТ вхідним рядком\n"
"  -i, --input-range=НИЖ-ВИЩ вважати числа від НИЖ до ВИЩ вхідним рядком\n"
"  -n, --head-lines=РЯДКІВ   виводити принаймні кількість РЯДКІВ\n"
"  -o, --output=ФАЙЛ         вивести результат у ФАЙЛ, а не стандартний "
"вивід\n"
"      --random-source=ФАЙЛ  випадкові дані з ФАЙЛа\n"
"  -r, --repeat              рядки у виведених даних можуть повторюватися\n"

#: src/shuf.c:226
msgid "too many input lines"
msgstr "занадто багато рядків вхідних даних"

#: src/shuf.c:418
msgid "multiple -i options specified"
msgstr "задано декілька ключів -i"

#: src/shuf.c:425 src/shuf.c:431 src/shuf.c:436
msgid "invalid input range"
msgstr "некоректний діапазон вхідних даних"

#: src/shuf.c:449
#, c-format
msgid "invalid line count: %s"
msgstr "некоректна кількість рядків: %s"

#: src/shuf.c:456 src/sort.c:4502
msgid "multiple output files specified"
msgstr "задано декілька файлів для виводу"

#: src/shuf.c:486
#, c-format
msgid "cannot combine -e and -i options"
msgstr "не можна одночасно використовувати ключі -e та -i"

#: src/shuf.c:575
msgid "no lines to repeat"
msgstr "немає рядків для повторення"

#: src/sleep.c:44
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  NUMBER need not be an\n"
"integer.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"Використання: %s ЧИСЛО[СУФІКС]\n"
"         або: %s ПАРАМЕТР\n"
"Призупиняє виконання на вказане ЧИСЛО секунд.  СУФІКС може\n"
"приймати значення 's', що означає секунди (типове значення),\n"
"'m' -- хвилини, 'h' -- години та 'd' -- дні. ЧИСЛО може бути\n"
"не цілим. Якщо вказано декілька аргументів, буде додано паузу,\n"
"тривалість якої буде сумою вказаних значень.\n"
"\n"

#: src/sleep.c:132 src/timeout.c:332
#, c-format
msgid "invalid time interval %s"
msgstr "неправильний інтервал часу %s"

#: src/sleep.c:143 src/tail.c:1311
msgid "cannot read realtime clock"
msgstr "не вдалося прочитати значення таймеру реального часу"

#: src/sort.c:420
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr "Вивести сортоване сполучення усіх ФАЙЛ(ів) на стандартний вивід.\n"

#: src/sort.c:427
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"Ключі, що вказують порядок:\n"
"\n"

#: src/sort.c:431
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks ігнорувати початкові пробіли\n"
"  -d, --dictionary-order      розглядати лише пропуски, літери та цифри\n"
"  -f, --ignore-case           ігнорувати регістр літер\n"

#: src/sort.c:437
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""
"  -g, --general-numeric-sort  порівнювати числа у загальному форматі\n"
"  -i, --ignore-nonprinting    розглядати лише друковані знаки\n"
"  -M, --month-sort            порівнювати (невідомо) < 'JAN' < ... < 'DEC'\n"

#: src/sort.c:442
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr ""
"  -h, --human-numeric-sort    порівнювати значення у зручному для читання "
"форматі (приклад: 2к 1Г)\n"

#: src/sort.c:445
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           shuffle, but group identical keys.  See "
"shuf(1)\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort          порівнювати числові значення рядків\n"
"  -R, --random-sort           перемішати, але згрупувати ідентичні ключі. "
"Див.shuf(1)\n"
"      --random-source=ФАЙЛ    випадкові дані з ФАЙЛА\n"
"  -r, --reverse               зворотний порядок порівняння\n"

#: src/sort.c:451
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=СЛОВО            сортувати відповідно до СЛОВО:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          сортувати за номером версії\n"
"\n"

#: src/sort.c:459
msgid ""
"Other options:\n"
"\n"
msgstr ""
"Інші параметри:\n"
"\n"

#: src/sort.c:463
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=NMERGE   об'єднувати не більше NMERGE джерел введення "
"одразу;\n"
"                            для решти використовувати тимчасові файли\n"

#: src/sort.c:467
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first перевіряти, чи сортовані вхідні\n"
"                   файли; не сортувати\n"
"  -C, --check=quiet, --check=silent як -c, але не повідомляти про перший\n"
"                   помилковий рядок\n"
"      --compress-program=ПРОГ  стискати тимчасові файли командою ПРОГ;\n"
"                   розпаковувати командою ПРОГ -d\n"

#: src/sort.c:474
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug               коментувати частину рядка, використану для\n"
"                              впорядковування, попереджати щодо сумнівного\n"
"                              використання до stderr\n"
"      --files0-from=Ф       читати вхідні дані з файлів, вказаних за "
"допомогою\n"
"                            назв, відокремлених нуль-символом, у файлі Ф;\n"
"                            Якщо Ф — -, читати назви зі стандартного "
"джерела\n"
"                            вхідних даних\n"

#: src/sort.c:481
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=ВИЗНКЛ          впорядкувати за ключем, ВИЗНКЛ визначає місце і "
"тип\n"
"  -m, --merge               об'єднати вже впорядковані файли; не "
"впорядковувати\n"

#: src/sort.c:485
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=ФАЙЛ  виводити у ФАЙЛ, а не на стандартний вивід\n"
"  -s, --stable     стабілізувати сортування, виключивши перевірку на "
"рівність\n"
"  -S, --buffer-size=РОЗМІР\n"
"                   використовувати в пам'яті буфер вказаного РОЗМІРУ\n"

#: src/sort.c:491
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=РОЗДІЛЮВАЧ\n"
"                   використовувати при пошуку ключових полів РОЗДІЛЮВАЧ, а "
"не\n"
"                   перехід від непробільних знаків до пробільних\n"
"  -T, --temporary-directory=КАТАЛОГ\n"
"                   використовувати для тимчасових файлів КАТАЛОГ, а не "
"$TMPDIR\n"
"                   або %s; декілька таких ключів задають декілька каталогів\n"
"  -u, --unique     з -c, суворо перевіряти порядок;\n"
"                     без -c, виводити лише перше з кількох рівних\n"

#: src/sort.c:505
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"ВИЗНКЛ вказується як П[.З][ПАРАМ][П[.З][ПАРАМ]] для початкової і\n"
"кінцевої позицій, де П -- номер поля, а З -- позиція\n"
"символу у цьому поле, відлік обох ведеться з 1, типовою кінцевою\n"
"позицією є позиція кінця рядка. Якщо не використано ні -t, ні -b,\n"
"відлік символів у полі вестиметься з початку попереднього полю пробілу.\n"
"ПАРАМ визначається одним або декількома параметрами впорядковування з\n"
"набору [bdfgiMhnRrV]. ПАРАМ перевизначає загальні параметри впорядковування\n"
"для відповідного ключа. Якщо поле ключа не вказано, як ключ буде\n"
"використано увесь рядок. Для діагностування помилкового використання ключів\n"
"скористайтеся параметром --debug.\n"
"\n"
"Після РОЗМІРУ можна вказувати такі суфікси-мультиплікатори:\n"

#: src/sort.c:518
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% пам'яті, b 1, k 1024 (типово), та так далі для M, G, T, P, E, Z, Y.\n"
"\n"
"*** ПОПЕРЕДЖЕННЯ ***\n"
"Встановлена в середовищі локаль впливає на порядок сортування.\n"
"Щоб отримати традиційний порядок, що використовує системні значення байт,\n"
"встановіть LC_ALL=C.\n"

#: src/sort.c:716
#, c-format
msgid "waiting for %s [-d]"
msgstr "очікування %s [-d]"

#: src/sort.c:721
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] аварійно завершений"

#: src/sort.c:876
#, c-format
msgid "cannot create temporary file in %s"
msgstr "не вдалося створити тимчасовий файл у %s"

#: src/sort.c:991 src/sort.c:2100 src/sort.c:3137 src/sort.c:3780
#: src/sort.c:3871 src/sort.c:3874
msgid "open failed"
msgstr "операція відкриття завершилась помилкою"

#: src/sort.c:1011
msgid "fflush failed"
msgstr "операція fflush завершилась помилкою"

#: src/sort.c:1016 src/sort.c:2103 src/sort.c:4778
msgid "close failed"
msgstr "помилка закриття"

#: src/sort.c:1155
msgid "couldn't create temporary file"
msgstr "не вдалося створити тимчасовий файл"

#: src/sort.c:1194
#, c-format
msgid "couldn't create process for %s -d"
msgstr "неможливо створити процес для %s -d"

#: src/sort.c:1267
#, c-format
msgid "warning: cannot remove: %s"
msgstr "попередження, не вдалося вилучити: %s"

#: src/sort.c:1353
#, c-format
msgid "invalid --%s argument %s"
msgstr "некоректний аргумент --%s %s"

#: src/sort.c:1356
#, c-format
msgid "minimum --%s argument is %s"
msgstr "мінімальним аргументом --%s є %s"

#: src/sort.c:1371
#, c-format
msgid "--%s argument %s too large"
msgstr "аргумент --%s %s є занадто великим"

#: src/sort.c:1374
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "максимум --%s аргумент з поточним rlimit що дорівнює %s"

#: src/sort.c:1456
msgid "number in parallel must be nonzero"
msgstr "кількість паралельних впорядкувань має бути ненульовою"

#: src/sort.c:1539
msgid "stat failed"
msgstr "операція stat завершилась помилкою"

#: src/sort.c:1801
msgid "read failed"
msgstr "помилка читання"

#: src/sort.c:2118
#, c-format
msgid "string transformation failed"
msgstr "помилка перетворення рядків"

#: src/sort.c:2121
#, c-format
msgid "the untransformed string was %s"
msgstr "Рядок до перетворення %s"

#: src/sort.c:2284
#, c-format
msgid "^ no match for key\n"
msgstr "^ не знайдено збігів з ключем\n"

#: src/sort.c:2456
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr "використано застарілий ключ «%s»; вам варто скористатися ключем «%s»"

#: src/sort.c:2463
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "ключ %lu має нульову ширину, його буде проігноровано"

#: src/sort.c:2472
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr "початкові пробіли у ключі %lu буде враховано; варто також вказати «b»"

#: src/sort.c:2485
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "ключ %lu є числовим, він охоплює декілька полів"

#: src/sort.c:2517
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] "параметр «-%s» проігноровано"
msgstr[1] "параметри «-%s» проігноровано"
msgstr[2] "параметри «-%s» проігноровано"

#: src/sort.c:2523
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr "параметр «-r» застосовується лише у разі, якщо збігів не виявлено"

#: src/sort.c:2797 src/sort.c:2806
msgid "write failed"
msgstr "запис завершився помилкою"

#: src/sort.c:2849
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: неправильний порядок: "

#: src/sort.c:2852
msgid "standard error"
msgstr "стандартна помилка"

#: src/sort.c:3764
msgid "cannot read"
msgstr "не вдалося прочитати"

#: src/sort.c:4043
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s: неправильна специфікація поля %s"

#: src/sort.c:4053
#, c-format
msgid "options '-%s' are incompatible"
msgstr "несумісні параметри '-%s'"

#: src/sort.c:4103
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s: неправильний лічильник на початку %s"

#: src/sort.c:4362
msgid "invalid number after '-'"
msgstr "неправильне число після '-'"

#: src/sort.c:4369 src/sort.c:4455 src/sort.c:4483
msgid "invalid number after '.'"
msgstr "неправильне число після '.'"

#: src/sort.c:4382 src/sort.c:4488
msgid "stray character in field spec"
msgstr "зайвий знак у специфікації поля"

#: src/sort.c:4429
msgid "multiple compress programs specified"
msgstr "вказано декілька програм стискання"

#: src/sort.c:4446
msgid "invalid number at field start"
msgstr "неправильне число на початку поля"

#: src/sort.c:4450 src/sort.c:4478
msgid "field number is zero"
msgstr "нульовий номер поля"

#: src/sort.c:4459
msgid "character offset is zero"
msgstr "нульовий знаковий зсув"

#: src/sort.c:4474
msgid "invalid number after ','"
msgstr "неправильне число після ','"

#: src/sort.c:4524
msgid "empty tab"
msgstr "порожня табуляція"

#: src/sort.c:4607 src/wc.c:784
#, c-format
msgid "cannot read file names from %s"
msgstr "не вдалося прочитати назви файлів з %s"

#: src/sort.c:4629
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s:%lu: некоректна нульова довжина назви файла"

#: src/sort.c:4635
#, c-format
msgid "no input from %s"
msgstr "немає вхідних даних з %s"

#: src/sort.c:4688
#, c-format
msgid "text ordering performed using %s sorting rules"
msgstr "для упорядковування тексту використано правила впорядковування %s"

#: src/sort.c:4692
msgid "text ordering performed using simple byte comparison"
msgstr "для упорядковування тексту використано просте порівняння байтів"

#: src/sort.c:4724
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "додатковий операнд %s не припустимий з -%c"

#: src/split.c:209
#, c-format
msgid "the suffix length needs to be at least %<PRIuMAX>"
msgstr "довжина суфікса не повинна бути меншою за %<PRIuMAX>"

#: src/split.c:226
#, c-format
msgid "Usage: %s [OPTION]... [FILE [PREFIX]]\n"
msgstr "Користування: %s [ПАРАМЕТР]... [ФАЙЛ [ПРЕФІКС]]\n"

#: src/split.c:230
msgid ""
"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n"
"default size is 1000 lines, and default PREFIX is 'x'.\n"
msgstr ""
"Вивести шматки ФАЙЛа до ПРЕФІКСaa, ПРЕФІКСab, ...;\n"
"Типовий розмір шматка — 1000 рядків, а типовий ПРЕФІКС — «x».\n"

#: src/split.c:238
#, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n"
"  -d                      use numeric suffixes starting at 0, not "
"alphabetic\n"
"      --numeric-suffixes[=FROM]  same as -d, but allow setting the start "
"value\n"
"  -x                      use hex suffixes starting at 0, not alphabetic\n"
"      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines/records per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files; see explanation "
"below\n"
"  -t, --separator=SEP     use SEP instead of newline as the record "
"separator;\n"
"                            '\\0' (zero) specifies the NUL character\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""
"  -a, --suffix-length=N   використовувати суфікси довжини N (типово %d)\n"
"      --additional-suffix=СУФІКС  дописувати СУФІКС до назв файлів\n"
"  -b, --bytes=ЧИСЛО       записувати у кожен файл виводу вказане ЧИСЛО "
"байтів\n"
"  -C, --line-bytes=ЧИСЛО  записувати не більше вказаного ЧИСЛА байт з рядка\n"
"  -d                      використовувати числові суфікси, починаючи з 0, а "
"не літерні\n"
"      --numeric-suffixes[=ПОЧАТОК] те саме, що і -d, але із можливістю "
"вказати\n"
"                           початкове значення\n"
"  -x                      використовувати шістнадцяткові суфікси, починаючи "
"з 0, а не літерні\n"
"      --hex-suffixes[=ПОЧАТОК]  те саме, що і -x, але із можливістю вказати\n"
"                           початкове значення\n"
"  -e, --elide-empty-files  не створювати порожніх файлів результатів, якщо "
"вказано -n\n"
"      --filter=КОМАНДА    записувати КОМАНДУ до оболонки; назвою файла є "
"$FILE\n"
"  -l, --lines=ЧИСЛО       записувати у кожен файл виводу вказане ЧИСЛО "
"рядків\n"
"  -n, --number=КІЛЬКІСТЬ  створити КІЛЬКІСТЬ фрагментів виведення. Див. "
"нижче.\n"
"  -t, --separator=РОЗД    використовувати роздільник РОЗД замість розриву\n"
"                            рядка для відокремлення записів;\n"
"                            '\\0' (нуль) визначає символ NUL\n"
"  -u, --unbuffered        копіювати вхідні дані безпосередньо до виведення з "
"«-n r/...»\n"

#: src/split.c:256
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr ""
"      --verbose           виводити діагностичні повідомлення\n"
"                          перед відкриттям кожного файла виводу\n"

#: src/split.c:263
msgid ""
"\n"
"CHUNKS may be:\n"
"  N       split into N files based on size of input\n"
"  K/N     output Kth of N to stdout\n"
"  l/N     split into N files without splitting lines/records\n"
"  l/K/N   output Kth of N to stdout without splitting lines/records\n"
"  r/N     like 'l' but use round robin distribution\n"
"  r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"ФРАГМЕНТИ можна задавати у форматі:\n"
"N       розділити на N файлів на основі розміру вхідних даних\n"
"K/N     вивести K-ий з N до stdout\n"
"l/N     розділити на N файлів без поділу на рядки або записи\n"
"l/K/N   вивести K-ий з N до stdout без поділу на рядки або записи\n"
"r/N     подібно до «l», але з використанням циклічного перебирання\n"
"r/K/N   те саме, але вивести лише K-ий з N до stdout\n"

#: src/split.c:450
msgid "output file suffixes exhausted"
msgstr "вичерпано суфікси для вихідних файлів"

#: src/split.c:462
#, c-format
msgid "creating file %s\n"
msgstr "створюється файл %s\n"

#: src/split.c:471
#, c-format
msgid "%s would overwrite input; aborting"
msgstr "%s перепише вхідні дані; перериваємо роботу"

#: src/split.c:488
msgid "failed to set FILE environment variable"
msgstr "не вдалося встановити змінну середовища FILE"

#: src/split.c:490
#, c-format
msgid "executing with FILE=%s\n"
msgstr "виконання з FILE=%s\n"

#: src/split.c:492
msgid "failed to create pipe"
msgstr "не вдалося створити канал"

#: src/split.c:506
msgid "closing prior pipe"
msgstr "закриття попереднього каналу"

#: src/split.c:508
msgid "closing output pipe"
msgstr "закриття каналу виведення"

#: src/split.c:512
msgid "moving input pipe"
msgstr "пересування каналу введення"

#: src/split.c:514
msgid "closing input pipe"
msgstr "закриття каналу введення"

#: src/split.c:519
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "не вдалося виконати команду: «%s -c %s»"

#: src/split.c:525
msgid "failed to close input pipe"
msgstr "не вдалося закрити канал вхідних даних"

#: src/split.c:561
msgid "waiting for child process"
msgstr "очікування на дочірній процес"

#: src/split.c:571
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr "при FILE=%s, сигнал %s від команди: %s"

#: src/split.c:579
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr "при FILE=%s, код виходу %d від команди: %s"

#: src/split.c:586
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "невідомий стан від команди (0x%X)"

#: src/split.c:1274
#, c-format
msgid "cannot split in more than one way"
msgstr "не можна розбивати одразу кількома методами"

#: src/split.c:1286 src/split.c:1401 src/split.c:1602
msgid "invalid number of chunks"
msgstr "некоректна кількість фрагментів"

#: src/split.c:1291
msgid "invalid chunk number"
msgstr "некоректний номер фрагмента"

#: src/split.c:1338
msgid "invalid suffix length"
msgstr "некоректна довжина суфікса"

#: src/split.c:1412
msgid "empty record separator"
msgstr "порожній роздільник записів"

#: src/split.c:1423
#, c-format
msgid "multi-character separator %s"
msgstr "багатосимвольний роздільник %s"

#: src/split.c:1431
msgid "multiple separator characters specified"
msgstr "вказано декілька символів-роздільників"

#: src/split.c:1462
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "ключ кількості рядків -%s%c... надто великий"

#: src/split.c:1479
#, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr "%s: некоректне початкове значення у числовому суфіксі"

#: src/split.c:1480
#, c-format
msgid "%s: invalid start value for hexadecimal suffix"
msgstr "%s: некоректне початкове значення у шістнадцятковому суфіксі"

#: src/split.c:1504
msgid "invalid IO block size"
msgstr "некоректний розмір блоку введення-виведення"

#: src/split.c:1522
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr "--filter не обробляє фрагменти, видобуті до stdout"

#: src/split.c:1562
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr ""
"початкове значення числового суфікса є занадто великим для довжини суфікса"

#: src/split.c:1594
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s: не вдалося визначити розмір файла"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:197
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:989
#, c-format
msgid "failed to canonicalize %s"
msgstr "не вдалося перетворити у канонічну форму %s"

#: src/stat.c:1092
#, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "попередження: керівна послідовність '\\%c' не розпізнана"

#: src/stat.c:1153
#, c-format
msgid "%s: invalid directive"
msgstr "%s: неправильна директива"

#: src/stat.c:1200
#, c-format
msgid "warning: backslash at end of format"
msgstr "попередження: зворотна похила риска наприкінці формату"

#: src/stat.c:1231
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr ""
"використання %s для позначення стандартного введення не працює у режимі "
"файлової системи"

#: src/stat.c:1238
#, c-format
msgid "cannot read file system information for %s"
msgstr "не вдалося прочитати інформацію файлової системи для %s"

#: src/stat.c:1362 src/stat.c:1429
#, c-format
msgid "cannot stat standard input"
msgstr "не вдалося виконати stat для стандартного джерела вхідних даних"

#: src/stat.c:1364
#, c-format
msgid "cannot statx %s"
msgstr "не вдалося виконати statx для %s"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1608
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  Файл: «%n»\n"
"   Ід.: %-8i Довжина назви: %-7l Тип: %T\n"
"Розмір блоку: %-10s Базовий розмір блоку: %S\n"
"Блоки: загалом: %-10b вільних: %-10f доступних: %a\n"
"Inode: загалом: %-10c вільних: %d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1629
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  Файл: %N\n"
"  Розмір: %-10s\tБлоків: %-10b Блок в/в: %-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1639
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr "Пристрій: %Dh/%dd\tInode: %-10i  Посилання: %-5h Тип пристрою: %t,%T\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1647
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr "Пристрій: %Dh/%dd\tInode: %-10i  Посилання: %h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1656
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "Доступ: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1666
#, c-format
msgid "Context: %C\n"
msgstr "Контекст: %C\n"

#: src/stat.c:1674
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"Доступ: %x\n"
"Модиф.: %y\n"
" Зміна: %z\n"
"Створ.: %w\n"

#: src/stat.c:1692
msgid "Display file or file system status.\n"
msgstr "Показати файл або стан файлової системи.\n"

#: src/stat.c:1698
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"  -L, --dereference     слідувати за посиланням\n"
"  -f, --file-system     показати стан файлової системи, а не файла\n"

#: src/stat.c:1702
msgid ""
"      --cached=MODE     specify how to use cached attributes;\n"
"                          useful on remote file systems. See MODE below\n"
msgstr ""
"      --cached=РЕЖИМ    вказати, як використовувати кешовані атрибути;\n"
"                          корисно на віддалених файлових системах. Див. "
"РЕЖИМ нижче.\n"

#: src/stat.c:1706
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline;\n"
"                          if you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c  --format=ФОРМАТ   використовувати вказаний ФОРМАТ, а не типовий;\n"
"                          переводити рядок після кожного використання "
"ФОРМАТУ\n"
"      --printf=ФОРМАТ   як --format, але інтерпретувати керівні\n"
"                          послідовності і не переводити рядок наприкінці.\n"
"                          Якщо потрібно переведення рядка, вставте у ФОРМАТ "
"\\n.\n"
"  -t, --terse           виводити дані у компактній формі\n"

#: src/stat.c:1717
msgid ""
"\n"
"The --cached MODE argument can be; always, never, or default.\n"
"`always` will use cached attributes if available, while\n"
"`never` will try to synchronize with the latest attributes, and\n"
"`default` will leave it up to the underlying file system.\n"
msgstr ""
"\n"
"Аргументом РЕЖИМ параметра --cached може бути одне з таких значень:\n"
"always, never або default.\n"
"«always» -- використовувати кешовані атрибути, якщо такі доступні,\n"
"«never» -- намагатися синхронізуватися із найсвіжішими атрибутами,\n"
"«default» -- використовувати параметри базової файлової системи.\n"

#: src/stat.c:1724
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   permission bits in octal (note '#' and '0' printf flags)\n"
"  %A   permission bits and file type in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"Можливі форматні послідовності для файлів (без --file-system):\n"
"\n"
"  %a   біти доступу у вісімковій формі (з врахуванням прапорців printf # і "
"0)\n"
"  %A   біти доступу і тип файла у текстовій формі\n"
"  %b   кількість виділених блоків (дивіться %B)\n"
"  %B   розмір блоку, що повідомляється %b, у байтах\n"
"  %C   рядок з контекстом безпеки SELinux\n"

#: src/stat.c:1733
msgid ""
"  %d   device number in decimal\n"
"  %D   device number in hex\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""
"  %d   номер пристрою, десятковий\n"
"  %D   номер пристрою, шістнадцятковий\n"
"  %f   низькорівневий режим, шістнадцятковий\n"
"  %F   тип файла\n"
"  %g   ідентифікатор групи-власника\n"
"  %G   назва групи-власника\n"

#: src/stat.c:1741
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %t   major device type in hex, for character/block device special files\n"
"  %T   minor device type in hex, for character/block device special files\n"
msgstr ""
"  %h   кількість жорстких посилань\n"
"  %i   кількість inode\n"
"  %m   точка монтування\n"
"  %n   назва файла\n"
"  %N   екранована назва файла, символьні посилання розіменовуються\n"
"  %o   оптимальний розмір блоку введення-виведення\n"
"  %s   повний розмір, у байтах\n"
"  %t   основний тип пристрою, шістнадцятковий, для спеціальних файлів "
"символьних або блокових пристроїв\n"
"  %T   другорядний тип пристрою, шістнадцятковий, для спеціальних файлів "
"символьних або блокових пристроїв\n"

#: src/stat.c:1752
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last data modification, human-readable\n"
"  %Y   time of last data modification, seconds since Epoch\n"
"  %z   time of last status change, human-readable\n"
"  %Z   time of last status change, seconds since Epoch\n"
"\n"
msgstr ""
"  %u   ідентифікатор користувача-власника\n"
"  %U   ім'я користувача-власника\n"
"  %w   час створення файла у зручному для читання форматі; -, якщо "
"невідомий\n"
"  %W   час створення файла у секундах від початку Епохи; 0 якщо невідомий\n"
"  %x   час останньої доступу у зручному для читання форматі\n"
"  %X   час останньої доступу у секундах з початку Епохи\n"
"  %y   час останньої зміни у зручному для читання форматі\n"
"  %Y   час останньої зміни у секундах з початку Епохи\n"
"  %z   час останньої зміни у зручному для читання форматі\n"
"  %Z   час останньої зміни у секундах з початку Епохи\n"
"\n"

#: src/stat.c:1766
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""
"Можливі послідовності форматування для файлових систем:\n"
"\n"
"  %a   кількість вільних блоків, доступних для звичайного користувача\n"
"  %b   повна кількість блоків даних у файловій системі\n"
"  %c   повна кількість вузлів у файловій системі\n"
"  %d   кількість вільних файлових вузлів у файловій системі\n"
"  %f   кількість вільних блоків у файловій системі\n"

#: src/stat.c:1775
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""
"  %i   Ідентифікатор файлової системи, шістнадцятковий\n"
"  %l   Максимальна довжина назви файла\n"
"  %n   Назва файла\n"
"  %s   Розмір блоку (для швидшої передачі)\n"
"  %S   Фундаментальний розмір блоку (для обліку блоків)\n"
"  %t   Тип, шістнадцятковий\n"
"  %T   Тип у текстовій формі\n"

#: src/stat.c:1785
#, c-format
msgid ""
"\n"
"--terse is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"\n"
"--terse еквівалентний до такого значення ФОРМАТ:\n"
"    %s"

#: src/stat.c:1796
#, c-format
msgid ""
"--terse --file-system is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"--terse --file-system еквівалентне до такого значення ФОРМАТ:\n"
"    %s"

#: src/stdbuf.c:91
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "Використання: %s ПАРАМЕТР... КОМАНДА\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr ""
"Запускає КОМАНДУ зі зміненими діями з буферизації для стандартних потоків.\n"

#: src/stdbuf.c:98
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=РЕЖИМ  скоригувати буферизацію для потоку стандартного "
"введення\n"
"  -o, --output=РЕЖИМ скоригувати буферизацію для потоку стандартного "
"виведення\n"
"  -e, --error=РЕЖИМ  скоригувати буферизацію для потоку стандартних помилок\n"

#: src/stdbuf.c:105
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"Якщо РЕЖИМ дорівнює L, для відповідного потоку буде використано рядкову "
"буферизацію.\n"
"Цей параметр є некоректним для стандартного джерела даних.\n"

#: src/stdbuf.c:108
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"Якщо РЕЖИМ дорівнює 0, відповідний потік не буферизується.\n"

#: src/stdbuf.c:111
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"РЕЖИМ може бути числом, за яким вказано один з таких суфіксів:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024 тощо для G, T, P, E, Z, Y.\n"
"Можна також використовувати двійкові префікси: KiB=K, MiB=M тощо.\n"
"У цьому випадку відповідний потік буде повністю буферизовано зі\n"
"встановленням розміру буфера у РЕЖИМ байтів.\n"

#: src/stdbuf.c:118
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for example) then that will override corresponding changes by 'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""
"\n"
"ЗАУВАЖЕННЯ: якщо КОМАНДА сама коригує буферизацію стандартних потоків даних\n"
"(наприклад tee), перевизначає відповідні параметри, змінені stdbuf.\n"
"Крім того, деякі фільтри (зокрема dd і cat) не використовують потоки для\n"
"введення/виведення, отже параметри stdbuf на них не впливають.\n"

#: src/stdbuf.c:243
#, c-format
msgid "failed to find %s"
msgstr "не вдалося знайти %s"

#: src/stdbuf.c:267 src/stdbuf.c:300
#, c-format
msgid "failed to update the environment with %s"
msgstr "не вдалося оновити середовища за допомогою %s"

#: src/stdbuf.c:346
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "рядкова буферизація stdin не має сенсу"

#: src/stdbuf.c:377
#, c-format
msgid "you must specify a buffering mode option"
msgstr "вам слід вказати параметр режиму буферизації"

#: src/stty.c:531
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"Використання: %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [ПАРАМЕТР]...\n"
"       або    %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [-a|--all]\n"
"       або    %s [-F ПРИСТРІЙ] [--file=ПРИСТРІЙ] [-g|--save]\n"

#: src/stty.c:537
msgid "Print or change terminal characteristics.\n"
msgstr "Виводить або змінює характеристики термінала.\n"

#: src/stty.c:543
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"  -a, --all       вивести поточні параметри у текстовій формі\n"
"  -g, --save      вивести поточні параметри у формі, що зрозуміла програмі\n"
"                  stty\n"
"  -F, --file=ПРИСТРІЙ\n"
"                  відкрити та використовувати вказаний пристрій замість\n"
"                  стандартного вводу\n"

#: src/stty.c:550
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"Необов'язковий знак мінус перед ПАРАМЕТРом означає зміну знаку.  Зірочкою\n"
"позначені параметри, не описані у стандарті POSIX.  Доступність того чи\n"
"іншого параметру визначається системою, що використовується.\n"

#: src/stty.c:555
msgid ""
"\n"
"Special characters:\n"
msgstr ""
"\n"
"Спеціальні символи:\n"

#: src/stty.c:559
msgid " * discard CHAR  CHAR will toggle discarding of output\n"
msgstr " * discard СИМВОЛ СИМВОЛ перемикатиме відкидання виведення\n"

#: src/stty.c:564
msgid ""
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
msgstr ""
" * dsusp СИМВОЛ  СИМВОЛ надсилатиме сигнал зупинки термінала, щойно "
"введення\n"
"                 буде завершено\n"

#: src/stty.c:568
msgid ""
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"  eof СИМВОЛ      СИМВОЛ буде означати кінець файла (припинення введення)\n"
"  eol СИМВОЛ      СИМВОЛ буде означати кінець рядка\n"

#: src/stty.c:573
msgid " * eol2 CHAR     alternate CHAR for ending the line\n"
msgstr " * eol2 СИМВОЛ   заміняти СИМВОЛ на кінець рядка\n"

#: src/stty.c:577
msgid ""
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
"  erase СИМВОЛ    СИМВОЛ буде стирати останній введений до нього\n"
"  intr СИМВОЛ     СИМВОЛ буде надсилати сигнал переривання\n"
"  kill СИМВОЛ     СИМВОЛ буде стирати поточний рядок\n"

#: src/stty.c:583
msgid " * lnext CHAR    CHAR will enter the next character quoted\n"
msgstr " * lnext СИМВОЛ  СИМВОЛ вводитиме наступний символ у лапках\n"

#: src/stty.c:588
msgid " * status CHAR   CHAR will send an info signal\n"
msgstr " * status СИМВОЛ СИМВОЛ надсилатиме сигнал info\n"

#: src/stty.c:592
msgid "   quit CHAR     CHAR will send a quit signal\n"
msgstr "   quit СИМВОЛ   СИМВОЛ надсилатиме сигнал виходу\n"

#: src/stty.c:596
msgid " * rprnt CHAR    CHAR will redraw the current line\n"
msgstr " * rprnt СИМВОЛ  СИМВОЛ перемальовуватиме поточний рядок\n"

#: src/stty.c:600
msgid ""
"   start CHAR    CHAR will restart the output after stopping it\n"
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
msgstr ""
"   start СИМВОЛ  СИМВОЛ перезапускатиме виведення після його зупинення\n"
"   stop СИМВОЛ   СИМВОЛ буде призупиняти ввід\n"
"   susp СИМВОЛ   СИМВОЛ буде надсилати терміналу сигнал зупинки\n"

#: src/stty.c:606
msgid " * swtch CHAR    CHAR will switch to a different shell layer\n"
msgstr " * swtch СИМВОЛ  СИМВОЛ перемикатиме на інший шар оболонки\n"

#: src/stty.c:611
msgid " * werase CHAR   CHAR will erase the last word typed\n"
msgstr "* werase СИМВОЛ   СИМВОЛ буде стирати останнє введене слово\n"

#: src/stty.c:615
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
msgstr ""
"\n"
"Спеціальні параметри:\n"
"   N             встановити швидкість введення та виведення у N бод\n"

#: src/stty.c:621
msgid ""
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"* cols N        повідомити ядру, що термінал має N позицій у рядку\n"
"* columns N     те саме, що і cols N\n"

#: src/stty.c:626
#, c-format
msgid ""
" * [-]drain      wait for transmission before applying settings (%s by "
"default)\n"
msgstr ""
" * [-]drain      зачекати на передавання, перш ніж застосовувати параметри "
"(типове значення: %s)\n"

#: src/stty.c:628
msgid "on"
msgstr "увімкнено"

#: src/stty.c:628
msgid "off"
msgstr "вимкнено"

#: src/stty.c:629
msgid "   ispeed N      set the input speed to N\n"
msgstr "   ispeed N      встановити швидкість надходження вхідних даних N\n"

#: src/stty.c:633
msgid " * line N        use line discipline N\n"
msgstr ""
" * line N        використовувати порядок передавання лінією зв’язку N\n"

#: src/stty.c:637
msgid ""
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"   min N         використовується з -icanon, встановити Н мінімальним "
"числом\n"
"                 символів для завершення операції читання\n"
"   ospeed N      встановити швидкість виводу N\n"

#: src/stty.c:642
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
msgstr ""
"* rows N        повідомити ядру, що термінал має N рядків\n"
"* size          вивести числа стовпчиків та рядків, відомі ядру\n"

#: src/stty.c:647
msgid ""
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
"   speed         вивести швидкість термінала\n"
"   time N        використовується з -icanon, встановити часову межу для\n"
"                 операції читання рівним N десятим секунди\n"

#: src/stty.c:651
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
msgstr ""
"\n"
"Параметри керування:\n"
"   [-]clocal     вимкнути сигнали керування модемом\n"
"   [-]cread      дозволити отримання вхідних даних\n"

#: src/stty.c:658
msgid " * [-]crtscts    enable RTS/CTS handshaking\n"
msgstr " * [-]crtscts    увімкнути узгодження RTS/CTS\n"

#: src/stty.c:663
msgid " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
msgstr " * [-]cdtrdsr    увімкнути узгодження DTR/DSR\n"

#: src/stty.c:667
msgid "   csN           set character size to N bits, N in [5..8]\n"
msgstr ""
"   csN           встановити розмір символу у N бітів, N — число у діапазоні "
"[5..8]\n"

#: src/stty.c:670
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""
"  [-]cstopb     два біти розділення у символі (один, якщо з '-')\n"
"  [-]hup        надсилати сигнал обриву термінальної лінії, коли останній\n"
"                процес закриває термінал\n"
"  [-]hupcl      синонім [-]hup\n"
"  [-]parenb     генерувати при виводі біт парності та очікувати біт "
"парності\n"
"                на вводі\n"
"  [-]parodd     встановити перевірку на непарність (або парність, якщо з "
"'-')\n"

#: src/stty.c:678
msgid " * [-]cmspar     use \"stick\" (mark/space) parity\n"
msgstr ""
" * [-]cmspar     використовувати «жорстку» (із позначками і пробілами) "
"парність\n"

#: src/stty.c:682
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
"   [-]ignpar     ignore characters with parity errors\n"
msgstr ""
"\n"
"Параметри вводу:\n"
"   [-]brkint     символ break буде викликати сигнал переривання\n"
"   [-]icrnl      перетворювати переведення каретки у переведення рядка\n"
"   [-]ignbrk     ігнорувати символи переривання\n"
"   [-]igncr      ігнорувати символи переведення каретки\n"
"   [-]ignpar     ігнорувати символи із порушенням парності\n"

#: src/stty.c:692
msgid ""
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
msgstr ""
" * [-]imaxbel    видавати гудок і не спорожнювати повний буфер введення у "
"відповідь на символ\n"

#: src/stty.c:696
msgid ""
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"  [-]inlcr      перетворювати переведення рядка у переведення каретки\n"
"  [-]inpck      використовувати перевірку парності вводу\n"
"  [-]istrip     очищати старший (восьмий) біт символів, що вводяться\n"

#: src/stty.c:702
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " * [-]iutf8      вважати, що вхідні знаки у кодуванні UTF-8\n"

#: src/stty.c:707
msgid " * [-]iuclc      translate uppercase characters to lowercase\n"
msgstr ""
" * [-]iuclc      перетворювати літери у верхньому регістрі на літери у "
"нижньому регістрі\n"

#: src/stty.c:712
msgid ""
" * [-]ixany      let any character restart output, not only start character\n"
msgstr ""
" * [-]ixany      дозволити будь-якому символу перезапускати виведення, не "
"лише початковому символу\n"

#: src/stty.c:716
msgid ""
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
"  [-]ixoff      дозволити надсилання символів призупинення/відновлення\n"
"  [-]ixon       дозволити керування потоком даних\n"
"  [-]parmrk     позначати помилки парності (послідовністю з 255 нуль-"
"символів)\n"
"  [-]tandem     синонім [-]xioff\n"

#: src/stty.c:722
msgid ""
"\n"
"Output settings:\n"
msgstr ""
"\n"
"Параметри виведення:\n"

#: src/stty.c:727
msgid " * bsN           backspace delay style, N in [0..1]\n"
msgstr ""
" * bsN           стиль затримки backspace, N — число у діапазоні [0..1]\n"

#: src/stty.c:732
msgid " * crN           carriage return delay style, N in [0..3]\n"
msgstr ""
" * crN           стиль затримки повернень каретки, N — число у діапазоні "
"[0..3]\n"

#: src/stty.c:737
msgid " * ffN           form feed delay style, N in [0..1]\n"
msgstr ""
" * ffN           стиль затримки посування сторінки, N — число у діапазоні "
"[0..1]\n"

#: src/stty.c:742
msgid " * nlN           newline delay style, N in [0..1]\n"
msgstr ""
" * nlN           стиль затримки розриву рядка, N — число у діапазоні [0..1]\n"

#: src/stty.c:747
msgid " * [-]ocrnl      translate carriage return to newline\n"
msgstr " * [-]ocrnl      перетворювати повернення каретки на розрив рядка\n"

#: src/stty.c:752
msgid ""
" * [-]ofdel      use delete characters for fill instead of NUL characters\n"
msgstr ""
" * [-]ofdel      використовувати для заповнення символи вилучення, а не "
"символи NUL\n"

#: src/stty.c:757
msgid ""
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
msgstr ""
" * [-]ofill      використовувати символи заповнення замість таймера для "
"затримок\n"

#: src/stty.c:762
msgid " * [-]olcuc      translate lowercase characters to uppercase\n"
msgstr ""
" * [-]olcuc      перетворювати літери у нижньому регістрі на літери у "
"верхньому регістрі\n"

#: src/stty.c:767
msgid " * [-]onlcr      translate newline to carriage return-newline\n"
msgstr ""
" * [-]onlcr      перетворювати розриви рядка на комбінації повернення "
"каретки і розриву рядка\n"

#: src/stty.c:772
msgid " * [-]onlret     newline performs a carriage return\n"
msgstr " * [-]onlret     розрив рядка призводить до повернення каретки\n"

#: src/stty.c:777
msgid " * [-]onocr      do not print carriage returns in the first column\n"
msgstr " * [-]onocr      не виводити повернення каретки у першу позицію\n"

#: src/stty.c:781
msgid "   [-]opost      postprocess output\n"
msgstr "   [-]opost      додатково виконувати завершальну обробку виведеного\n"

#: src/stty.c:785
msgid ""
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
msgstr ""
" * tabN          стиль затримки горизонтальної табуляції, N — число у "
"діапазоні [0..3]\n"
" * tabs          те саме, що і tab0\n"
" * -tabs         те саме, що і tab3\n"

#: src/stty.c:792
msgid " * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""
" * vtN           стиль затримки вертикальної табуляції, N — число у "
"діапазоні [0..1]\n"

#: src/stty.c:796
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
msgstr ""
"\n"
"Локальні параметри:\n"
"   [-]crterase   виводити символи erase як backspace-пробіл-backspace\n"

#: src/stty.c:802
msgid ""
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"* crtkill       стирати весь рядок, згідно з параметрами echoprt та echoe\n"
"* -crtkill      стирати весь рядок, згідно з параметрами echoctl та echok\n"

#: src/stty.c:808
msgid " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
msgstr " * [-]ctlecho    виводити керівні символи з каре («^c»)\n"

#: src/stty.c:812
msgid "   [-]echo       echo input characters\n"
msgstr "   [-]echo       виводити введені символи\n"

#: src/stty.c:816
msgid " * [-]echoctl    same as [-]ctlecho\n"
msgstr " * [-]echoctl    те саме, що і [-]ctlecho\n"

#: src/stty.c:820
msgid ""
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
"   [-]echoe      те саме, що і [-]crterase\n"
"   [-]echok      виводити розрив рядка після символу знищення\n"

#: src/stty.c:825
msgid " * [-]echoke     same as [-]crtkill\n"
msgstr " * [-]echoke     те саме, що і [-]crtkill\n"

#: src/stty.c:829
msgid "   [-]echonl     echo newline even if not echoing other characters\n"
msgstr ""
"   [-]echonl     виводити розрив рядка, навіть якщо не копіюються інші "
"символи\n"

#: src/stty.c:833
msgid ""
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
msgstr " * [-]echoprt    виводити вилучені символи за курсор, між «\\» і «/»\n"

#: src/stty.c:838
msgid " * [-]extproc    enable \"LINEMODE\"; useful with high latency links\n"
msgstr ""
" * [-]extproc    увімкнути «лінійний режим»; корисно для посилань із високою "
"латентністю\n"

#: src/stty.c:843
msgid " * [-]flusho     discard output\n"
msgstr " * [-]flusho     відкинути виведені дані\n"

#: src/stty.c:847
#, c-format
msgid ""
"   [-]icanon     enable special characters: %s\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"   [-]icanon     уможливити спеціальні символи: %s\n"
"   [-]iexten     уможливити спеціальні символи не з POSIX\n"

#: src/stty.c:858
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
msgstr ""
"  [-]isig       використовувати спецсимволи interrupt, quit, та suspend\n"
"  [-]noflsh     заборонити скидання буфера після переривання спецсимволами\n"
"                interrupt та quit\n"

#: src/stty.c:863
msgid " * [-]prterase   same as [-]echoprt\n"
msgstr " * [-]prterase   те саме, що [-]echoprt\n"

#: src/stty.c:868
msgid ""
" * [-]tostop     stop background jobs that try to write to the terminal\n"
msgstr ""
" * [-]tostop     зупинити фонові завдання, які намагаються виконати запис до "
"термінала\n"

#: src/stty.c:873
msgid ""
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""
" * [-]xcase      з icanon, екранування «\\» символів у верхньому регістрі\n"

#: src/stty.c:877
msgid ""
"\n"
"Combination settings:\n"
msgstr ""
"\n"
"Параметри поєднання:\n"

#: src/stty.c:882
msgid " * [-]LCASE      same as [-]lcase\n"
msgstr " * [-]LCASE      те саме, що [-]lcase\n"

#: src/stty.c:886
msgid ""
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"  cbreak        те саме, що -icanon\n"
"  -cbreak       те саме, що icanon\n"

#: src/stty.c:890
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
msgstr ""
"  cooked        те саме, що brkint ignpar istrip icrnl ixon opost isig,\n"
"                символи  icanon, eof та eol мають типове значення\n"
"  -cooked       те саме, що raw\n"

#: src/stty.c:895
#, c-format
msgid "   crt           same as %s\n"
msgstr "   crt           те саме, що %s\n"

#: src/stty.c:905
#, c-format
msgid ""
"   dec           same as %s intr ^c erase 0177\n"
"                 kill ^u\n"
msgstr ""
"   dec           те саме, що %s intr ^c erase 0177\n"
"                 kill ^u\n"

#: src/stty.c:920
msgid " * [-]decctlq    same as [-]ixany\n"
msgstr " * [-]decctlq    те саме, що [-]ixany\n"

#: src/stty.c:924
msgid ""
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
"   -evenp        same as -parenb cs8\n"
msgstr ""
"   ek            зводити символи erase і kill до типових значень\n"
"   evenp         те саме, що і parenb -parodd cs7\n"
"   -evenp        те саме, що і -parenb cs8\n"

#: src/stty.c:930
msgid " * [-]lcase      same as xcase iuclc olcuc\n"
msgstr " * [-]lcase      те саме, що xcase iuclc olcuc\n"

#: src/stty.c:934
msgid ""
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
msgstr ""
"   litout        те саме, що -parenb -istrip -opost cs8\n"
"   -litout       те саме, що parenb istrip opost cs7\n"

#: src/stty.c:938
#, c-format
msgid ""
"   nl            same as %s\n"
"   -nl           same as %s\n"
msgstr ""
"   nl            те саме, що %s\n"
"   -nl           те саме, що %s\n"

#: src/stty.c:956
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"  oddp          синонім parenb parodd cs7\n"
"  -oddp         синонім -parenb cs8\n"
"  [-]parity     синонім [-]evenp\n"
"  pass8         синонім -parenb -istrip cs8\n"
"  -pass8        синонім parenb istrip cs7\n"

#: src/stty.c:963
#, c-format
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"  raw            те саме, що і -ignbrk -brkint -ignpar -parmrk -inpck -"
"istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"  -raw           те саме, що і cooked\n"

#: src/stty.c:982
#, c-format
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 all special characters to their default values\n"
msgstr ""
"   sane          те саме, що і cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 усі спеціальні символи мають типові значення\n"

#: src/stty.c:1068
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"Керує термінальною лінією, що підключена до стандартного вводу.  Запущена\n"
"без аргументів, виводить швидкість передачі інформації, line discipline та\n"
"відмінності від звичайних параметрів.  В параметрах, СИМВОЛИ трактуються\n"
"буквально або вказуються у як ^c, 0x37, 0177 або 127; для скасування\n"
"спеціальних символів служать значення ^- та undef.\n"

#: src/stty.c:1097
#, c-format
msgid "missing argument to %s"
msgstr "пропущений аргумент для %s"

#: src/stty.c:1140 src/stty.c:1258
#, c-format
msgid "invalid argument %s"
msgstr "неправильний аргумент %s"

#: src/stty.c:1192
#, c-format
msgid "%s: error setting %s"
msgstr "%s: помилка під час встановлення %s"

#: src/stty.c:1234
#, c-format
msgid "invalid line discipline %s"
msgstr "неправильна line discipline %s"

#: src/stty.c:1326
msgid "only one device may be specified"
msgstr "можна вказати лише одне пристрій"

#: src/stty.c:1360
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr ""
"ключі для виводу у текстовому та виводі, зрозумілому програмі stty,\n"
"виключають один одного"

#: src/stty.c:1366
msgid "when specifying an output style, modes may not be set"
msgstr "при вказуванні стилю виводу не можна встановлювати режим"

#: src/stty.c:1384
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: не вдалося переініціалізувати неблокуючий режим"

#: src/stty.c:1447
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: не вдалося виконати всі запитані дії"

#: src/stty.c:1792
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: для цього пристрою немає відомостей про розмір"

#: src/stty.c:2321
msgid "invalid integer argument"
msgstr "некоректний цілий аргумент"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:38
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:63
msgid "Print checksum and block counts for each FILE.\n"
msgstr ""
"Виводить контрольну суму і кількість блоків для кожного ФАЙЛА.\n"
"\n"

#: src/sum.c:69
msgid ""
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"\n"
"  -r              використовувати метод обчислення контрольних сум BSD,\n"
"                  розмір блоку 1 кБ\n"
"  -s, --sysv      використовувати метод обчислення контрольних сум System "
"V,\n"
"                  розмір блоку 512 байт\n"

#: src/sync.c:64
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Використання: %s [ПАРАМЕТР] [ФАЙЛ]...\n"

#: src/sync.c:65
msgid ""
"Synchronize cached writes to persistent storage\n"
"\n"
"If one or more files are specified, sync only them,\n"
"or their containing file systems.\n"
"\n"
msgstr ""
"Синхронізувати кешований запис на носій постійного зберігання\n"
"\n"
"Якщо вказано один або декілька файлів, синхронізувати лише ці файли\n"
"або файлові системи, які їх містять.\n"
"\n"

#: src/sync.c:73
msgid "  -d, --data             sync only file data, no unneeded metadata\n"
msgstr ""
"  -d, --data             синхронізувати лише дані файла, без непотрібних "
"метаданих\n"

#: src/sync.c:76
msgid "  -f, --file-system      sync the file systems that contain the files\n"
msgstr ""
"  -f, --file-system      синхронізувати файлові системи, що містять файли\n"

#: src/sync.c:115
#, c-format
msgid "error opening %s"
msgstr "помилка під час відкриття %s"

#: src/sync.c:126
#, c-format
msgid "couldn't reset non-blocking mode %s"
msgstr "не вдалося переініціалізувати режим без блокування %s"

#: src/sync.c:157
#, c-format
msgid "error syncing %s"
msgstr "помилка під час синхронізації %s"

#: src/sync.c:215
msgid "cannot specify both --data and --file-system"
msgstr "не можна одночасно використовувати параметри --data і --file-system"

#: src/sync.c:219
msgid "--data needs at least one argument"
msgstr "--data слід передати принаймні один аргумент"

#: src/system.h:347
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"ПРИМІТКА: ваша оболонка може надавати свою версію %s, яка\n"
"звичайно перекриває версію, описану тут.  Зверніться до\n"
"документації з вашої оболонки, щоб дізнатись, які ключі вона\n"
"підтримує.\n"

#: src/system.h:353
msgid "      --help     display this help and exit\n"
msgstr "      --help     показати цю довідку та вийти\n"

#: src/system.h:355
msgid "      --version  output version information and exit\n"
msgstr ""
"      --version  показати інформацію про версію та вийти\n"
"\n"

#: src/system.h:583
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Якщо вхідний файл не вказаний, або якщо вказано символ -,\n"
"використовується стандартний ввід.\n"

#: src/system.h:590
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"\n"
"Обов'язкові аргументи для довгих форм запису параметрів є обов'язковими і "
"для скорочених форм.\n"

#: src/system.h:598
msgid ""
"\n"
"The SIZE argument is an integer and optional unit (example: 10K is "
"10*1024).\n"
"Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"РОЗМІР є цілим числом з додатковим значенням одиниці (приклад: 10K = "
"10*1024).\n"
"Одиницями можуть бути K, M, G, T, P, E, Z, Y (степені 1024) або KB, MB... "
"(степені 1000).\n"
"Можна також використовувати двійкові префікси: KiB=K, MiB=M тощо.\n"

#: src/system.h:608
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"Показує значення у одиницях першого доступного РОЗМІРу з --block-size\n"
"та змінні середовища %s_BLOCK_SIZE, BLOCK_SIZE та BLOCKSIZE.\n"
"Якщо розмір не буде знайдено, типовою одиницею буде 1024 байтів\n"
"(або 512, якщо встановлено POSIXLY_CORRECT).\n"

#: src/system.h:618
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"Типовий суфікс для запасних копій ~, лише якщо не встановлена\n"
"змінна оточення SIMPLE_BACKUP_SUFFIX або ключ --suffix. Спосіб контролю\n"
"версій можна вказати ключем --backup або змінною оточення\n"
"VERSION_CONTROL. Можливі значення:\n"
"\n"

#: src/system.h:625
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       ніколи не створювати резервних копій (навіть якщо\n"
"                  вказаний ключ --backup)\n"
"  numbered, t     створювати нумеровані копії\n"
"  existing, nil   якщо існують нумеровані копії, то створювати\n"
"                  нумеровані інакше створювати прості\n"
"  simple. never   завжди створювати прості копії\n"

#: src/system.h:655
#, c-format
msgid ""
"\n"
"%s online help: <%s>\n"
msgstr ""
"\n"
"Довідкові дані щодо %s у мережі: <%s>\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <https://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at https://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:666
msgid "Report any translation bugs to <https://translationproject.org/team/>\n"
msgstr ""
"Повідомляйте про усі помилки перекладі на адресу, вказану на сторінці "
"<https://translationproject.org/team/uk.html>\n"

#: src/system.h:669
#, c-format
msgid "Full documentation <%s%s>\n"
msgstr "Документація повністю: <%s%s>\n"

#: src/system.h:671
#, c-format
msgid "or available locally via: info '(coreutils) %s%s'\n"
msgstr "вона ж доступна локально: info '(coreutils) %s%s'\n"

#: src/system.h:682
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "Спробуйте '%s --help' для одержання додаткової інформації.\n"

#: src/system.h:726
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"УВАГА: Зациклення у структурі каталогу.\n"
"Швидше за все, це означає, що ваша файлова система пошкоджена.\n"
"ПОВІДОМТЕ ВАШОГО СИСТЕМНОГО АДМІНІСТРАТОРА.\n"
"Наступний каталог є частиною циклу:\n"
" %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:136
msgid "Write each FILE to standard output, last line first.\n"
msgstr "Вивести кожен ФАЙЛ до стандартного виведення, останній рядок першим.\n"

#: src/tac.c:143
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             приєднати розділювач до початку, а не до кінця\n"
"  -r, --regex              сприймати розділювач як регулярний вираз\n"
"  -s, --separator=РЯДОК    вказати розділювачем РЯДОК, а не знак '\\n'\n"

#: src/tac.c:223 src/tac.c:233 src/tac.c:343
#, c-format
msgid "%s: seek failed"
msgstr "%s: помилка переміщення по файла"

#: src/tac.c:276
msgid "record too large"
msgstr "запис надто великий"

#: src/tac.c:458
#, c-format
msgid "failed to create temporary file in %s"
msgstr "не вдалося створити тимчасовий файл у %s"

#: src/tac.c:466
#, c-format
msgid "failed to open %s for writing"
msgstr "не вдалося відкрити %s для читання"

#: src/tac.c:484
#, c-format
msgid "failed to rewind stream for %s"
msgstr "не вдалося повернутися до початку потоку даних для %s"

#: src/tac.c:521 src/tac.c:533
#, c-format
msgid "%s: write error"
msgstr "%s: помилка запису"

#: src/tac.c:582
#, c-format
msgid "failed to open %s for reading"
msgstr "помилка при спробі відкрити %s для читання"

#: src/tac.c:650
msgid "separator cannot be empty"
msgstr "розділювач не може бути порожнім"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:78
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:269
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Виводить останні %d рядків кожного з ФАЙЛІВ до стандартного виведення.\n"
"Якщо задано декілька ФАЙЛІВ, спочатку виводить перед даними заголовок із "
"назвою файла.\n"

#: src/tail.c:277
msgid ""
"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
"                             output starting with byte NUM of each file\n"
msgstr ""
"  -c, --bytes=[+]ЧИСЛО     вивести вказану кількість останніх байтів;\n"
"                             -c +ЧИСЛО можна вказати, щоб виведення для\n"
"                             кожного файла починалося із байта ЧИСЛО\n"

#: src/tail.c:281
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                             an absent option argument means 'descriptor'\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           виводити дані, що надходять, при зростанні "
"файла;\n"
"                           -f, --follow та --follow=descriptor еквівалентні\n"
"  -F                       еквівалент --follow=name --retry\n"

#: src/tail.c:287
#, c-format
msgid ""
"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last "
"%d;\n"
"                             or use -n +NUM to output starting with line "
"NUM\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                             changed size after N (default %d) iterations\n"
"                             to see if it has been unlinked or renamed\n"
"                             (this is the usual case of rotated log files);\n"
"                             with inotify, this option is rarely useful\n"
msgstr ""
"  -n, --lines=[+]Н         виводити останні Н рядків, а не останні %d\n"
"                           скористайтеся -n +Н для виведення рядків з Н-го\n"
"      --max-unchanged-stats=Н\n"
"                           c ключем --follow=name, повторно відкривати\n"
"                           ФАЙЛ, який не змінився останні Н (типово %d)\n"
"                           ітерацій, щоб перевірити, чи не було його "
"вилучено\n"
"                           або перейменовано (таке звичайно буває при\n"
"                           ротації системних протокольних файлів)\n"
"                           З inotify цей параметр малокорисний.\n"

#: src/tail.c:300
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file if it is inaccessible\n"
msgstr ""
"      --pid=PID            з ключем -f, перерватися, коли процес PID\n"
"                           завершує роботу\n"
"  -q, --quiet, --silent    не виводити заголовки з назвами файлів\n"
"      --retry              повторювати спроби відкрити файл, навіть якщо\n"
"                             доступ до нього буде втрачено\n"

#: src/tail.c:305
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations;\n"
"                             with inotify and --pid=P, check process P at\n"
"                             least once every N seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=Н   з ключем -f, перевіряти отримання нових даних\n"
"                             приблизно кожні Н секунд (типово 1).\n"
"                             Якщо використано inotify і --pid=P, перевіряти\n"
"                             процес P принаймні кожні Н секунд.\n"
"  -v, --verbose            завжди виводити заголовки з назвами файлів\n"

#: src/tail.c:317
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
msgstr ""
"\n"
"Після ЧИСЛА блоків та байт може стоять один з множників:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"
"Можна також використовувати двійкові префікси: KiB=K, MiB=M тощо.\n"
"\n"

#: src/tail.c:325
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"З --follow (-f) tail типово слідкує за дескриптором файла, тобто, навіть "
"якщо\n"
"назву файла буде змінено, tail продовжуватиме стежити за його кінцем.\n"
"Така типова поведінка небажана, якщо ви хочете слідкувати за файлом, який\n"
"має певну назву, а не за дескриптором (наприклад файлом журналу, який\n"
"підлягає періодичній ротації). У такому разі використовуйте\n"
"--follow=name. Це змусить tail слідувати за вказаним файлом, беручи до "
"уваги\n"
"його перейменування, вилучення або створення.\n"

#: src/tail.c:416
#, c-format
msgid "closing %s (fd=%d)"
msgstr "закриття %s (fd=%d)"

#: src/tail.c:515
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: не вдалося перемістити вказівник позиції на %s відносно кінця"

#: src/tail.c:951
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr ""
"не вдалося визначити розташування %s. Повертаємося до способу опитування"

#: src/tail.c:1007
#, c-format
msgid "%s has been replaced with an untailable symbolic link"
msgstr "%s було замінено символічним посиланням, до якого tail незастосовний"

#: src/tail.c:1022
#, c-format
msgid "%s has become inaccessible"
msgstr "%s став недоступний"

#: src/tail.c:1040
#, c-format
msgid "%s has been replaced with an untailable file%s"
msgstr "%s було замінено файлом, до якого tail незастосовний%s"

#: src/tail.c:1042 src/tail.c:2048
msgid "; giving up on this name"
msgstr "; припиняємо обробку на цій назві"

#: src/tail.c:1048
#, c-format
msgid "%s has been replaced with an untailable remote file"
msgstr "%s було замінено віддаленим файлом, до якого tail незастосовний"

#: src/tail.c:1069
#, c-format
msgid "%s has become accessible"
msgstr "%s став доступний"

#: src/tail.c:1081
#, c-format
msgid "%s has appeared;  following new file"
msgstr "З’явилося %s; виводимо новий файл"

#: src/tail.c:1091
#, c-format
msgid "%s has been replaced;  following new file"
msgstr "Замінено %s; виводимо новий файл"

#: src/tail.c:1206
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s: не вдалося змінити неблокуючий режим"

#: src/tail.c:1252 src/tail.c:1427
#, c-format
msgid "%s: file truncated"
msgstr "%s: файл обрізаний"

#: src/tail.c:1286 src/tail.c:1628
#, c-format
msgid "no files remaining"
msgstr "більше немає файлів"

#: src/tail.c:1522
#, c-format
msgid "cannot watch parent directory of %s"
msgstr "не вдалося виконати спостереження за батьківським каталогом %s"

#: src/tail.c:1525 src/tail.c:1542 src/tail.c:1752
#, c-format
msgid "inotify resources exhausted"
msgstr "вичерпано ресурси inotify"

#: src/tail.c:1546 src/tail.c:1760
#, c-format
msgid "cannot watch %s"
msgstr "не вдалося виконати спостереження за %s"

#: src/tail.c:1595
#, c-format
msgid "%s was replaced"
msgstr "Замінено %s"

#: src/tail.c:1667
msgid "error waiting for inotify and output events"
msgstr "помилка під час спроби дочекатися подій inotify та виведення"

#: src/tail.c:1695
msgid "error reading inotify event"
msgstr "помилка під час спроби читання події inotify"

#: src/tail.c:1714
#, c-format
msgid "directory containing watched file was removed"
msgstr "каталог із файлом, за яким велося спостереження, вилучено"

#: src/tail.c:2046
#, c-format
msgid "%s: cannot follow end of this type of file%s"
msgstr "%s: не можна стежити за кінцем файла такого типу%s"

#: src/tail.c:2227
msgid "invalid maximum number of unchanged stats between opens"
msgstr "некоректна максимальна кількість незмінених параметрів між відкриттями"

#: src/tail.c:2235
msgid "invalid PID"
msgstr "некоректний PID"

#: src/tail.c:2251
#, c-format
msgid "invalid number of seconds: %s"
msgstr "некоректна кількість секунд: %s"

#: src/tail.c:2270
#, c-format
msgid "option used in invalid context -- %c"
msgstr "параметр використовує неправильний контекст -- %c"

#: src/tail.c:2282
#, c-format
msgid "warning: --retry ignored; --retry is useful only when following"
msgstr ""
"попередження: --retry проігноровано; --retry корисний лише при слідуванні"

#: src/tail.c:2286
#, c-format
msgid "warning: --retry only effective for the initial open"
msgstr "попередження: --retry працюватиме лише для початкового відкриття"

#: src/tail.c:2291
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"попередження: PID ігнорований; ключ --pid=PID корисний лише при слідуванні"

#: src/tail.c:2294
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "попередження: --pid=PID не підтримується на цій системі"

#: src/tail.c:2400
#, c-format
msgid "cannot follow %s by name"
msgstr "не вдалося слідувати за %s за назвою"

#: src/tail.c:2415
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "попередження: нескінченне стеження за стандартним вводом неефективне"

#: src/tail.c:2512
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "не можна використовувати inotify, повертаємося до способу опитування"

#: src/tee.c:88
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"Копіює стандартний ввід у кожен ФАЙЛ, а також у стандартний вивід.\n"
"\n"
"  -a, --append              дописати у вказані ФАЙЛИ\n"
"  -i, --ignore-interrupts   ігнорувати сигнали переривання\n"

#: src/tee.c:94
msgid ""
"  -p                        diagnose errors writing to non pipes\n"
"      --output-error[=MODE]   set behavior on write error.  See MODE below\n"
msgstr ""
"  -p                        діагностувати помилки, якщо запис ведеться не до "
"каналів обробки\n"
"      --output-error[=РЕЖИМ]  визначити поведінку під час запису помилок "
"Див. РЕЖИМ нижче\n"

#: src/tee.c:100
msgid ""
"\n"
"MODE determines behavior with write errors on the outputs:\n"
"  'warn'         diagnose errors writing to any output\n"
"  'warn-nopipe'  diagnose errors writing to any output not a pipe\n"
"  'exit'         exit on error writing to any output\n"
"  'exit-nopipe'  exit on error writing to any output not a pipe\n"
"The default MODE for the -p option is 'warn-nopipe'.\n"
"The default operation when --output-error is not specified, is to\n"
"exit immediately on error writing to a pipe, and diagnose errors\n"
"writing to non pipe outputs.\n"
msgstr ""
"\n"
"РЕЖИМ визначає поведінку у відповідь на помилки запису виведених даних:\n"
"  'warn'         діагностувати помилки запису до будь-якого виведення\n"
"  'warn-nopipe'  діагностувати помилки запису до будь-якого виведення, окрім "
"каналу обробки\n"
"  'exit'         виходити при помилках запису до будь-якого виведення\n"
"  'exit-nopipe'  виходити при помилках запису до будь-якого виведення, окрім "
"каналу обробки\n"
"Типовим значенням параметра РЕЖИМ для параметра -p є 'warn-nopipe'.\n"
"Типовою дією у відповідь, якщо не вказано --output-error, є негайне "
"завершення обробки,\n"
"якщо виявлено помилку запису до каналу обробки, та діагностування помилок "
"запису,\n"
"якщо запис виконувався не до каналу обробки.\n"

#: src/test.c:126
#, c-format
msgid "missing argument after %s"
msgstr "пропущений аргумент після %s"

#: src/test.c:162
#, c-format
msgid "invalid integer %s"
msgstr "неправильне ціле число %s"

#: src/test.c:244
#, c-format
msgid "%s expected"
msgstr "мало бути %s"

#: src/test.c:247
#, c-format
msgid "%s expected, found %s"
msgstr "мало бути %s, а маємо %s"

#: src/test.c:328
msgid "-nt does not accept -l"
msgstr "-nt не допускає -l"

#: src/test.c:341
msgid "-ef does not accept -l"
msgstr "-ef не допускає -l"

#: src/test.c:357
msgid "-ot does not accept -l"
msgstr "-ot не допускає -l"

#: src/test.c:366
#, c-format
msgid "%s: unknown binary operator"
msgstr "%s: невідомий бінарний оператор"

#: src/test.c:396
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очікується унарний оператор"

#: src/test.c:632
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очікується двійковий оператор"

#: src/test.c:690
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"Використання: test ВИРАЗ\n"
"  або:  test\n"
"  або:  [ ВИРАЗ ]\n"
"  або:  [ ]\n"
"  або:  [ КЛЮЧ\n"

#: src/test.c:697
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr "Вихідний статус визначається ВИРАЗОМ.\n"

#: src/test.c:703
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"Якщо ВИРАЗ не вказаний, він вважається хибним.  У іншому випадку\n"
"ВИРАЗ може бути істинним або хибним; він встановлює статус\n"
"завершення програми.  Код завершення визначається наступним образом:\n"

#: src/test.c:708
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( ВИРАЗ )               ВИРАЗ істинний\n"
"  ! ВИРАЗ                 ВИРАЗ хибний\n"
"  ВИРАЗ1 -a ВИРАЗ2        ВИРАЗ1 та ВИРАЗ2 обидва істинні\n"
"  ВИРАЗ1 -o ВИРАЗ2        ВИРАЗ1 або ВИРАЗ2 істинний\n"

#: src/test.c:715
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n РЯДОК            довжина РЯДКА відмінна від нуля\n"
"  РЯДОК               еквівалентно -n РЯДОК\n"
"  -z РЯДОК            довжина РЯДКА дорівнює нулю\n"
"  РЯДОК1 = РЯДОК2     рядки еквівалентні\n"
"  РЯДОК1 != РЯДОК2    рядки не еквівалентні\n"

#: src/test.c:723
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  ЦІЛЕ1 -eq ЦІЛЕ2   ЦІЛЕ1 дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -ge ЦІЛЕ2   ЦІЛЕ1 більше або дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -gt ЦІЛЕ2   ЦІЛЕ1 більше ЦІЛОГО2\n"
"  ЦІЛЕ1 -le ЦІЛЕ2   ЦІЛЕ1 менше або дорівнює ЦІЛОМУ2\n"
"  ЦІЛЕ1 -lt ЦІЛЕ2   ЦІЛЕ1 менше ЦІЛОГО2\n"
"  ЦІЛЕ1 -ne ЦІЛЕ2   ЦІЛЕ1 відмінне від ЦІЛОГО2\n"

#: src/test.c:732
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  ФАЙЛ1 -ef ФАЙЛ2   ФАЙЛ1 та ФАЙЛ2 мають одинакові пристрої та номери inode\n"
"  ФАЙЛ1 -nt ФАЙЛ2   ФАЙЛ1 змінювався пізніше ніж ФАЙЛ2\n"
"  ФАЙЛ1 -ot ФАЙЛ2   ФАЙЛ1 створений пізніше ніж ФАЙЛ2\n"

#: src/test.c:738
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b ФАЙЛ     ФАЙЛ існує та є спеціальним з блоковим доступом\n"
"  -c ФАЙЛ     ФАЙЛ існує та є спеціальним з символьним доступом\n"
"  -d ФАЙЛ     ФАЙЛ існує та є каталогом\n"
"  -e ФАЙЛ     ФАЙЛ існує\n"

#: src/test.c:745
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f ФАЙЛ     ФАЙЛ існує та є звичайним файлом\n"
"  -g ФАЙЛ     ФАЙЛ існує та має ознака set-group-ID\n"
"  -G ФАЙЛ     ФАЙЛ існує та належить поточної ефективній групі\n"
"  -h ФАЙЛ     ФАЙЛ існує та є символьним посиланням (еквівалент -L)\n"
"  -k ФАЙЛ     ФАЙЛ існує та має ознака sticky\n"

#: src/test.c:752
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -N FILE     FILE exists and has been modified since it was last read\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L ФАЙЛ     ФАЙЛ існує та є символьним посиланням (еквівалент -h)\n"
"  -N FILE     ФАЙЛ існує, і його було змінено з часу останнього читання\n"
"  -O ФАЙЛ     ФАЙЛ існує та належить поточному ефективному користувачу\n"
"  -p ФАЙЛ     ФАЙЛ існує та є іменованим каналом\n"
"  -r ФАЙЛ     ФАЙЛ існує доступний для читання\n"
"  -s ФАЙЛ     ФАЙЛ існує та має ненульовий розмір\n"

#: src/test.c:760
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S ФАЙЛ     ФАЙЛ існує та є сокетом\n"
"  -t [ДФ]     дескриптор файла ДФ відкритий на терміналі\n"
"  -u ФАЙЛ     ФАЙЛ існує та має ознака set-user-ID\n"
"  -w ФАЙЛ     ФАЙЛ існує та доступний для запису\n"
"  -x ФАЙЛ     ФАЙЛ існує та є виконуваним\n"

#: src/test.c:767
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"Всі тести, що відносяться до ФАЙЛА, крім -h та -L розіменовують\n"
"символьні посилання.  Пам'ятайте, що ви повинні скасувати спеціальне\n"
"значення дужок для командного інтерпретатора (наприклад, за допомогою\n"
"знаку '\\').  ЦІЛЕ може також бути вказане як \"-l РЯДОК\", при цьому\n"
"воно приймає значення довжини РЯДКА.\n"

#: src/test.c:773
msgid ""
"\n"
"NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n"
"EXPR2' or 'test EXPR1 || test EXPR2' instead.\n"
msgstr ""
"\n"
"ЗАУВАЖЕННЯ: двійкові -a і -o є спадково неоднозначними. Слід користуватися\n"
"«test ВИРАЗ1 && test ВИРАЗ2» або «test ВИРАЗ1 || test ВИРАЗ2».\n"

#: src/test.c:778
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"ПРИМІТКА: [ притримується параметрів --help та --version options, але тест - "
"ні.\n"
"інтерпретує кожен з цих параметрів як будь-який непорожній рядок.\n"

#: src/test.c:783
msgid "test and/or ["
msgstr "test та/або ["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:795
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:796
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:850
#, c-format
msgid "missing %s"
msgstr "пропущено %s"

#: src/test.c:864
#, c-format
msgid "extra argument %s"
msgstr "зайвий аргумент %s"

#: src/timeout.c:135
#, c-format
msgid "warning: timer_settime"
msgstr "попередження: timer_settime"

#: src/timeout.c:140
#, c-format
msgid "warning: timer_create"
msgstr "попередження: timer_create"

#: src/timeout.c:207
#, c-format
msgid "sending signal %s to command %s"
msgstr "надсилаємо сигнал %s команді %s"

#: src/timeout.c:235
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Використання: %s [ПАРАМЕТР] ТРИВАЛІСТЬ КОМАНДА [АРГУМЕНТ]...\n"
"       або:    %s [ПАРАМЕТР]\n"

#: src/timeout.c:239
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr ""
"Запустити КОМАНДУ і завершити її роботу, якщо її не буде завершено протягом "
"часу ТРИВАЛІСТЬ.\n"

#: src/timeout.c:245
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                   command times out\n"
"      --foreground\n"
"                 when not running timeout directly from a shell prompt,\n"
"                   allow COMMAND to read from the TTY and get TTY signals;\n"
"                   in this mode, children of COMMAND will not be timed out\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                   this long after the initial signal was sent\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout;\n"
"                   SIGNAL may be a name like 'HUP' or a number;\n"
"                   see 'kill -l' for a list of signals\n"
msgstr ""
"      --preserve-status\n"
"                 вийти зі станом рівним стану КОМАНДИ, навіть якщо час\n"
"                 час очікування на завершення команди перевищено\n"
"      --foreground\n"
"                 Якщо timeout не запущено безпосередньо з командної "
"оболонки,\n"
"                 надати змогу КОМАНДІ читати дані з TTY і отримувати сигнали "
"TTY.\n"
"                 У цьому режимі дочірні процеси КОМАНДИ не підлягатимуть "
"обмеженню\n"
"                 часу очікування на завершення.\n"
"  -k, --kill-after=ТРИВАЛІСТЬ\n"
"                 надсилати сигнал KILL, якщо КОМАНДА не завершила роботу\n"
"                 протягом вказаного часу з надсилання початкового сигналу.\n"
"  -s, --signal=СИГНАЛ\n"
"                 вказати сигнал, який слід надсилати у разі перевищення "
"часу\n"
"                 очікування.\n"
"                 СИГНАЛом може бути назва, наприклад HUP, або число.\n"
"                 Переглянути список сигналів можна за допомогою команди\n"
"                 «kill -l»\n"

#: src/timeout.c:260
msgid "  -v, --verbose  diagnose to stderr any signal sent upon timeout\n"
msgstr ""
"  -v, --verbose  виводити до stderr діагностику щодо усіх сигналів, "
"надісланих до завершення часу очікування\n"

#: src/timeout.c:266
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
"A duration of 0 disables the associated timeout.\n"
msgstr ""
"\n"
"ТРИВАЛІСТЬ — число з рухомою крапкою з додатковим суфіксом:\n"
"«s» — секунди (типовий), «m» — хвилини, «h» — години або «d» — дні.\n"
"Тривалість, яка дорівнює 0, вимикає пов'язаний із нею час очікування.\n"

#: src/timeout.c:271
msgid ""
"\n"
"If the command times out, and --preserve-status is not set, then exit with\n"
"status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n"
"is specified, send the TERM signal upon timeout.  The TERM signal kills\n"
"any process that does not block or catch that signal.  It may be necessary\n"
"to use the KILL (9) signal, since this signal cannot be caught, in which\n"
"case the exit status is 128+9 rather than 124.\n"
msgstr ""
"\n"
"Якщо час очікування на завершення команди буде перевищено, і не вказано\n"
"--preserve-status, вийти з кодом стану 124. Якщо цього не відбудеться,\n"
"вийти з кодом стану КОМАНДИ. Якщо сигналу не вказано, надіслати сигнал TERM\n"
"після перевищення часу очікування. Сигнал TERM перерве виконання будь-яких\n"
"процесів, які не блокують і не перехоплюють цей сигнал. Іншим\n"
"процесам слід насилати сигнал KILL (9), оскільки цей сигнал не може\n"
"бути перехоплено. Якщо надіслано сигнал KILL (9), станом виходу буде\n"
"128+9, а не 124.\n"

#: src/timeout.c:346 src/timeout.c:403
#, c-format
msgid "warning: sigprocmask"
msgstr "попередження: sigprocmask"

#: src/timeout.c:425
#, c-format
msgid "warning: disabling core dumps failed"
msgstr "попередження: спроба вимикання дампів ядра завершилася невдало"

#: src/timeout.c:544
#, c-format
msgid "error waiting for command"
msgstr "помилка під час очікування на команду"

#: src/timeout.c:555
#, c-format
msgid "the monitored command dumped core"
msgstr ""
"команда, за якою виконувалося спостереження, завершила роботу критичною "
"помилкою"

#: src/timeout.c:568
#, c-format
msgid "unknown status from command (%d)"
msgstr "невідомий стан завершення від команди (%d)"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:310
#, c-format
msgid "invalid date format %s"
msgstr "неправильний формат дати %s"

#: src/touch.c:192
#, c-format
msgid "cannot touch %s"
msgstr "не вдалося виконати touch для %s"

#: src/touch.c:198
#, c-format
msgid "setting times of %s"
msgstr "встановлення тимчасових позначок %s"

#: src/touch.c:214
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""
"Оновити час доступу та час зміни кожного ФАЙЛА до поточної позначки часу.\n"
"\n"
"Якщо ФАЙЛа у аргументі не існує і не вказано -c або -h, його буде створено\n"
"порожнім.\n"
"\n"
"Якщо у аргументі ФАЙЛ вказано символ -, він обробляється особливим чином\n"
"та призводить до зміни позначки часу для файла, пов'язаного зі стандартним\n"
"виведенням даних.\n"

#: src/touch.c:226
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a                     змінювати лише час доступу\n"
"  -c, --no-create        не створювати файлів\n"
"  -d, --date=РЯДОК       проаналізувати РЯДОК і використовувати його\n"
"                          замість поточного часу\n"
"  -f                     (ігнорується)\n"

#: src/touch.c:232
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference   впливає на символічне посилання, а не на файл,\n"
"                         на який вказує (діє лише на системі з підтримкою\n"
"                         зміни часових позначок символічних посилань)\n"
"  -m                     змірити лише час внесення змін\n"

#: src/touch.c:238
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=ФАЙЛ   використовувати час ФАЙЛА замість поточного\n"
"  -t Час                 використовувати [[ВВ]РР]ММДДггхх[.сс] замість\n"
"                           поточного часу\n"
"  --time=СЛОВО           змінити вказаний час:\n"
"                          СЛОВО access, atime, use еквівалентно -a\n"
"                          СЛОВО modify, mtime еквівалентно -m\n"

#: src/touch.c:247
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"Зауважте, що ключі -d та -t сприймають різні формати дати та часу.\n"

#: src/touch.c:336
#, c-format
msgid "cannot specify times from more than one source"
msgstr "не вдалося вказати час з кількох джерел"

#: src/touch.c:410
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"попередження: 'touch %s' застарів; використовуйте 'touch -t %04ld%02d%02d%02d"
"%02d.%02d'"

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Використання: %s [КЛЮЧ]... НАБІР1 [НАБІР2]\n"

#: src/tr.c:291
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each sequence of a repeated character\n"
"                            that is listed in the last specified SET,\n"
"                            with a single occurrence of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Перетворює, ущільнює та/або вилучає символи зі стандартного введення і\n"
"виводить їх до стандартного виведення.\n"
"\n"
"  -c, -C, --complement    спочатку отримати доповнення ТАБЛИЦІ1\n"
"  -d, --delete            вилучати знаки з ТАБЛИЦІ1, не перетворювати\n"
"  -s, --squeeze-repeats   заміщати послідовності знаків, що повторюються, з\n"
"                           перелічених у останній ТАБЛИЦІ, на єдиний такий "
"знак\n"
"  -t, --truncate-set1     спочатку вкоротити ТАБЛИЦЮ1 до розміру ТАБЛИЦІ2\n"

#: src/tr.c:304
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"ТАБЛИЦі вказуються як символьні рядки.  У багатьох випадках символи\n"
"представляють самі себе.  Приймаються наступні послідовності:\n"
"\n"
"  \\ННН            знак з вісімковим кодом ННН (від 1 до 3 цифр)\n"
"  \\\\              зворотна похила риска\n"
"  \\a              звуковий сигнал\n"
"  \\b              забиття\n"
"  \\f              переведення сторінки\n"
"  \\n              новий рядок\n"
"  \\r              переведення каретки\n"
"  \\t              горизонтальна табуляція\n"

#: src/tr.c:318
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              вертикальна табуляція\n"
"  ЗНАК1-ЗНАК2     всі знаки від ЗНАК1 до ЗНАК2 у порядку зростання\n"
"  [ЗНАК*]         ЗНАК заповнює ТАБЛИЦЮ2 до довжини ТАБЛИЦІ1\n"
"  [ЗНАК*ЧИСЛО]    вказане ЧИСЛО однакових ЗНАКІВ; ЧИСЛО вісімкових, якщо\n"
"                  починається з 0\n"
"  [:alnum:]       всі літери та цифри\n"
"  [:alpha:]       всі літери\n"
"  [:blank:]       всі горизонтальні пробільні символи\n"
"  [:cntrl:]       всі керівні знаки\n"
"  [:digit:]       всі цифри\n"

#: src/tr.c:329
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       всі друковані знаки, за винятком пробілу\n"
"  [:lower:]       всі маленькі літери\n"
"  [:print:]       всі друковані знаки, включно з пробілом\n"
"  [:punct:]       всі знаки пунктуації\n"
"  [:space:]       всі вертикальні або горизонтальні пробільні знаки\n"
"  [:upper:]       всі великі літери\n"
"  [:xdigit:]      всі шістнадцяткові цифри\n"
"  [=ЗНАК=]        всі знаки, еквівалентні ЗНАКУ\n"

#: src/tr.c:339
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses the last\n"
"specified SET, and occurs after translation or deletion.\n"
msgstr ""
"\n"
"Перетворення виконується, якщо не вказано -d і обох таблиць, ТАБЛИЦІ1\n"
"і ТАБЛИЦІ2. -t можна використовувати лише під час перетворення.\n"
"Якщо потрібно, ТАБЛИЦЮ2 буде розширено до розмірів ТАБЛИЦІ1\n"
"повторенням останнього символу. Зайві символи ТАБЛИЦІ2 буде пропущено.\n"
"Гарантовано розширюються у порядку зростання лише [:lower:] і [:upper:].\n"
"Використані у ТАБЛИЦІ2 під час перетворення символи можна використовувати\n"
"для визначення перетворення регістру лише у парах. -s використовує останню\n"
"вказану таблицю. Ущільнення відбувається після перетворення або\n"
"вилучення.\n"

#: src/tr.c:507
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"попередження: неоднозначна вісімкова послідовність \\%c%c%c трактується\n"
"як двобайтова послідовність \\0%c%c, %c"

#: src/tr.c:516
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr ""
"попередження: неекранована зворотна похила риска наприкінці формату не є "
"переносимою"

#: src/tr.c:666
#, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr "неправильний порядок меж діапазону '%s-%s'"

#: src/tr.c:812
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "неправильно вказана кількість повторів %s у конструкції [c*n]"

#: src/tr.c:888
#, c-format
msgid "missing character class name '[::]'"
msgstr "пропущено назву класу знаків '[::]'"

#: src/tr.c:891
#, c-format
msgid "missing equivalence class character '[==]'"
msgstr "пропущений знак класу еквівалентності '[==]'"

#: src/tr.c:906
#, c-format
msgid "invalid character class %s"
msgstr "неправильний клас знаків %s"

#: src/tr.c:925
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: потрібно вказати один символ, що визначає клас еквівалентних йому"

#: src/tr.c:1205
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "непарні конструкції [:upper:] та/або [:lower:]"

#: src/tr.c:1309
msgid "too many characters in set"
msgstr "надто багато знаків у таблиці"

#: src/tr.c:1393
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr ""
"якщо під час перетворення рядок1 буде довшим за рядок2,\n"
"останній рядок не повинен завершуватися класом символів"

#: src/tr.c:1449
msgid "the [c*] repeat construct may not appear in string1"
msgstr "конструкція [c*] не може використовуватись у ТАБЛИЦІ1"

#: src/tr.c:1459
msgid "only one [c*] repeat construct may appear in string2"
msgstr "у ТАБЛИЦІ2 може використовуватись лише одна конструкція [c*]"

#: src/tr.c:1467
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "вираз [=c=] не може використовуватись у ТАБЛИЦІ2 при перетворенні"

#: src/tr.c:1474
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""
"при перетворенні, у ТАБЛИЦІ2 можуть використовуватись лише\n"
"класи 'upper' та 'lower'"

#: src/tr.c:1489
msgid "when not truncating set1, string2 must be non-empty"
msgstr ""
"якщо частина таблиці1 не відкидається, таблиця2 не повинна бути порожньою"

#: src/tr.c:1498
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"при перетворенні з доповненням класів символів, ТАБЛИЦЯ2 повинна\n"
"ставити у відповідність всім символам доповнення рівно один символ"

#: src/tr.c:1507
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""
"конструкція [c*] може використовуватись у ТАБЛИЦІ2 лише при перетворенні"

#: src/tr.c:1759
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr "При вилученні і ущільненні повторів слід вказати два рядки."

#: src/tr.c:1761
msgid "Two strings must be given when translating."
msgstr "При перетворенні потрібно вказати дві таблиці."

#: src/tr.c:1771
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr ""
"При вилученні без ущільнення повторів можна вказати дві лише одну таблицю."

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [ аргументи командного рядка, що ігноруються ]\n"
"       або:    %s КЛЮЧ\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "Завершення з успішним статусом."

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "Завершення роботи з кодом стану, що відповідає невдалому виконанню."

#: src/truncate.c:70
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "Використання: %s ПАРАМЕТР... ФАЙЛ...\n"

#: src/truncate.c:71
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the sparse extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""
"Зменшити або збільшити розмір кожного ФАЙЛа до вказаного значення\n"
"\n"
"Якщо ФАЙЛа не існує, його буде створено.\n"
"\n"
"Якщо розмір ФАЙЛа перевищуватиме вказаний, додаткові дані буде втрачено.\n"
"Якщо розмір ФАЙЛа буде меншим, його буде збільшено. Додаткову частину\n"
"буде заповнено нульовими байтами.\n"

#: src/truncate.c:83
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create        не створювати файлів\n"

#: src/truncate.c:86
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr ""
"  -o, --io-blocks        вважати РОЗМІР кількістю блоків введення-вивадення, "
"а не байтів\n"

#: src/truncate.c:89
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE bytes\n"
msgstr ""
"  -r, --reference=RФАЙЛ  основний розмір RФАЙЛА\n"
"  -s, --size=РОЗМІР      встановити або змінити розмір файла, відповідно до "
"РОЗМІР\n"

#: src/truncate.c:95
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""
"\n"
"Перед РОЗМІРом може бути додано один з таких символів-модифікаторів:\n"
"«+» — розширити, «-» — звузити, «<» — не більше, «>» — не менше,\n"
"«/» — зменшити до кратного, «%» — збільшити до кратного.\n"

#: src/truncate.c:124
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdPTR> byte blocks for file %s"
msgstr "переповнення у %<PRIdMAX> * %<PRIdPTR> байтових блоків для файла %s"

#: src/truncate.c:145
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s має непридатний, ймовірно від'ємний розмір"

#: src/truncate.c:155 src/truncate.c:348
#, c-format
msgid "cannot get the size of %s"
msgstr "не вдалося визначити розмір %s"

#: src/truncate.c:179
#, c-format
msgid "overflow extending size of file %s"
msgstr "переповнення під час розширення розміру файла %s"

#: src/truncate.c:193
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "не вдалося обрізати %s до %<PRIdMAX> байтів"

#: src/truncate.c:266
#, c-format
msgid "multiple relative modifiers specified"
msgstr "вказано декілька відносних модифікаторів"

#: src/truncate.c:275
msgid "Invalid number"
msgstr "Некоректне число"

#: src/truncate.c:297
#, c-format
msgid "you must specify either %s or %s"
msgstr "можна визначити лише щось одне: %s або %s"

#: src/truncate.c:304
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "вам слід вказати відносний %s з %s"

#: src/truncate.c:311
#, c-format
msgid "%s was specified but %s was not"
msgstr "вказано %s, але без %s"

#: src/truncate.c:368
#, c-format
msgid "cannot open %s for writing"
msgstr "не вдалося відкрити %s для запису"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:40
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:82
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
msgstr ""
"Користування: %s [ПАРАМЕТР] [ФАЙЛ]\n"
"Вивести повністю упорядкований список, узгоджений із частковим "
"упорядковуванням у ФАЙЛі.\n"

#: src/tsort.c:89 src/uptime.c:213
#, c-format
msgid "\n"
msgstr "\n"

#: src/tsort.c:475
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s: на вході міститься непарна кількість лексем"

#: src/tsort.c:521
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: на вході міститься цикл:"

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"Виводить назву файла для терміналу, що приєднаний до стандартному вводу.\n"
"\n"
"  -s, --silent, --quiet   не виводити, лише повернути код завершення\n"

#: src/tty.c:127
msgid "not a tty"
msgstr "не tty"

#: src/uname.c:125
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"Виводить певні відомості про систему.  Якщо КЛЮЧ не вказаний,\n"
"вважається -s.\n"
"\n"
"  -a, --all                вивести всю інформацію, у наступному порядку,\n"
"                            крім -p та -i, якщо вони невідомі:\n"
"  -s, --kernel-name        вивести назву ядра\n"
"  -n, --nodename           вивести назву машини у мережі\n"
"  -r, --release            вивести номер випуску операційної системи\n"

#: src/uname.c:134
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type (non-portable)\n"
"  -i, --hardware-platform  print the hardware platform (non-portable)\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     вивести версію ядра\n"
"  -m, --machine            вивести тип обладнання машини\n"
"  -p, --processor          вивести тип процесора (непридатне до портування)\n"
"  -i, --hardware-platform  вивести тип апаратної платформи (непридатне до "
"портування)\n"
"  -o, --operating-system   вивести назву операційної системи\n"

#: src/uname.c:144
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"Вивести архітектуру машини.\n"
"\n"

#: src/uname.c:287
msgid "cannot get system name"
msgstr "не вдалося дізнатись назву системи"

#: src/unexpand.c:82
msgid "Convert blanks in each FILE to tabs, writing to standard output.\n"
msgstr ""
"Перетворити пробіли у кожному ФАЙЛі на табуляції, вивести результат до "
"стандартного виведення.\n"

#: src/unexpand.c:89
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
msgstr ""
"  -a, --all         перетворювати всі пробільні знаки, а не лише початкові\n"
"      --first-only  перетворювати лише початкові пробільні знаки\n"
"                      (має вищий пріоритет за -a)\n"
"  -t, --tabs=ЧИСЛО  вживати табуляцію вказаної ширини, а не 8 (включає -a)\n"

#: src/unexpand.c:306
msgid "tab stop value is too large"
msgstr "розмір табуляції надто великий"

#: src/uniq.c:166
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Використання: %s [КЛЮЧ]... [ВХІД [ВИХІД]]\n"

#: src/uniq.c:170
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""
"Фільтрує сусідні відповідні рядків з ВХОДУ (або стандартного введення),\n"
"з записом до ВИХОДУ (або стандартного виведення).\n"
"\n"
"Якщо не вказано параметрів, відповідні рядки об'єднуються з рядками,\n"
"виявленими першими.\n"

#: src/uniq.c:179
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines, one for each group\n"
msgstr ""
"  -c, --count           виводити число повторів на початку кожного рядка\n"
"  -d, --repeated        виводити лише рядки, що повторюються, один для "
"кожної з груп\n"

#: src/uniq.c:183
msgid ""
"  -D                    print all duplicate lines\n"
"      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
"                                 with an empty line;\n"
"                                 METHOD={none(default),prepend,separate}\n"
msgstr ""
"  -D                    вивести усі рядки-дублікати\n"
"      --all-repeated[=СПОСІБ]  подібно до -D, але уможливити відокремлення\n"
"                                 груп порожнім рядком;\n"
"                                 СПОСІБ={none(типовий),prepend(перед),"
"separate(окремо)}\n"

#: src/uniq.c:189
msgid "  -f, --skip-fields=N   avoid comparing the first N fields\n"
msgstr "  -f, --skip-fields=N   уникати порівняння перших N полів\n"

#: src/uniq.c:192
msgid ""
"      --group[=METHOD]  show all items, separating groups with an empty "
"line;\n"
"                          METHOD={separate(default),prepend,append,both}\n"
msgstr ""
"      --group[=МЕТОД]   показати усі запис, відокремивши групи порожніми "
"рядками;\n"
"                          МЕТОД={separate(типовий),prepend,append,both}\n"

#: src/uniq.c:196
msgid ""
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -i, --ignore-case     ігнорувати при порівнянні регістр\n"
"  -s, --skip-chars=Н    не порівнювати перші Н знаків\n"
"  -u, --unique          виводити лише рядки, що не повторюються\n"

#: src/uniq.c:204
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=Н   порівнювати перші Н знаків рядків\n"

#: src/uniq.c:209
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"Полем вважається послідовність пробільних знаків, за якою\n"
"йдуть не пробільні знаки. Спочатку пропускаються поля, потім символи.\n"

#: src/uniq.c:214
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
msgstr ""
"\n"
"Зауваження: uniq не зможе визначити повторених рядків, якщо ці рядки не є\n"
"сусідніми. Вам варто спочатку впорядкувати вхідні дані, або скористатися\n"
"«sort -u» замість uniq.\n"

#: src/uniq.c:425
msgid "too many repeated lines"
msgstr "надто багато рядків, що повторюються"

#: src/uniq.c:600
msgid "invalid number of fields to skip"
msgstr "неправильна кількість полів, що пропускаються"

#: src/uniq.c:609
msgid "invalid number of bytes to skip"
msgstr "неправильна кількість байт, що пропускаються"

#: src/uniq.c:619
msgid "invalid number of bytes to compare"
msgstr "неправильна кількість байт, що порівнюються"

#: src/uniq.c:641
#, c-format
msgid "--group is mutually exclusive with -c/-d/-D/-u"
msgstr "--group не можна використовувати разом з -c/-d/-D/-u"

#: src/uniq.c:648
#, c-format
msgid "grouping and printing repeat counts is meaningless"
msgstr "одночасне групування і виведення даних щодо повторів не має сенсу"

#: src/uniq.c:655
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "вивід усіх рядків, що повторюються та числа повторів не має сенсу"

#: src/unlink.c:45
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s ФАЙЛ\n"
"       або:    %s КЛЮЧ\n"

#: src/unlink.c:48
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"Викликає функцію unlink для вилучення вказаного ФАЙЛА.\n"
"\n"

#: src/uptime.c:126
msgid "couldn't get boot time"
msgstr "не вдалося дізнатись час початкового завантаження"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:137
msgid " %H:%M:%S  "
msgstr " %H:%M:%S  "

#: src/uptime.c:139
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:141
#, c-format
msgid "up ???? days ??:??,  "
msgstr "???? днів ??:??,  "

#: src/uptime.c:145
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "%ld день %2d:%02d,  "
msgstr[1] "%ld дні %2d:%02d,  "
msgstr[2] "%ld днів %2d:%02d,  "

#: src/uptime.c:150
#, c-format
msgid "up  %2d:%02d,  "
msgstr "%2d:%02d,  "

#: src/uptime.c:152
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu користувач"
msgstr[1] "%lu користувачі"
msgstr[2] "%lu користувачів"

#: src/uptime.c:162
#, c-format
msgid ",  load average: %.2f"
msgstr ", середня завантаженість: %.2f"

#: src/uptime.c:200
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"Виводить поточний час, час безперервної роботи системи, кількість\n"
"користувачів у системі та середнє число завдань у черзі запуску за\n"
"останні 1, 5 та 15 хвилин."

#: src/uptime.c:209
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr ""
"  Процеси у\n"
"стані неперервного сну також впливають на середнє завантаження.\n"

#: src/uptime.c:215
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Якщо ФАЙЛ не вказано, використовується %s.  Часто замість ФАЙЛ\n"
"вказують %s.\n"
"\n"

#: src/users.c:106
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Виводить список підключених користувачів відповідно до ФАЙЛА.\n"
"Якщо ФАЙЛ не вказаний, використовується %s.  Часто у якості ФАЙЛА\n"
"вказують %s.\n"
"\n"

#: src/wc.c:123
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  A word is a non-zero-length sequence of\n"
"characters delimited by white space.\n"
msgstr ""
"Вивести дані щодо кількості розривів рядків, слів та байтів для кожного з "
"ФАЙЛів і\n"
"рядок сумарних даних, якщо вказано декілька файлів. Словом вважається "
"ненульової\n"
"довжини послідовність символів символів обмежена пробілами.\n"

#: src/wc.c:131
msgid ""
"\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"\n"
"За допомогою вказаних нижче параметрів можна вибрати дані, які\n"
"буде виведено. Порядок буде завжди таким: розриви рядків,\n"
"слова, символи, байти, максимальна довжина рядка.\n"
"  -c, --bytes            вивести кількість байт\n"
"  -m, --chars            вивести кількість знаків\n"
"  -l, --lines            вивести кількість розривів рядків\n"

#: src/wc.c:139
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the maximum display width\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=F    читати вхідні дані з файлів, вказаних\n"
"                           назвами зі списку, розділеного символами\n"
"                           NUL у файлі F. Якщо F дорівнює «-», назви\n"
"                           буде прочитано зі стандартного джерела даних\n"
"  -L, --max-line-length  вивести максимальну ширину виведення\n"
"  -w, --words            вивести кількість слів\n"

#: src/who.c:213
msgid " old "
msgstr "давно"

#: src/who.c:443
msgid "system boot"
msgstr "завантаження системи"

#: src/who.c:451 src/who.c:453
msgid "id="
msgstr "id="

#: src/who.c:466 src/who.c:471
msgid "term="
msgstr "термінал="

#: src/who.c:468 src/who.c:472
msgid "exit="
msgstr "вихід="

#: src/who.c:489
msgid "LOGIN"
msgstr "ВХІД"

#: src/who.c:509
msgid "clock change"
msgstr "зміна часу"

#: src/who.c:521 src/who.c:522
msgid "run-level"
msgstr "рівень виконання"

#: src/who.c:525 src/who.c:526
msgid "last="
msgstr "попередній="

#: src/who.c:557
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"число користувачів=%lu\n"

#: src/who.c:563
msgid "NAME"
msgstr "НАЗВА"

#: src/who.c:563
msgid "LINE"
msgstr "ЛІНІЯ"

#: src/who.c:563
msgid "TIME"
msgstr "Час"

#: src/who.c:563
msgid "IDLE"
msgstr "НЕАКТИВНИЙ"

#: src/who.c:564
msgid "PID"
msgstr "PID"

#: src/who.c:564
msgid "COMMENT"
msgstr "КОМЕНТАР"

#: src/who.c:564
msgid "EXIT"
msgstr "ВИХІД"

#: src/who.c:644
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "Використання: %s [КЛЮЧ]... [ ФАЙЛ | АРГ1 АРГ2]\n"

#: src/who.c:645
msgid "Print information about users who are currently logged in.\n"
msgstr "Вивести дані щодо користувачів, які працюють у системі.\n"

#: src/who.c:648
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all         еквівалент -b -d --login -p -r -t -T -u\n"
"  -b, --boot        час останнього звантаження системи\n"
"  -d, --dead        виводити мертві процеси\n"
"  -H, --heading     виводити рядок з заголовками стовпчиків\n"

#: src/who.c:655
msgid "  -l, --login       print system login processes\n"
msgstr "  -l, --login       виводити процеси входу у систему\n"

#: src/who.c:658
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup      намагатись канонізувати назви вузлів через DNS\n"
"  -m                лише назва вузлі та користувач, пов'язані з\n"
"                    стандартним вводом\n"
"  -p, --process     виводити активні процеси, які породжені init\n"

#: src/who.c:663
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       всі назви та кількість підключених користувачів\n"
"  -r, --runlevel    виводити поточний рівень виконання\n"
"  -s, --short       виводити лише назву, лінію та час (приймається типово)\n"
"  -t, --time        виводити останню зміна системного часу\n"

#: src/who.c:669
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    додавати статус отримання повідомлень як  +, - або ?\n"
"  -u, --users       перерахувати підключених користувачів\n"
"      --message     еквівалент -T\n"
"      --writable    еквівалент -T\n"

#: src/who.c:677
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""
"\n"
"Якщо ФАЙЛ не вказаний, використовується %s. Часто як ФАЙЛ вказують %s.\n"
"Якщо вказані АРГ1 та АРГ2, вважається використання -m: наприклад 'am i'\n"
"та 'mom likes'.\n"

#: src/whoami.c:45
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"Вивести ім'я користувача, що відповідає поточному ефективному id\n"
"користувача.  Аналогічно виклику id -un.\n"
"\n"

#: src/whoami.c:86
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "не вдалося визначити назву для ідентифікатора користувача %lu"

#: src/yes.c:41
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Використання: %s [РЯДОК]...\n"
"       або:    %s КЛЮЧ\n"

#: src/yes.c:47
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
"Безперервно виводити вказаний РЯДОК (РЯДКИ) або, якщо РЯДОК не вказано, "
"'y'.\n"
"\n"

#~ msgid "%s home page: <https://www.gnu.org/software/%s/>\n"
#~ msgstr "Домашня сторінка %s: <https://www.gnu.org/software/%s/>\n"

#~ msgid ""
#~ "CAUTION: Note that shred relies on a very important assumption:\n"
#~ "that the file system overwrites data in place.  This is the traditional\n"
#~ "way to do things, but many modern file system designs do not satisfy "
#~ "this\n"
#~ "assumption.  The following are examples of file systems on which shred "
#~ "is\n"
#~ "not effective, or is not guaranteed to be effective in all file system "
#~ "modes:\n"
#~ "\n"
#~ msgstr ""
#~ "УВАГА: Пам'ятайте, що shred покладається на дуже важливе припущення:\n"
#~ "що ваша файлова система перезаписує файли \"на місці\".\n"
#~ "Зазвичай це так, але багато сучасних файлових системи\n"
#~ "не задовольняють цьому припущенню.  Ось приклади файлових систем, на\n"
#~ "яких shred не ефективний або не дає гарантії ефективності в усіх\n"
#~ "режимах файлової системи:\n"
#~ "\n"

#~ msgid ""
#~ "* log-structured or journaled file systems, such as those supplied with\n"
#~ "AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
#~ "\n"
#~ "* file systems that write redundant data and carry on even if some "
#~ "writes\n"
#~ "fail, such as RAID-based file systems\n"
#~ "\n"
#~ "* file systems that make snapshots, such as Network Appliance's NFS "
#~ "server\n"
#~ "\n"
#~ msgstr ""
#~ "* файлові системи з журналом, наприклад які йдуть у комплекті\n"
#~ "  AIX та Solaris (та JFS, ReiserFS, XFS, Ext3 та ін.)\n"
#~ "\n"
#~ "* файлові системи, які записують надлишкові дані та зберігають\n"
#~ "  працездатність навіть якщо виникають невдалі записи, наприклад\n"
#~ "  файлові системи, що побудовані на технології RAID\n"
#~ "\n"
#~ "* файлові системи, які створюють копії стану, наприклад\n"
#~ "  NFS-сервер від Network Appliance\n"
#~ "\n"

#~ msgid ""
#~ "* file systems that cache in temporary locations, such as NFS\n"
#~ "version 3 clients\n"
#~ "\n"
#~ "* compressed file systems\n"
#~ "\n"
#~ msgstr ""
#~ "* файлові системи, які кешують файли у тимчасових сховищах, наприклад \n"
#~ "  клієнти NFS версії 3\n"
#~ "\n"
#~ "* стиснені файлові системи\n"
#~ "\n"

#~ msgid ""
#~ "In the case of ext3 file systems, the above disclaimer applies\n"
#~ "(and shred is thus of limited effectiveness) only in data=journal mode,\n"
#~ "which journals file data in addition to just metadata.  In both the\n"
#~ "data=ordered (default) and data=writeback modes, shred works as usual.\n"
#~ "Ext3 journaling modes can be changed by adding the data=something option\n"
#~ "to the mount options for a particular file system in the /etc/fstab "
#~ "file,\n"
#~ "as documented in the mount man page (man mount).\n"
#~ "\n"
#~ msgstr ""
#~ "В випадку файлових систем ext3 наведене вище обмеження вірне (тож,\n"
#~ "shred не такий ефективний), лише у режимі\n"
#~ "data=journal, коли окрім метаданих у журнал заносяться також самі дані\n"
#~ "файлів.  В режимах data=ordered (типово) та data=writeback\n"
#~ "програма shred працює у звичайному режимі.  Режими журналу ext3 можна\n"
#~ "змінити, додавши ключ data=щось до параметрів підключення\n"
#~ "конкретної файлової системи у файлі /etc/fstab, згідно документації на\n"
#~ "сторінці man для mount (man mount).\n"

#~ msgid ""
#~ "In addition, file system backups and remote mirrors may contain copies\n"
#~ "of the file that cannot be removed, and that will allow a shredded file\n"
#~ "to be recovered later.\n"
#~ msgstr ""
#~ "Окрім того, резервні копії та вилучені дзеркала файлової системи можуть\n"
#~ "містити копії файла, які не можна вилучити, і які пізніше надають змогу\n"
#~ "відновити знищений файл.\n"

#~ msgid "overflow rounding up size of file %s"
#~ msgstr "переповнення під час округлення розміру файла %s у бік збільшення"

#~ msgid ""
#~ "\n"
#~ "NUM may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ msgstr ""
#~ "\n"
#~ "Після ЧИСЛА блоків та байт може стоять один з множників:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"

#~ msgid "Usage: %s [OPTION]... [USER]\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]\n"

#~ msgid "%s: option '--%s' doesn't allow an argument\n"
#~ msgstr "%s: додавання аргументів до параметра «--%s» не передбачено\n"

#~ msgid "%s: unrecognized option '--%s'\n"
#~ msgstr "%s: невідомий параметр «--%s»\n"

#~ msgid "%s: option '-W %s' is ambiguous\n"
#~ msgstr "%s: параметр «-W %s» не є однозначним\n"

#~ msgid "%s: option '-W %s' doesn't allow an argument\n"
#~ msgstr "%s: додавання аргументів до параметра «-W %s» не передбачено\n"

#~ msgid "%s: option '-W %s' requires an argument\n"
#~ msgstr "%s: до параметра «-W %s» слід додати аргумент\n"

#~ msgid "Infinity B"
#~ msgstr "Нескінченість"

#~ msgid "syntax error"
#~ msgstr "синтаксична помилка"

#~ msgid ""
#~ "      --time-style=STYLE     with -l, show times using style STYLE:\n"
#~ "                               full-iso, long-iso, iso, locale, or "
#~ "+FORMAT;\n"
#~ "                               FORMAT is interpreted like in 'date'; if "
#~ "FORMAT\n"
#~ "                               is FORMAT1<newline>FORMAT2, then FORMAT1 "
#~ "applies\n"
#~ "                               to non-recent files and FORMAT2 to recent "
#~ "files;\n"
#~ "                               if STYLE is prefixed with 'posix-', STYLE\n"
#~ "                               takes effect only outside the POSIX "
#~ "locale\n"
#~ msgstr ""
#~ "      --time-style=СТИЛЬ     з -l, виводити час використовуючи СТИЛЬ:\n"
#~ "                             full-iso, long-iso, iso, locale, +ФОРМАТ.\n"
#~ "                             ФОРМАТ інтерпретується як у 'date'; якщо\n"
#~ "                             ФОРМАТ - це ФОРМАТ1<переведення-"
#~ "рядка>ФОРМАТ2,\n"
#~ "                             ФОРМАТ1 застосовується до старих файлів, а\n"
#~ "                             ФОРМАТ2 до нових; якщо до СТИЛЮ доданий "
#~ "префікс\n"
#~ "                             'posix-', то він діє лише не у POSIX локалі\n"

#~ msgid "failed to set the copy of stderr to close on exec"
#~ msgstr ""
#~ "не вдалося зробити так, щоб копія стандартного потоку помилок закрилась "
#~ "на початку виконання"

#~ msgid "failed to set locale; "
#~ msgstr "не вдалося встановити локаль; "

#~ msgid "error monitoring inotify event"
#~ msgstr "помилка під час стеження за подією inotify"

#~ msgid "stdin"
#~ msgstr "stdin"

#~ msgid "stdout"
#~ msgstr "stdout"

#~ msgid "stderr"
#~ msgstr "stderr"

#~ msgid "unknown stream"
#~ msgstr "невідомий потік"

#~ msgid "failed to reopen %s with mode %s"
#~ msgstr "не вдалося повторно відкрити %s у режимі %s"

#~ msgid "error initializing month strings"
#~ msgstr "помилка під час ініціалізації рядків місяців"

#~ msgid "%s has been replaced with a symbolic link. giving up on this name"
#~ msgstr ""
#~ "%s було замінено символічним посиланням. Кінець виводу для цієї назви"

#~ msgid "%s has been replaced with a remote file. giving up on this name"
#~ msgstr "%s було замінено віддаленим файлом. Кінець виводу для цієї назви"

#~ msgid "empty %s not allowed"
#~ msgstr "порожній рядок %s є неприпустимим"

#~ msgid "  nocache   discard cached data\n"
#~ msgstr "  nocache   відкинути кешовані дані\n"

#~ msgid ", %g s, %s/s\n"
#~ msgstr ", %g с, %s/s\n"

#~ msgid ", %.6f s, %s/s"
#~ msgstr ", %.6f с, %s/с"

#~ msgid ""
#~ "\n"
#~ "If the first character of K (the number of bytes or lines) is a '+',\n"
#~ "print beginning with the Kth item from the start of each file, "
#~ "otherwise,\n"
#~ "print the last K items in the file.  K may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо першим символом у Н (числі байт або рядків) є «+», виведення буде\n"
#~ "розпочато з Н-ого елемента від початку кожного файла, інакше буде\n"
#~ "виведено останні Н елементи. Н може мати суфікс-множник: b 512, kB 1000, "
#~ "K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024 тощо для T, P, E, Z, Y.\n"
#~ "\n"

#~ msgid ""
#~ "unrecognized file system type 0x%08lx for %s. please report this to %s. "
#~ "reverting to polling"
#~ msgstr ""
#~ "Нерозпізнаний тип файлової системи 0x%08lx для %s. Будь ласка, повідомте "
#~ "про нього до %s. Повертаємося до простого опитування."

#~ msgid "failed to %s supplemental groups"
#~ msgstr "не вдалося %s список додаткових груп"

#~ msgid "%s: invalid number"
#~ msgstr "%s: неприпустимий число"

#~ msgid ""
#~ "\n"
#~ "Sending a %s signal to a running 'dd' process makes it\n"
#~ "print I/O statistics to standard error and then resume copying.\n"
#~ "\n"
#~ "  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
#~ "  $ kill -%s $pid; sleep 1; kill $pid\n"
#~ "  18335302+0 records in\n"
#~ "  18335302+0 records out\n"
#~ "  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
#~ "\n"
#~ "Options are:\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо надіслати запущеному процесу 'dd' сигнал %s, він виведе на\n"
#~ "стандартний потік помилок статистику вводу/виводу та продовжить\n"
#~ "копіювання.\n"
#~ "\n"
#~ "  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
#~ "  $ kill -%s $pid; sleep 1; kill $pid\n"
#~ "  18335302+0 вхідних записів\n"
#~ "  18335302+0 вихідних записів\n"
#~ "  9387674624 байта (9.4 GB) скопійовано, 34.6279 секунди, 271 Мб/с\n"
#~ "\n"
#~ "Ключі:\n"
#~ "\n"

#~ msgid "%s: %s is so large that it is not representable"
#~ msgstr "%s: %s настільки великий, що його неможливо машинно представити"

#~ msgid "number of lines"
#~ msgstr "число рядків"

#~ msgid "number of bytes"
#~ msgstr "число байт"

#~ msgid "%s: invalid number to ignore"
#~ msgstr "%s: некоректне число для виключення"

#~ msgid "input line is too short, no numbers found to convert in field %ld"
#~ msgstr ""
#~ "надто короткий рядок вхідних даних, у полі %ld не виявлено чисел для "
#~ "форматування"

#~ msgid ""
#~ "\n"
#~ "-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when FILE is -, "
#~ "read\n"
#~ "standard input.\n"
#~ msgstr ""
#~ "\n"
#~ "додається -t, якщо PAGE_LENGTH <= 10. Якщо ФАЙЛ не вказано\n"
#~ "або вказаний як -, читає стандартне джерело введення.\n"

#~ msgid ""
#~ "\n"
#~ "With no FILE, or when FILE is -, read standard input.  Default is '-"
#~ "F /'.\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо вхідний файл не вказаний, або якщо вказано символ -,\n"
#~ "використовується стандартне джерело вхідних даних. Типовим є «-F /».\n"

#~ msgid "%s: invalid number of bytes"
#~ msgstr "%s: неправильна кількість байт"

#~ msgid "%s: invalid number of lines"
#~ msgstr "%s: неправильна кількість рядків"

#~ msgid ""
#~ " * lnext CHAR    CHAR will enter the next character quoted\n"
#~ "   quit CHAR     CHAR will send a quit signal\n"
#~ " * rprnt CHAR    CHAR will redraw the current line\n"
#~ "   start CHAR    CHAR will restart the output after stopping it\n"
#~ msgstr ""
#~ "* lnext СИМВОЛ    СИМВОЛ буде вводити наступний символ, скасовуючи його\n"
#~ "                  спеціальну дію\n"
#~ "  quit СИМВОЛ     СИМВОЛ буде надсилати сигнал виходу\n"
#~ "* rprnt СИМВОЛ    СИМВОЛ буде перерисовувати поточний рядок\n"
#~ "  start СИМВОЛ    СИМВОЛ буде відновлювати ввід\n"

#~ msgid ""
#~ "\n"
#~ "Control settings:\n"
#~ "   [-]clocal     disable modem control signals\n"
#~ "   [-]cread      allow input to be received\n"
#~ " * [-]crtscts    enable RTS/CTS handshaking\n"
#~ " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
#~ "   csN           set character size to N bits, N in [5..8]\n"
#~ msgstr ""
#~ "\n"
#~ "Параметри керування:\n"
#~ "   [-]clocal     скасувати керівні сигнали модему\n"
#~ "   [-]cread      дозволити ввід\n"
#~ " * [-]crtscts    дозволити керування потоком RTS/CTS\n"
#~ " * [-]cdtrdsr    дозволити керування потоком DTR/DSR\n"
#~ "   csН           встановити розмір символу рівним Н біт, Н від 5 до 8\n"

#~ msgid ""
#~ "\n"
#~ "Output settings:\n"
#~ " * bsN           backspace delay style, N in [0..1]\n"
#~ " * crN           carriage return delay style, N in [0..3]\n"
#~ " * ffN           form feed delay style, N in [0..1]\n"
#~ " * nlN           newline delay style, N in [0..1]\n"
#~ msgstr ""
#~ "\n"
#~ "Параметри виводу:\n"
#~ "* bsН           пауза після забою, діапазон Н [0..1]\n"
#~ "* crН           пауза після переведення каретки, діапазон Н [0..3]\n"
#~ "* ffН           пауза після переведення сторінки, діапазон Н [0..1]\n"
#~ "* nlН           пауза після нового рядка, діапазон Н [0..1]\n"

#~ msgid ""
#~ " * [-]ocrnl      translate carriage return to newline\n"
#~ " * [-]ofdel      use delete characters for fill instead of NUL "
#~ "characters\n"
#~ " * [-]ofill      use fill (padding) characters instead of timing for "
#~ "delays\n"
#~ " * [-]olcuc      translate lowercase characters to uppercase\n"
#~ " * [-]onlcr      translate newline to carriage return-newline\n"
#~ " * [-]onlret     newline performs a carriage return\n"
#~ msgstr ""
#~ "* [-]ocrnl      перетворювати переведення каретки у переведення рядка\n"
#~ "* [-]ofdel      заповнювати символами затирання замість нулів\n"
#~ "* [-]ofill      використовувати символи заповнення для затримок\n"
#~ "* [-]olcuc      перетворювати маленькі літери на великі\n"
#~ "* [-]onlcr      перетворювати переведення рядка у переведення каретки-"
#~ "розрив рядка\n"
#~ "* [-]onlret     переведення рядка призводить до переведення каретки\n"

#~ msgid ""
#~ " * [-]onocr      do not print carriage returns in the first column\n"
#~ "   [-]opost      postprocess output\n"
#~ " * tabN          horizontal tab delay style, N in [0..3]\n"
#~ " * tabs          same as tab0\n"
#~ " * -tabs         same as tab3\n"
#~ " * vtN           vertical tab delay style, N in [0..1]\n"
#~ msgstr ""
#~ "* [-]onocr      не виводити переведення каретки у першому стовпчику\n"
#~ "  [-]opost      форматувати вивід\n"
#~ "* tabН          значення паузи після горизонтальної табуляції,\n"
#~ "                допустимі Н [0..3]\n"
#~ "* tabs          синонім tab0\n"
#~ "* -tabs         синонім tab3\n"
#~ "* vtН           пауза після вертикальної табуляції, діапазон Н [0..1]\n"

#~ msgid ""
#~ " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
#~ "   [-]echo       echo input characters\n"
#~ " * [-]echoctl    same as [-]ctlecho\n"
#~ "   [-]echoe      same as [-]crterase\n"
#~ "   [-]echok      echo a newline after a kill character\n"
#~ msgstr ""
#~ "* [-]ctlecho    відображати керівні символи з шапкою ('^c')\n"
#~ "  [-]echo       відображати символи, що вводяться\n"
#~ "* [-]echoctl    синонім [-]ctlecho\n"
#~ "  [-]echoe      синонім [-]crterase\n"
#~ "  [-]echok      відображати переведення рядка після символу знищення\n"

#~ msgid ""
#~ " * [-]echoke     same as [-]crtkill\n"
#~ "   [-]echonl     echo newline even if not echoing other characters\n"
#~ " * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
#~ "   [-]icanon     enable erase, kill, werase, and rprnt special "
#~ "characters\n"
#~ "   [-]iexten     enable non-POSIX special characters\n"
#~ msgstr ""
#~ "* [-]echoke     синонім [-]crtkill\n"
#~ "  [-]echonl     відображати переведення рядка, навіть якщо інші символи "
#~ "не\n"
#~ "                відображаються\n"
#~ "* [-]echoprt    виводити стерті символи у зворотному порядку, між '\\' та "
#~ "'/'\n"
#~ "  [-]icanon     використовувати спецсимволи erase, kill, werase, та "
#~ "rprnt\n"
#~ "  [-]iexten     використовувати спецсимволи, не описані у стандарті "
#~ "POSIX\n"

#~ msgid ""
#~ "   dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
#~ "                 kill ^u\n"
#~ " * [-]decctlq    same as [-]ixany\n"
#~ "   ek            erase and kill characters to their default values\n"
#~ "   evenp         same as parenb -parodd cs7\n"
#~ msgstr ""
#~ "  dec           синонім echoe echoctl echoke -ixany intr ^c erase 0177\n"
#~ "                 kill ^u\n"
#~ "* [-]decctlq    синонім [-]ixany\n"
#~ "  ek            встановити типові значення для символів erase та kill\n"
#~ "  evenp         синонім parenb -parodd cs7\n"

#~ msgid ""
#~ "   -evenp        same as -parenb cs8\n"
#~ " * [-]lcase      same as xcase iuclc olcuc\n"
#~ "   litout        same as -parenb -istrip -opost cs8\n"
#~ "   -litout       same as parenb istrip opost cs7\n"
#~ "   nl            same as -icrnl -onlcr\n"
#~ "   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
#~ msgstr ""
#~ "  -evenp        синонім -parenb cs8\n"
#~ "* [-]lcase      синонім xcase iuclc olcuc\n"
#~ "  litout        синонім -parenb -istrip -opost cs8\n"
#~ "  -litout       синонім parenb istrip opost cs7\n"
#~ "  nl            синонім -icrnl -onlcr\n"
#~ "  -nl           синонім icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"

#~ msgid ""
#~ "Force changed blocks to disk, update the super block.\n"
#~ "\n"
#~ msgstr ""
#~ "Записує змінені блоки на диск, оновлює суперблок\n"
#~ "\n"

#~ msgid "ignoring all arguments"
#~ msgstr "всі аргументи проігноровані"

#~ msgid "For complete documentation, run: info coreutils '%s invocation'\n"
#~ msgstr ""
#~ "Ознайомитися з повною документацією можна за допомогою команди info "
#~ "coreutils '%s invocation'\n"

#~ msgid "number in %s is too large"
#~ msgstr "число у %s надто велике"

#~ msgid "%s: invalid number of seconds"
#~ msgstr "%s: неправильне число секунд"

#~ msgid "%s: cannot find name for user ID %lu\n"
#~ msgstr "%s: не вдалося визначити ім'я користувача для ID %lu\n"

#~ msgid "cannot create pipe"
#~ msgstr "не вдалося створити канал"

#~ msgid "%s subprocess failed"
#~ msgstr "помилка підпроцесу %s"

#~ msgid "_open_osfhandle failed"
#~ msgstr "Помилка _open_osfhandle"

#~ msgid "cannot restore fd %d: dup2 failed"
#~ msgstr "не вдалося відновити файловий дескриптор %d: помилка dup2"

#~ msgid "%s subprocess"
#~ msgstr "дочірній процес %s"

#~ msgid "%s subprocess got fatal signal %d"
#~ msgstr "дочірнім процесом %s отримано сигнал щодо аварійного завершення %d"

#~ msgid "failed to set additional groups"
#~ msgstr "не вдалося встановити додаткові групи"

#~ msgid "mount point %s already traversed"
#~ msgstr "обхід точки монтування %s вже здійснено"

#~ msgid "%s: cannot lseek back to original position"
#~ msgstr "ю%s: не вдалося вернуть вказівник файла на початкову позицію"

#~ msgid "%s: failed to reset file pointer"
#~ msgstr "%s: не вдалося скинути вказівник на файл"

#~ msgid "cannot reposition file pointer for %s"
#~ msgstr "не вдалося перемістити вказівник файла для %s"

#~ msgid ""
#~ "  -Z, --context[=CTX]  set the SELinux security context of each NAME to\n"
#~ "                         default type, or CTX if specified\n"
#~ msgstr ""
#~ "  -Z, --context[=КОН]  встановити контекст захисту SELinux для кожної "
#~ "НАЗВИ у типове\n"
#~ "                       значення або у значення КОН\n"

#~ msgid ""
#~ "  -Z, --context[=CTX]  set the SELinux security context of NAME to\n"
#~ "                         default type, or to CTX if specified\n"
#~ msgstr ""
#~ "  -Z, --context[=КОН]  встановити контекст захисту SELinux для НАЗВИ у "
#~ "типове\n"
#~ "                       значення або у значення КОН\n"

#~ msgid "out of memory (requested %zu bytes)"
#~ msgstr "переповнення пам'яті (запитано %zu байтів)"

#~ msgid "--padding cannot be combined with --format"
#~ msgstr "--padding не можна використовувати разом з --format"

#~ msgid ""
#~ "Usage: %s [SHORT-OPTION]... USER COMMAND [ARGUMENT]...\n"
#~ "  or:  %s LONG-OPTION\n"
#~ msgstr ""
#~ "Використання: %s [СКОРОЧЕНИЙ-ПАРАМЕТР]... КОРИСТУВАЧ КОМАНДА "
#~ "[АРГУМЕНТ]...\n"
#~ "  або  %s ПАРАМЕТР-ПОВНІСТЮ\n"

#~ msgid ""
#~ "Drop any supplemental groups, assume the user-ID and group-ID of the "
#~ "specified\n"
#~ "USER (numeric ID or user name), and run COMMAND with any specified "
#~ "ARGUMENTs.\n"
#~ "Exit with status 111 if unable to assume the required user and group ID.\n"
#~ "Otherwise, exit with the exit status of COMMAND.\n"
#~ "This program is useful only when run by root (user ID zero).\n"
#~ "\n"
#~ msgstr ""
#~ "Скидає всі додаткові групи, встановлює ідентифікатори\n"
#~ "користувача та групи як у вказаного КОРИСТУВАЧА та запускає КОМАНДУ\n"
#~ "з вказаними АРГУМЕНТАМИ.  Завершується зі статусом 111, якщо \n"
#~ "не вдалося встановити потрібні ідентифікатори користувача та групи.  У\n"
#~ "іншому випадку повертається вихідний статус КОМАНДИ.  Ця програма\n"
#~ "має сенс лише для root (UID=0).\n"
#~ "\n"

#~ msgid ""
#~ "  -g GID[,GID1...]  also set the primary group-ID to the numeric GID, "
#~ "and\n"
#~ "                      (if specified) supplemental group IDs to GID1, ...\n"
#~ msgstr ""
#~ "  -g GID[,GID1...]  також встановити головний ідентифікатор групи у "
#~ "значення GID, та\n"
#~ "                    (якщо вказано) ідентифікатори додаткових груп ID у "
#~ "GID1, ...\n"

#~ msgid "unknown user-ID: %s"
#~ msgstr "невідомий ідентифікатор користувача: %s"

#~ msgid "to use user-ID %s you need to use -g too"
#~ msgstr ""
#~ "для використання ідентифікатора користувача %s слід використовувати -g too"

#~ msgid "cannot set group-ID to %lu"
#~ msgstr "не вдалося встановити ідентифікатор групи рівним %lu"

#~ msgid "cannot set user-ID to %lu"
#~ msgstr "не вдалося встановити ідентифікатор користувача рівним %lu"

#~ msgid "failed to get file system create context"
#~ msgstr "не вдалося отримати контекст файлової системи для створення файлів"

#~ msgid "warning: "
#~ msgstr "попередження: "

#~ msgid "long option '--megabytes' is deprecated and will soon be removed"
#~ msgstr ""
#~ "довга версія параметра «--megabytes» вважається застарілою, скоро її буде "
#~ "вилучено"

#~ msgid "Usage: %s [OPTION]... [USERNAME]\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [КОРИСТУВАЧ]\n"

#~ msgid ""
#~ "      --strict         with --check, exit non-zero for any invalid input\n"
#~ msgstr ""
#~ "      --strict         з --check вийти з ненульовим кодом для будь-якого "
#~ "некоректного\n"
#~ "                       джерела вхідних даних\n"

#~ msgid "failed to redirect stderr to /dev/null"
#~ msgstr "не вдалося переспрямувати stderr до /dev/null"

#~ msgid "invalid number: '%s'"
#~ msgstr "некоректне число: «%s»"

#~ msgid ""
#~ "\n"
#~ "With no FILE or if FILE is -, read Standard Input.  '-F /' by default.\n"
#~ msgstr ""
#~ "\n"
#~ "Якщо ФАЙЛ не вказаний або вказаний як -, читає стандартний ввід.\n"
#~ "Типово вважається вказаним '-F /'.\n"

#~ msgid "cannot remove directory: %s"
#~ msgstr "не вдалося вилучити каталог: %s"

#~ msgid "dup2 failed"
#~ msgstr "помилка dup2"

#~ msgid "couldn't execute %s"
#~ msgstr "неможливо виконати %s"

#~ msgid "couldn't execute %s -d"
#~ msgstr "неможливо виконати %s -d"

#~ msgid ""
#~ "\n"
#~ "Report %s bugs to %s\n"
#~ msgstr ""
#~ "\n"
#~ "Про вади у %s повідомляйте на адресу %s.\n"

#~ msgid "warning: --retry is useful mainly when following by name"
#~ msgstr ""
#~ "попередження: ключ --retry корисний лише при слідуванні за назвою файла"

#~ msgid "using single-precision arithmetic"
#~ msgstr "використання арифметики з фіксованою точністю"

#~ msgid "using arbitrary-precision arithmetic"
#~ msgstr "використання арифметики з довільною точністю"

#~ msgid ""
#~ "simple_strtod_human:\n"
#~ "  input string: '%s'\n"
#~ "  locale decimal-point: '%s'\n"
#~ msgstr ""
#~ "simple_strtod_human:\n"
#~ "  рядок вхідних даних: «%s»\n"
#~ "  символ відокремлення дробової частини локалі: «%s»\n"

#~ msgid ""
#~ "  parsed numeric value: %Lf\n"
#~ "  input precision = %d\n"
#~ msgstr ""
#~ "  оброблене числове значення: %Lf\n"
#~ "  точність вхідних даних = %d\n"

#~ msgid "  Auto-scaling, found 'i', switching to base %d\n"
#~ msgstr "  Автомасштабування, виявлено «i», перемикаємося на основу %d\n"

#~ msgid "  suffix power=%d^%d = %Lf\n"
#~ msgstr "  степінь у суфіксі=%d^%d = %Lf\n"

#~ msgid "  returning value: %Lf (%LG)\n"
#~ msgstr "  повертаємо значення %Lf (%LG)\n"

#~ msgid "double_to_human:\n"
#~ msgstr "double_to_human:\n"

#~ msgid "  no scaling, returning (grouped) value: %'.*Lf\n"
#~ msgstr "  без масштабування, повертаємо значення (з групуванням) %'.*Lf\n"

#~ msgid "  no scaling, returning value: %.*Lf\n"
#~ msgstr "  без масштабування, повертаємо значення %.*Lf\n"

#~ msgid "  scaled value to %Lf * %0.f ^ %d\n"
#~ msgstr "  масштабоване значення до %Lf * %0.f ^ %d\n"

#~ msgid "  after rounding, value=%Lf * %0.f ^ %d\n"
#~ msgstr "  після округлення, значення=%Lf * %0.f ^ %d\n"

#~ msgid "  returning value: '%s'\n"
#~ msgstr "  повернутаємо значення «%s»\n"

#~ msgid "Usage: %s [OPTIONS] [NUMBER]\n"
#~ msgstr "Використання: %s [ПАРАМЕТРИ] [ЧИСЛО]\n"

#~ msgid ""
#~ "  --from=UNIT     auto-scale input numbers to UNITs. Default is 'none'.\n"
#~ "                  See UNIT below.\n"
#~ "  --from-unit=N   specify the input unit size (instead of the default "
#~ "1).\n"
#~ "  --to=UNIT       auto-scale output numbers to UNITs.\n"
#~ "                  See UNIT below.\n"
#~ "  --to-unit=N     the output unit size (instead of the default 1).\n"
#~ "  --round=METHOD  the rounding method to use when scaling. METHOD can "
#~ "be:\n"
#~ "                  up, down, from-zero (default), towards-zero, nearest\n"
#~ "  --suffix=SUFFIX add SUFFIX to output numbers, and accept optional "
#~ "SUFFIX\n"
#~ "                  in input numbers.\n"
#~ "  --padding=N     pad the output to N characters.\n"
#~ "                  Positive N will right-aligned. Negative N will left-"
#~ "align.\n"
#~ "                  Note: if the output is wider than N, padding is "
#~ "ignored.\n"
#~ "                  Default is to automatically pad if whitespace is "
#~ "found.\n"
#~ "  --grouping      group digits together (e.g. 1,000,000).\n"
#~ "                  Uses the locale-defined grouping (i.e. have no effect\n"
#~ "                  in C/POSIX locales).\n"
#~ "  --header[=N]    print (without converting) the first N header lines.\n"
#~ "                  N defaults to 1 if not specified.\n"
#~ "  --field N       replace the number in input field N (default is 1)\n"
#~ "  -d, --delimiter=X  use X instead of whitespace for field delimiter\n"
#~ "  --format=FORMAT use printf style floating-point FORMAT.\n"
#~ "                  See FORMAT below for details.\n"
#~ "  --invalid=MODE  failure mode for invalid numbers: MODE can be:\n"
#~ "                  abort (the default), fail, warn, ignore.\n"
#~ "  --debug         print warnings about invalid input.\n"
#~ "  \n"
#~ msgstr ""
#~ "  --from=ОДИНИЦЯ  автоматично масштабувати вхідні числа за ОДИНИЦЕЮ. "
#~ "Типове\n"
#~ "                  значення -- 'none'. Опис ОДИНИЦІ наведено нижче.\n"
#~ "  --from-unit=N   вказати розмір вхідної одиниці (типовим є 1).\n"
#~ "  --to=ОДИНИЦЯ    автоматично масштабувати виведені числа за ОДИНИЦЕЮ. "
#~ "Опис\n"
#~ "                  ОДИНИЦІ наведено нижче.\n"
#~ "  --to-unit=N     розмір одиниці виведення (замість типового значення "
#~ "1).\n"
#~ "  --round=СПОСІБ  спосіб округлення під час масштабування. Варіанти:\n"
#~ "                  up (до більшого), down (до меншого), from-zero (до "
#~ "дальшого\n"
#~ "                  до нуля, типовий), towards-zero (до ближчого до "
#~ "нуля),                   nearest (до найближчого цілого\n"
#~ "  --suffix=СУФІКС додати СУФІКС до виведених чисел і використовувати "
#~ "СУФІКС\n"
#~ "                  у вхідних даних.\n"
#~ "  --padding=N     доповнити виведені дані до N символів.\n"
#~ "                  Використання додатного N призведе до вирівнювання "
#~ "праворуч\n"
#~ "                  Від’ємні N вирівнюватимуть дані ліворуч.\n"
#~ "                  Зауваження: якщо виведені дані будуть довшими за N,\n"
#~ "                  доповнення не відбуватиметься. Типовим є автоматичне "
#~ "доповнення,\n"
#~ "                  якщо буде виявлено пробіли.\n"
#~ "  --grouping      групувати цифри (наприклад, 1.000.000).\n"
#~ "                  Використовується визначене локаллю групування (тобто не "
#~ "впливає\n"
#~ "                  на локалі C/POSIX).\n"
#~ "  --header[=N]    вивести (без перетворення) перші N рядків заголовка.\n"
#~ "                  Якщо не вказано, типовим значенням N є 1.\n"
#~ "  --field N       замінити число у вхідному полі N (типовим є 1)\n"
#~ "  -d, --delimiter=X  використовувати X замість пробілу для відокремлення "
#~ "полів\n"
#~ "  --format=ФОРМАТ використовувати форматування у стилі printf.\n"
#~ "                  Опис ФОРМАТу наведено нижче.\n"
#~ "  --invalid=РЕЖИМ режим обробки некоректних символів. Можливі режими:\n"
#~ "                  abort (перервати обробку, типовий), fail (обробити з "
#~ "помилками),\n"
#~ "                  warn (попередити), ignore (ігнорувати).\n"
#~ "  --debug         виводити попередження щодо некоректних вхідних даних.\n"
#~ "  \n"

#~ msgid ""
#~ "\n"
#~ "UNIT options:\n"
#~ "  none       No auto-scaling is done. Suffixes will trigger an error.\n"
#~ "  auto       Accept optional single-letter/two-letter suffix:\n"
#~ "             1K  = 1000\n"
#~ "             1Ki = 1024\n"
#~ "             1M  = 1000000\n"
#~ "             1Mi = 1048576\n"
#~ "  si         Accept optional single letter suffix:\n"
#~ "             1K = 1000\n"
#~ "             1M = 1000000\n"
#~ "             ...\n"
#~ "  iec        Accept optional single letter suffix:\n"
#~ "             1K = 1024\n"
#~ "             1M = 1048576\n"
#~ "             ...\n"
#~ "  iec-i      Accept optional two-letter suffix:\n"
#~ "             1Ki = 1024\n"
#~ "             1Mi = 1048576\n"
#~ "             ...\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "Варіанти ОДИНИЦІ:\n"
#~ "  none       без автоматичного масштабування. Використання суфіксів\n"
#~ "             призводитиме до повідомлення про помилку.\n"
#~ "  auto       Використовувати додатковий одно- або дволітерний суфікс:\n"
#~ "             1K  = 1000\n"
#~ "             1Ki = 1024\n"
#~ "             1M  = 1000000\n"
#~ "             1Mi = 1048576\n"
#~ "  si         Використовувати додатковий однолітерний суфікс:\n"
#~ "             1K = 1000\n"
#~ "             1M = 1000000\n"
#~ "             ...\n"
#~ "  iec        Використовувати додатковий однолітерний суфікс:\n"
#~ "             1K = 1024\n"
#~ "             1M = 1048576\n"
#~ "             ...\n"
#~ "  iec-i      Використовувати додатковий дволітерний суфікс:\n"
#~ "             1Ki = 1024\n"
#~ "             1Mi = 1048576\n"
#~ "             ...\n"
#~ "\n"

#~ msgid ""
#~ "format String:\n"
#~ "  input: %s\n"
#~ "  grouping: %s\n"
#~ "  padding width: %ld\n"
#~ "  alignment: %s\n"
#~ "  prefix: '%s'\n"
#~ "  suffix: '%s'\n"
#~ msgstr ""
#~ "Рядок форматування:\n"
#~ "  вхідні дані: %s\n"
#~ "  групування: %s\n"
#~ "  розмір доповнення: %ld\n"
#~ "  вирівнювання: %s\n"
#~ "  префікс: «%s»\n"
#~ "  суфікс: «%s»\n"

#~ msgid ""
#~ "formatting output:\n"
#~ "  value: %Lf\n"
#~ "  humanized: '%s'\n"
#~ msgstr ""
#~ "форматуємо виведення:\n"
#~ "  значення: %Lf\n"
#~ "  у зручному форматі: «%s»\n"

#~ msgid "  After padding: '%s'\n"
#~ msgstr "  Після доповнення: «%s»\n"

#~ msgid "trimming suffix '%s'\n"
#~ msgstr "обрізаємо суфікс «%s»\n"

#~ msgid "no valid suffix found\n"
#~ msgstr "не знайдено коректного суфікса\n"

#~ msgid "setting Auto-Padding to %ld characters\n"
#~ msgstr "встановлюємо автоматичне доповнення до %ld символів\n"

#~ msgid ""
#~ "extracting Fields:\n"
#~ "  input: '%s'\n"
#~ "  field: %d\n"
#~ msgstr ""
#~ "видобуваємо поля:\n"
#~ "  вхідні дані: «%s»\n"
#~ "  поле: %d\n"

#~ msgid ""
#~ "  TOO FEW FIELDS!\n"
#~ "  prefix: '%s'\n"
#~ msgstr ""
#~ "  НАДТО МАЛО ПОЛІВ!\n"
#~ "  префікс: «%s»\n"

#~ msgid ""
#~ "  prefix: '%s'\n"
#~ "  number: '%s'\n"
#~ "  suffix: '%s'\n"
#~ msgstr ""
#~ "  префікс: «%s»\n"
#~ "  номер: «%s»\n"
#~ "  суфікс: «%s»\n"

#~ msgid "reading %s"
#~ msgstr "читання %s"

#~ msgid "writing %s"
#~ msgstr "запис %s"

#~ msgid "closing %s"
#~ msgstr "закриття %s"

#~ msgid "accessing %s"
#~ msgstr "звернення до %s"

#~ msgid "opening %s"
#~ msgstr "відкриття %s"

#~ msgid ""
#~ "  -x, --one-file-system    skip directories on different file systems\n"
#~ "  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
#~ "      --exclude=PATTERN    exclude files that match PATTERN\n"
#~ "  -d, --max-depth=N     print the total for a directory (or file, with --"
#~ "all)\n"
#~ "                          only if it is N or fewer levels below the "
#~ "command\n"
#~ "                          line argument;  --max-depth=0 is the same as\n"
#~ "                          --summarize\n"
#~ msgstr ""
#~ "  -x, --one-file-system   пропускати каталоги на інших файлових системах\n"
#~ "  -X, --exclude-from=ФАЙЛ виключати файли, що збігаються з якимось\n"
#~ "                          шаблоном з ФАЙЛА\n"
#~ "      --exclude=ШАБЛОН    виключати файли, що збігаються з ШАБЛОНОМ\n"
#~ "      --max-depth=N       виводити зведення про каталог (або файл, з --"
#~ "all),\n"
#~ "                          лише якщо він на N або менше рівнів нижче,\n"
#~ "                          ніж аргумент командного рядка; --max-depth=0\n"
#~ "                          еквівалентно до --summarize\n"

#~ msgid ""
#~ "  none, off       never make backups (even if --backup is given)\n"
#~ "  numbered, t     make numbered backups\n"
#~ "  existing, nil   numbered if numbered backups exist, simple otherwise\n"
#~ "  simple, never   always make simple backups\n"
#~ "\n"
#~ msgstr ""
#~ "  none, off       ніколи не створювати резервних копій (навіть якщо\n"
#~ "                  вказаний ключ --backup)\n"
#~ "  numbered, t     створювати нумеровані копії\n"
#~ "  existing, nil   якщо існують нумеровані копії, то створювати\n"
#~ "                  нумеровані інакше створювати прості\n"
#~ "  simple. never   завжди створювати прості копії\n"
#~ "\n"

#~ msgid ""
#~ "WARNING: --page-increment is deprecated; use --line-increment instead"
#~ msgstr ""
#~ "ПОПЕРЕДЖЕННЯ: --page-increment вважаєте застарілим; вам варто "
#~ "скористатися --line-increment"

#~ msgid "All arguments to long options are mandatory for short options.\n"
#~ msgstr "Всі аргументи для довгих ключів є обов'язковими для коротких.\n"

#~ msgid ""
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, and may have a multiplier "
#~ "suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ "Adding a z suffix to any type displays printable characters at the end of "
#~ "each\n"
#~ "output line.\n"
#~ msgstr ""
#~ "\n"
#~ "ОСНОВА може бути d (десятковою), o (вісімковою), x (шістнадцятковою) або\n"
#~ "n (не виводити зсув).  Н з префіксом 0x або 0X сприймається як\n"
#~ "шістнадцяткове, з суфіксом b множиться на 512, з суфіксом kB — 1000, K — "
#~ "1024,\n"
#~ "MB — 1000*1000, M — 1024*1024, GB — 1000*1000*1000, G — 1024*1024*1024, "
#~ "те саме\n"
#~ "для T, P, E, Z, Y. Якщо додати до будь-якого формату суфікс z,\n"
#~ "наприкінці кожного рядка будуть виводитись друковані символи.\n"

#~ msgid ""
#~ "Option --string without a number implies 3; option --width without a "
#~ "number\n"
#~ "implies 32.  By default, od uses -A o -t oS -w16.\n"
#~ msgstr ""
#~ "Параметр --string без аргументу означає 3, --width — 32.\n"
#~ "Типово od використовуються ключі -A o -t oS -w16.\n"

#~ msgid "Usage: %s [OPTION]... FILE\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [ФАЙЛ]\n"

#~ msgid "Password:"
#~ msgstr "Пароль:"

#~ msgid "getpass: cannot open /dev/tty"
#~ msgstr "getpass: не вдалося відкрити /dev/tty"

#~ msgid "cannot set groups"
#~ msgstr "не вдалося встановити групи"

#~ msgid "cannot set group id"
#~ msgstr "не вдалося встановити груповий id"

#~ msgid "cannot set user id"
#~ msgstr "не вдалося встановити id користувача"

#~ msgid "Usage: %s [OPTION]... [-] [USER [ARG]...]\n"
#~ msgstr "Використання: %s [КЛЮЧ]... [-] [КОРИСТУВАЧ [АРГ]...]\n"

#~ msgid ""
#~ "Change the effective user id and group id to that of USER.\n"
#~ "\n"
#~ "  -, -l, --login               make the shell a login shell\n"
#~ "  -c, --command=COMMAND        pass a single COMMAND to the shell with -"
#~ "c\n"
#~ "  -f, --fast                   pass -f to the shell (for csh or tcsh)\n"
#~ "  -m, --preserve-environment   do not reset environment variables\n"
#~ "  -p                           same as -m\n"
#~ "  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n"
#~ msgstr ""
#~ "Встановлює ефективні id користувача та групи як у КОРИСТУВАЧА.\n"
#~ "\n"
#~ "  -, -l, --login               використовувати оболонку як оболонку "
#~ "входу\n"
#~ "  -c, --commmand=КОМАНДА       передати оболонці КОМАНДУ за допомогою -c\n"
#~ "  -f, --fast                   передати оболонці -f (для csh або tcsh)\n"
#~ "  -m, --preserve-environment   не перевстановлювати змінні оточення\n"
#~ "  -p                           синонім для -m\n"
#~ "  -s, --shell=ОБОЛОНКА         запустити ОБОЛОНКУ, якщо дозволяє /etc/"
#~ "shells\n"

#~ msgid ""
#~ "\n"
#~ "A mere - implies -l.   If USER not given, assume root.\n"
#~ msgstr ""
#~ "\n"
#~ "Просто знак мінус означає -l.  Якщо КОРИСТУВАЧ не вказаний,\n"
#~ "вважається root.\n"

#~ msgid "user %s does not exist"
#~ msgstr "користувач %s не існує"

#~ msgid "incorrect password"
#~ msgstr "неправильний пароль"

#~ msgid "using restricted shell %s"
#~ msgstr "використовується обмежена оболонка %s"

#~ msgid "warning: cannot change directory to %s"
#~ msgstr "попередження: не вдалося змінити каталог на %s"

#~ msgid ""
#~ "\n"
#~ "Examples:\n"
#~ "  %s /usr/bin/sort       Output \"sort\".\n"
#~ "  %s include/stdio.h .h  Output \"stdio\".\n"
#~ msgstr ""
#~ "\n"
#~ "Приклади:\n"
#~ "  %s /usr/bin/sort       Виводить \"sort\".\n"
#~ "  %s include/stdio.h .h  Виводить \"stdio\".\n"

#~ msgid ""
#~ "Usage: %s NAME\n"
#~ "  or:  %s OPTION\n"
#~ msgstr ""
#~ "Використання: %s НАЗВА\n"
#~ "       або:    %s КЛЮЧ\n"

#~ msgid "--relative-base requires --relative-to"
#~ msgstr "Для --relative-base слід вказати --relative-to"

#~ msgid ""
#~ "Change the group of each FILE to GROUP.\n"
#~ "With --reference, change the group of each FILE to that of RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "Змінює групу власника кожного файла ФАЙЛ на ГРУПА.\n"
#~ "З ключем  --reference, змінює групу кожного ФАЙЛУ на групу ЗФАЙЛУ.\n"
#~ "\n"
#~ "  -c, --changes          як і verbose, але виводити лише при змінах\n"
#~ "      --dereference      впливає на ціль кожного символічного посилання\n"
#~ "                         (типово), а не на саме символічне посилання\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's group rather than specifying a\n"
#~ "                         GROUP value\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet  не виводити більшість повідомлень про помилки\n"
#~ "      --reference=ЗФАЙЛУ використовувати групу ЗФАЙЛУ замість явного\n"
#~ "                         вказування ГРУПИ\n"
#~ "  -R, --recursive        рекурсивно обробляти файли та каталоги\n"
#~ "  -v, --verbose          виводити діагностичні повідомлення для кожного "
#~ "файла\n"

#~ msgid ""
#~ "Change the mode of each FILE to MODE.\n"
#~ "\n"
#~ "  -c, --changes           like verbose but report only when a change is "
#~ "made\n"
#~ msgstr ""
#~ "Змінює режим кожного ФАЙЛУ на вказаний РЕЖИМ.\n"
#~ "\n"
#~ "  -c, --changes           як verbose, але повідомляти, лише якщо справді\n"
#~ "                          внесена зміна\n"

#~ msgid ""
#~ "      --no-preserve-root  do not treat `/' specially (the default)\n"
#~ "      --preserve-root     fail to operate recursively on `/'\n"
#~ msgstr ""
#~ "      --no-preserve-root  не обробляти `/' особливим чином (типово)\n"
#~ "      --preserve-root     не обробляти рекурсивно `/'\n"

#~ msgid ""
#~ "  -f, --silent, --quiet   suppress most error messages\n"
#~ "  -v, --verbose           output a diagnostic for every file processed\n"
#~ "      --reference=RFILE   use RFILE's mode instead of MODE values\n"
#~ "  -R, --recursive         change files and directories recursively\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet   не виводити більшість повідомлень про помилки\n"
#~ "  -v, --verbose           виводити діагностичні повідомлення для усіх "
#~ "файлів\n"
#~ "      --reference=ЗФАЙЛ   режим ЗФАЙЛУ замість явного вказування РЕЖИМУ\n"
#~ "  -R, --recursive         рекурсивно обробляти файли та каталоги\n"

#~ msgid ""
#~ "Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
#~ "With --reference, change the owner and group of each FILE to those of "
#~ "RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "Змінює власника та/або групу кожного ФАЙЛУ на ВЛАСНИКА та/або ГРУПУ.\n"
#~ "З ключем --reference, змінює власника та групу кожного ФАЙЛУ на власника "
#~ "та\n"
#~ "групу ЗФАЙЛУ.\n"
#~ "\n"
#~ "  -c, --change           те саме що й --verbose, але повідомляє лише "
#~ "коли\n"
#~ "                         були внесені зміни\n"
#~ "      --dereference      змінювати файл, на який вказує символьне\n"
#~ "                         посилання, а не саме посилання (типово)\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's owner and group rather than\n"
#~ "                         specifying OWNER:GROUP values\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet  не виводити більшість повідомлень про помилки\n"
#~ "      --reference=ЗФАЙЛ  використовувати власника та групу ЗФАЙЛУ "
#~ "замість\n"
#~ "                         явного вказування ВЛАСНИКА:ГРУПИ\n"
#~ "  -R, --recursive        рекурсивно обробляти файли та каталоги\n"
#~ "  -v, --verbose          виводити діагностичні повідомлення для кожного "
#~ "файла\n"

#~ msgid ""
#~ "\n"
#~ "SIZE may be (or may be an integer optionally followed by) one of "
#~ "following:\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, "
#~ "Y.\n"
#~ msgstr ""
#~ "\n"
#~ "РОЗМІР може бути таким (або це може бути ціле число, за яким\n"
#~ "може слідувати одне з переліченого):\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024 тощо для G, T, P, E, Z, Y.\n"
