# Simplified Chinese translation of coreutils.
# Copyright (C) 1998, 2002, 2004, 2005, 2009, 2010, 2011 Free Software Foundation, Inc.
# This file is distributed under the same license as the coreutils package.
# Yip Chi Lap <clyip@cs.hku.hk>, 1998.
# Abel Cheung <maddog@linux.org.hk>, 2002.
# Anthony Fok <anthony@thizlinux.com>, 2002.
# Funda Wang <fundawang@linux.net.cn>, 2004, 2005.
# Ji ZhengYu <zhengyuji@gmail.com>, 2009.
# Aron Xu <happyaron.xu@gmail.com>, 2009, 2010, 2011, 2015.
# Boyuan Yang <073plan@gmail.com>, 2018, 2019, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.31.90\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2020-03-05 13:28+0000\n"
"PO-Revision-Date: 2020-02-28 14:41-0500\n"
"Last-Translator: Boyuan Yang <073plan@gmail.com>\n"
"Language-Team: Chinese (simplified) <i18n-zh@googlegroups.com>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 2.3\n"

#: lib/argmatch.c:132
#, c-format
msgid "invalid argument %s for %s"
msgstr "%2$s 的参数%1$s 无效"

#: lib/argmatch.c:133
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "%2$s 的参数%1$s 不明确"

#: lib/argmatch.c:152 lib/argmatch.h:223
msgid "Valid arguments are:"
msgstr "有效的参数为："

#: lib/closein.c:100
msgid "error closing file"
msgstr "关闭文件时出错"

#: lib/closeout.c:122 src/basenc.c:945 src/basenc.c:957 src/basenc.c:963
#: src/basenc.c:1006 src/basenc.c:1071 src/cat.c:187 src/cat.c:203
#: src/cat.c:287 src/cksum.c:245 src/expand.c:150 src/expand.c:175
#: src/factor.c:2387 src/mktemp.c:339 src/od.c:970 src/paste.c:163
#: src/seq.c:295 src/shuf.c:595 src/split.c:936 src/split.c:1190
#: src/split.c:1195 src/tail.c:1291 src/tail.c:1445 src/tail.c:2507
#: src/tr.c:1587 src/tr.c:1813 src/tr.c:1905 src/unexpand.c:234
#: src/unexpand.c:250
#, c-format
msgid "write error"
msgstr "写入错误"

#: lib/copy-acl.c:54 src/copy.c:1427 src/copy.c:2945
#, c-format
msgid "preserving permissions for %s"
msgstr "%s 的保留权限"

#: lib/error.c:195
msgid "Unknown system error"
msgstr "未知的系统错误"

#: lib/file-type.c:40
msgid "regular empty file"
msgstr "普通空文件"

#: lib/file-type.c:40
msgid "regular file"
msgstr "普通文件"

#: lib/file-type.c:43
msgid "directory"
msgstr "目录"

#: lib/file-type.c:46
msgid "symbolic link"
msgstr "符号链接"

#: lib/file-type.c:52
msgid "message queue"
msgstr "消息队列"

#: lib/file-type.c:55
msgid "semaphore"
msgstr "信号量"

#: lib/file-type.c:58
msgid "shared memory object"
msgstr "共享内存对象"

#: lib/file-type.c:61
msgid "typed memory object"
msgstr "共享内存对象"

#: lib/file-type.c:66
msgid "block special file"
msgstr "块特殊文件"

#: lib/file-type.c:69
msgid "character special file"
msgstr "字符特殊文件"

#: lib/file-type.c:72
msgid "contiguous data"
msgstr "连续数据"

#: lib/file-type.c:75
msgid "fifo"
msgstr "先进先出"

#: lib/file-type.c:78
msgid "door"
msgstr "门(Solaris)"

#: lib/file-type.c:81
msgid "multiplexed block special file"
msgstr "复用块特殊文件"

#: lib/file-type.c:84
msgid "multiplexed character special file"
msgstr "复用字符特殊文件"

#: lib/file-type.c:87
msgid "multiplexed file"
msgstr "复用文件"

#: lib/file-type.c:90
msgid "named file"
msgstr "命名文件(XENIX)"

#: lib/file-type.c:93
msgid "network special file"
msgstr "网络特殊文件"

#: lib/file-type.c:96
msgid "migrated file with data"
msgstr "含数据迁移文件(Cray DMF)"

#: lib/file-type.c:99
msgid "migrated file without data"
msgstr "不含数据迁移文件(Cray DMF)"

#: lib/file-type.c:102
msgid "port"
msgstr "端口"

#: lib/file-type.c:105
msgid "socket"
msgstr "套接字"

#: lib/file-type.c:108
msgid "whiteout"
msgstr "whiteout 文件"

#: lib/file-type.c:110
msgid "weird file"
msgstr "古怪文件"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "主机名的地址家族不被支持"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "名称解析出现临时错误"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "错误的ai_flags 值"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "名称解析时出现不可恢复的错误"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "不支持的ai_family"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "内存分配失败"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "没有与主机名关联的地址"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "名称或服务未知"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr "ai_socktype 不支持 Servname"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "不支持ai_socktype"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "系统错误"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "参数缓冲区太小"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "正在处理请求"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "请求已取消"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "请求未取消"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "全部请求已完成"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "被信号中断"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "参数字符串编码不正确"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "未知错误"

#: lib/getopt.c:278
#, c-format
msgid "%s: option '%s%s' is ambiguous\n"
msgstr "%s：选项“%s%s”有歧义\n"

#: lib/getopt.c:284
#, c-format
msgid "%s: option '%s%s' is ambiguous; possibilities:"
msgstr "%s：选项“%s%s”有歧义；可能是："

#: lib/getopt.c:319
#, c-format
msgid "%s: unrecognized option '%s%s'\n"
msgstr "%s：无法识别的选项“%s%s”\n"

#: lib/getopt.c:345
#, c-format
msgid "%s: option '%s%s' doesn't allow an argument\n"
msgstr "%s：选项“%s%s”不允许带参数\n"

#: lib/getopt.c:360
#, c-format
msgid "%s: option '%s%s' requires an argument\n"
msgstr "%s：选项“%s%s”必须带参数\n"

#: lib/getopt.c:621
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s：无效选项 -- %c\n"

#: lib/getopt.c:636 lib/getopt.c:682
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s：选项必须带参数 -- \"%c\"\n"

#: lib/mkdir-p.c:162 src/copy.c:1927 src/copy.c:1999 src/copy.c:2571
#: src/copy.c:2932 src/find-mount-point.c:84 src/install.c:702
#: src/realpath.c:146 src/stat.c:1440 src/truncate.c:327
#, c-format
msgid "cannot stat %s"
msgstr "无法获取%s 的文件状态(stat)"

#: lib/mkdir-p.c:190 src/install.c:512
#, c-format
msgid "cannot change permissions of %s"
msgstr "无法更改 %s 的权限"

#: lib/mkdir-p.c:200 src/copy.c:2560 src/install.c:740 src/install.c:753
#, c-format
msgid "cannot create directory %s"
msgstr "无法创建目录 %s"

#: lib/obstack.c:338 lib/obstack.c:340 lib/xalloc-die.c:34 src/csplit.c:233
#: src/tac.c:442
#, c-format
msgid "memory exhausted"
msgstr "内存耗尽"

#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "无法记录目前的工作目录"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "返回到初始工作目录失败"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:362
msgid "`"
msgstr "“"

#: lib/quotearg.c:363
msgid "'"
msgstr "”"

#: lib/randread.c:128
#, c-format
msgid "%s: end of file"
msgstr "%s：文件结束"

#: lib/randread.c:128 src/du.c:1074 src/md5sum.c:803 src/od.c:954 src/tac.c:251
#: src/tac.c:357 src/tac.c:515 src/tac.c:596 src/wc.c:824
#, c-format
msgid "%s: read error"
msgstr "%s：读取出错"

#: lib/regcomp.c:135
msgid "Success"
msgstr "成功"

#: lib/regcomp.c:138
msgid "No match"
msgstr "无匹配"

#: lib/regcomp.c:141
msgid "Invalid regular expression"
msgstr "无效的正则表达式"

#: lib/regcomp.c:144
msgid "Invalid collation character"
msgstr "无效的校勘字符"

#: lib/regcomp.c:147
msgid "Invalid character class name"
msgstr "无效的字符类型名"

#: lib/regcomp.c:150
msgid "Trailing backslash"
msgstr "末尾的反斜杠"

#: lib/regcomp.c:153
msgid "Invalid back reference"
msgstr "无效的后向引用"

#: lib/regcomp.c:156
msgid "Unmatched [, [^, [:, [., or [="
msgstr "未匹配的 [、[^、[:、[. 或 [="

#: lib/regcomp.c:159
msgid "Unmatched ( or \\("
msgstr "未匹配的 ( 或 \\("

#: lib/regcomp.c:162
msgid "Unmatched \\{"
msgstr "未匹配的 \\{"

#: lib/regcomp.c:165
msgid "Invalid content of \\{\\}"
msgstr "\\{\\} 中内容无效"

#: lib/regcomp.c:168
msgid "Invalid range end"
msgstr "无效的范围结束符"

#: lib/regcomp.c:171
msgid "Memory exhausted"
msgstr "内存耗尽"

#: lib/regcomp.c:174
msgid "Invalid preceding regular expression"
msgstr "无效的前置正则表达式"

#: lib/regcomp.c:177
msgid "Premature end of regular expression"
msgstr "正则表达式异常结束"

#: lib/regcomp.c:180
msgid "Regular expression too big"
msgstr "正则表达式过长"

#: lib/regcomp.c:183
msgid "Unmatched ) or \\)"
msgstr "未匹配的 ) 或 \\)"

#: lib/regcomp.c:676
msgid "No previous regular expression"
msgstr "缺少之前的正则表达式"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "在%s 进行递归操作十分危险"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "在%s 进行递归操作十分危险(与%s 相同)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr "使用 --no-preserve-root 选项跳过安全模式"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:150
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:163
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-acl.c:46 src/copy.c:2583 src/cp.c:514
#, c-format
msgid "setting permissions for %s"
msgstr "设置 %s 的权限"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "挂起"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "中断"

#: lib/siglist.h:37
msgid "Quit"
msgstr "退出"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "非法操作"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "跟踪/断点陷阱"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "已中止"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "浮点数异常"

#: lib/siglist.h:52
msgid "Killed"
msgstr "已杀死"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "总线错误"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "段错误"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "管道中断"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "时钟警告"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "已终止"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "紧急 I/O 事件"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "已停止（信号）"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "已停止"

#: lib/siglist.h:79
msgid "Continued"
msgstr "已继续"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "子进程已退出"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "已停止（tty 输入）"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "已停止（tty 输出）"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "可能需要I/O"

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "CPU 时间超时"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "文件大小超过限制"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "虚拟定时器过期"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "定时器描述已过期"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "窗口已更改"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "用户自定义信号 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "用户自定义信号 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "捕获 EMT 信号"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "错误的系统调用"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "栈错误"

#: lib/siglist.h:126
msgid "Information request"
msgstr "信息请求"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "电源错误"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "资源丢失"

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "实时信号 %d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "未知信号 %d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "iconv 函数无法使用"

#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "iconv 函数不存在"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "字符值超出可接受的范围以外"

#: lib/unicodeio.c:181
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "无法将U+%04X 转换至用户的字符集"

#: lib/unicodeio.c:183
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "无法将U+%04X 转换至用户的字符集：%s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "无效的用户"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "无效的组"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "无效的 spec"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "无法显示错误信息"

#: lib/version-etc.c:73
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "由%s (%s)打包\n"

#: lib/version-etc.c:76
#, c-format
msgid "Packaged by %s\n"
msgstr "由%s 打包\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:83
msgid "(C)"
msgstr "(C)"

#. TRANSLATORS: The %s placeholder is the web address of the GPL license.
#: lib/version-etc.c:88
#, c-format
msgid ""
"License GPLv3+: GNU GPL version 3 or later <%s>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
msgstr ""
"许可证 GPLv3+：GNU 通用公共许可证第 3 版或更新版本<%s>。\n"
"本软件是自由软件：您可以自由修改和重新发布它。\n"
"在法律范围内没有其他保证。\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:105
#, c-format
msgid "Written by %s.\n"
msgstr "由%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:109
#, c-format
msgid "Written by %s and %s.\n"
msgstr "由%s 和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:113
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "由%s、%s 和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:120
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"由%s、%s、%s 和\n"
"%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:127
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:134
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:142
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s 和 %s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:150
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s\n"
"和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:159
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s、\n"
"%s、和%s 编写。\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:170
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"由%s、%s、%s、\n"
"%s、%s、%s、%s、\n"
"%s、%s、和其他人编写。\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:249
#, c-format
msgid "Report bugs to: %s\n"
msgstr ""
"请向< %s> 报告软件错误。请向 <i18n-zh@googlegroups.com> 报告翻译错误。\n"

#: lib/version-etc.c:251
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "请向 %2$s 报告 %1$s 的错误\n"

#: lib/version-etc.c:255 lib/version-etc.c:257
#, c-format
msgid "%s home page: <%s>\n"
msgstr "%s 的主页：<%s>\n"

#: lib/version-etc.c:260
#, c-format
msgid "General help using GNU software: <%s>\n"
msgstr "GNU 软件一般性帮助：<%s>\n"

#: lib/xbinary-io.c:37
#, c-format
msgid "failed to set file descriptor text/binary mode"
msgstr "设置文件描述符为文本/二进制模式时失败"

#: lib/xmemcoll.c:39 src/expr.c:1026
#, c-format
msgid "string comparison failed"
msgstr "字符串比较出现错误"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "请设置LC_ALL='C' 以避免出现问题。"

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "要比较的字符串为%s 和%s。"

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "不能执行格式化输出"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "非法的%s%s 参数\"%s\""

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "非法的后缀在%s%s 参数\"%s\""

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "%s%s 参数\"%s\"太大"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:38 src/chmod.c:39 src/chown.c:37 src/comm.c:39
#: src/cp.c:48 src/csplit.c:45 src/cut.c:46 src/date.c:40 src/dd.c:45
#: src/df.c:49 src/dirname.c:32 src/du.c:55 src/env.c:39 src/expand.c:49
#: src/fold.c:36 src/groups.c:36 src/head.c:47 src/id.c:42 src/install.c:51
#: src/ln.c:52 src/ls.c:137 src/mkdir.c:39 src/mkfifo.c:36 src/mknod.c:37
#: src/mv.c:43 src/nice.c:40 src/nl.c:42 src/paste.c:53 src/pathchk.c:32
#: src/pinky.c:38 src/printenv.c:44 src/printf.c:68 src/rm.c:41 src/rmdir.c:37
#: src/stty.c:68 src/sum.c:39 src/tac.c:58 src/tail.c:77 src/tee.c:38
#: src/touch.c:45 src/tty.c:44 src/uname.c:61 src/unexpand.c:50 src/uniq.c:41
#: src/uptime.c:46 src/users.c:36 src/wc.c:51 src/who.c:51 src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"用法：%s 名称 [后缀]\n"
"　或：%s 选项\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""
"去掉前导的目录部分后打印<名称>。\n"
"如果指定的话，还会去掉尾随的<后缀>。\n"

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n"
"  -z, --zero           end each output line with NUL, not newline\n"
msgstr ""
"  -a, --multiple       支持接受多个参数，并把每个参数都视作给定的<名称>\n"
"  -s, --suffix=SUFFIX  移除尾随的<后缀>；隐含启用 -a 选项\n"
"  -z, --zero           以 NUL 字符而非换行符来结束每一个输出行\n"

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""
"\n"
"示例：\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"

#: src/basename.c:170 src/chcon.c:537 src/chgrp.c:279 src/chmod.c:529
#: src/chown.c:280 src/chroot.c:279 src/comm.c:481 src/csplit.c:1402
#: src/dirname.c:116 src/expr.c:454 src/join.c:1159 src/link.c:76
#: src/mkdir.c:252 src/mkfifo.c:130 src/mknod.c:171 src/nohup.c:107
#: src/pathchk.c:147 src/printf.c:693 src/readlink.c:145 src/realpath.c:237
#: src/rm.c:338 src/rmdir.c:223 src/seq.c:633 src/sleep.c:116 src/stat.c:1885
#: src/stdbuf.c:371 src/tr.c:1753 src/unlink.c:74
#, c-format
msgid "missing operand"
msgstr "缺少操作数"

#: src/basename.c:176 src/basenc.c:1225 src/comm.c:489 src/cp.c:621
#: src/date.c:471 src/dircolors.c:449 src/du.c:1019 src/hostid.c:72
#: src/hostname.c:111 src/install.c:985 src/join.c:969 src/link.c:84
#: src/ln.c:593 src/logname.c:70 src/mknod.c:182 src/mv.c:451 src/nproc.c:115
#: src/od.c:1871 src/ptx.c:2082 src/seq.c:639 src/shuf.c:491 src/sort.c:4596
#: src/split.c:1554 src/tr.c:1768 src/tsort.c:559 src/tty.c:113 src/uname.c:252
#: src/uniq.c:520 src/uniq.c:537 src/unlink.c:80 src/uptime.c:252
#: src/users.c:145 src/wc.c:758 src/who.c:831 src/whoami.c:78
#, c-format
msgid "extra operand %s"
msgstr "额外的操作数 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:37 src/basenc.c:40
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:38 src/env.c:40 src/numfmt.c:43
msgid "Assaf Gordon"
msgstr "Assaf Gordon"

#: src/basenc.c:101 src/dircolors.c:99 src/uptime.c:199 src/users.c:105
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "用法：%s [选项]... [文件]\n"

#: src/basenc.c:106
msgid "basenc encode or decode FILE, or standard input, to standard output.\n"
msgstr "baseenc 可以编码/解码文件或标准输入输出。\n"

#: src/basenc.c:110
#, c-format
msgid "Base%d encode or decode FILE, or standard input, to standard output.\n"
msgstr "使用 Base%d 编码/解码文件或标准输入输出。\n"

#: src/basenc.c:118
msgid "      --base64          same as 'base64' program (RFC4648 section 4)\n"
msgstr "      --base64          与 'base64' 程序相同（RFC4648 section 4）\n"

#: src/basenc.c:121
msgid "      --base64url       file- and url-safe base64 (RFC4648 section 5)\n"
msgstr ""
"      --base64url       文件安全或者 URL 安全的 base64（RFC4648 section 5）\n"

#: src/basenc.c:124
msgid "      --base32          same as 'base32' program (RFC4648 section 6)\n"
msgstr "      --base32          与 'base32' 程序相同（RFC4648 section 4）\n"

#: src/basenc.c:127
msgid ""
"      --base32hex       extended hex alphabet base32 (RFC4648 section 7)\n"
msgstr ""
"      --base32hex       扩展的十六进制（hex）字母表 base32（RFC4648 section "
"7）\n"

#: src/basenc.c:130
msgid "      --base16          hex encoding (RFC4648 section 8)\n"
msgstr "      --base16          十六进制（hex）编码（RFC4648 section 8）\n"

#: src/basenc.c:133
msgid ""
"      --base2msbf       bit string with most significant bit (msb) first\n"
msgstr "      --base2msbf       位字符串，最高位（msb）最先\n"

#: src/basenc.c:136
msgid ""
"      --base2lsbf       bit string with least significant bit (lsb) first\n"
msgstr "      --base2lsbf       位字符串，最低位（lsb）最先\n"

#: src/basenc.c:140
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode\t\t解码数据\n"
"  -i, --ignore-garbag\t解码时忽略非字母字符\n"
"  -w, --wrap=字符数\t在指定的字符数后自动换行(默认为76)，0 为禁用自动换行\n"
"\n"

#: src/basenc.c:148
msgid ""
"      --z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n"
"                        when encoding, input length must be a multiple of "
"4;\n"
"                        when decoding, input length must be a multiple of 5\n"
msgstr ""
"      --z85             类似 ascii85 的编码（ZeroMQ 标准：32/Z85）；\n"
"                        编码时，输入长度必须是 4 的倍数；\n"
"                        解码时，输入长度必须是 5 的倍数；\n"

#: src/basenc.c:157
msgid ""
"\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"解码时，输入数据（编码流）可能包含一些换行符，以及不在有效字符范围之内的\n"
"字符。  可以尝试用 --ignore-garbage 选项来绕过编码流中的无效字符。\n"

#: src/basenc.c:164
#, c-format
msgid ""
"\n"
"The data are encoded as described for the %s alphabet in RFC 4648.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"数据以 RFC 4648 规定的 %s 字母格式进行编码。\n"
"解码时，输入数据（编码流）可能包含一些非有效 %s 字符以及换行符。\n"
"可以尝试用 --ignore-garbage 选项来绕过编码流中的无效字符。\n"

#: src/basenc.c:619
msgid "invalid input (length must be multiple of 4 characters)"
msgstr "无效输入（长度必须为 4 字符的整数倍）"

#: src/basenc.c:1009 src/basenc.c:1055 src/csplit.c:277 src/csplit.c:1468
#: src/join.c:465 src/shuf.c:233 src/shuf.c:279 src/shuf.c:559
#: src/tac-pipe.c:76 src/tee.c:263 src/tr.c:1611
#, c-format
msgid "read error"
msgstr "读取错误"

#: src/basenc.c:1074
msgid "invalid input"
msgstr "输入无效"

#: src/basenc.c:1121
msgid "invalid wrap size"
msgstr "无效的换行字符数"

#: src/basenc.c:1218
#, c-format
msgid "missing encoding type"
msgstr "缺少编码类型"

#: src/basenc.c:1256 src/cat.c:764
msgid "closing standard input"
msgstr "关闭标准输入"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:47 src/df.c:48 src/du.c:54 src/factor.c:129
#: src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:38 src/ls.c:136 src/rm.c:42 src/split.c:50
#: src/tee.c:37 src/uniq.c:40
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:88 src/df.c:1511 src/expand.c:69 src/fold.c:66 src/head.c:110
#: src/ls.c:5342 src/nl.c:176 src/paste.c:436 src/pr.c:2737 src/rm.c:133
#: src/sum.c:59 src/tac.c:132 src/tail.c:265 src/tee.c:87 src/unexpand.c:78
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "用法：%s [选项]... [文件]...\n"

#: src/cat.c:92
msgid "Concatenate FILE(s) to standard output.\n"
msgstr "连接所有指定文件并将结果写到标准输出。\n"

#: src/cat.c:98
msgid ""
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"\n"
"  -A, --show-all           等效于 -vET\n"
"  -b, --number-nonblank    对非空输出行编号，同时取消 -n 选项效果\n"
"  -e                       等效于 -vE\n"
"  -E, --show-ends          在每行结束处显示\"$\"\n"
"  -n, --number             对输出的所有行编号\n"
"  -s, --squeeze-blank      不输出多行空行\n"

#: src/cat.c:107
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       与 -vT 等效\n"
"  -T, --show-tabs          将跳格字符显示为^I\n"
"  -u                       (被忽略)\n"
"  -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"示例：\n"
"  %s f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。\n"
"  %s        将标准输入的内容复制到标准输出。\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "无法在 %s 上执行 ioctrl"

#: src/cat.c:638 src/dd.c:2492 src/sort.c:405 src/tail.c:2444 src/tee.c:207
#: src/yes.c:128
#, c-format
msgid "standard output"
msgstr "标准输出"

#: src/cat.c:699
#, c-format
msgid "%s: input file is output file"
msgstr "%s：输入文件是输出文件"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/runcon.c:57
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:38 src/chgrp.c:39 src/chmod.c:40 src/chown.c:38 src/cp.c:49
#: src/cut.c:47 src/dirname.c:33 src/du.c:57 src/head.c:48 src/hostid.c:32
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:44 src/nohup.c:34 src/od.c:40
#: src/pathchk.c:33 src/pwd.c:32 src/rm.c:43 src/sleep.c:34 src/sync.c:33
#: src/tail.c:79 src/tr.c:38 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:101 src/runcon.c:202 src/runcon.c:233
#, c-format
msgid "failed to create security context: %s"
msgstr "创建安全上下文失败：%s"

#: src/chcon.c:113
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "设置 %s 安全上下文组件到 %s 失败"

#: src/chcon.c:157 src/chcon.c:548 src/copy.c:958 src/runcon.c:216
#: src/stat.c:833
#, c-format
msgid "failed to get security context of %s"
msgstr "无法取得%s 的安全上下文"

#: src/chcon.c:167
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "无法对未标记的文件 %s 应用部分（不完整的）上下文"

#: src/chcon.c:191
#, c-format
msgid "failed to change context of %s to %s"
msgstr "改变 %s 的上下文到 %s 失败"

#: src/chcon.c:256 src/chmod.c:218 src/chown-core.c:324 src/copy.c:759
#: src/du.c:533 src/ls.c:3436
#, c-format
msgid "cannot access %s"
msgstr "无法访问 %s"

#: src/chcon.c:267 src/chmod.c:231 src/chown-core.c:337 src/du.c:513
#, c-format
msgid "cannot read directory %s"
msgstr "无法读取目录 %s"

#: src/chcon.c:294
#, c-format
msgid "changing security context of %s\n"
msgstr "正在更改 %s 的安全上下文\n"

#: src/chcon.c:328 src/chmod.c:349 src/chown-core.c:538 src/remove.c:601
#: src/selinux.c:323
#, c-format
msgid "fts_read failed"
msgstr "fts_read 失败"

#: src/chcon.c:339 src/chmod.c:360 src/chown-core.c:550 src/du.c:714
#: src/remove.c:615 src/selinux.c:334
#, c-format
msgid "fts_close failed"
msgstr "fts_close 失败"

#: src/chcon.c:353
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法:  %s [选项]... 上下文 文件...\n"
"　或:  %s [选项]... [-u 用户] [-r 角色] [-l 范围] [-t 类型] 文件...\n"
"　或:  %s [选项]... --reference=参考文件 文件...\n"

#: src/chcon.c:359
msgid ""
"Change the SELinux security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""
"将每个指定<文件>的安全上下文变更至指定<上下文>。\n"
"使用 --reference 选项时，把指定<文件>的安全上下文设置为与<参考文件>相同。\n"

#: src/chcon.c:366 src/chgrp.c:125 src/chown.c:95
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"      --dereference      影响每个符号链接的原始引用文件（这是默认行为），而"
"非\n"
"                         符号链接本身\n"
"  -h, --no-dereference   只影响符号链接，而非被引用的任何文件\n"

#: src/chcon.c:371
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""
"  -u, --user=用户        设置指定<用户>的目标安全上下文\n"
"  -r, --role=角色        设置指定<角色>的目标安全上下文\n"
"  -t, --type=类型        设置指定<类型>的目标安全上下文\n"
"  -l, --range=范围      设置指定<范围>的目标安全上下文\n"
"\n"

#: src/chcon.c:377 src/chgrp.c:134 src/chmod.c:390 src/chown.c:111
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""
"      --no-preserve-root  不特殊对待“/”（默认行为）\n"
"      --preserve-root    不允许在“/”上递归操作\n"

#: src/chcon.c:381
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""
"      --reference=参考文件  使用指定<参考文件>的安全上下文，而非指定<环境>"
"值\n"

#: src/chcon.c:385 src/chgrp.c:142 src/chown.c:119
msgid "  -R, --recursive        operate on files and directories recursively\n"
msgstr "  -R, --recursive        递归操作文件和目录\n"

#: src/chcon.c:388
msgid "  -v, --verbose          output a diagnostic for every file processed\n"
msgstr "  -v, --verbose          为每个处理的文件输出诊断信息\n"

#: src/chcon.c:391 src/chgrp.c:145 src/chown.c:122
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"\n"
"以下选项是在指定了 -R 选项时被用于设置如何遍历目录结构体系。\n"
"如果您指定了多于一个选项，那么只有最后一个会生效。\n"
"\n"
"  -H                     如果命令行参数是一个指向目录的符号链接，则对其\n"
"                         进行遍历\n"
"  -L                     遍历每一个遇到的指向目录的符号链接\n"
"  -P                     不遍历任何符号链接（默认）\n"
"\n"

#: src/chcon.c:518 src/chgrp.c:266 src/chown.c:267
msgid "-R --dereference requires either -H or -L"
msgstr "-R --dereference 需要-H 或-L 其中之一"

#: src/chcon.c:524
msgid "-R -h requires -P"
msgstr "-R -h 需要-P"

#: src/chcon.c:539 src/chgrp.c:281 src/chmod.c:531 src/chown.c:282
#: src/comm.c:483 src/csplit.c:1404 src/join.c:1161 src/link.c:78
#: src/mknod.c:173 src/tr.c:1756
#, c-format
msgid "missing operand after %s"
msgstr "%s 后缺少操作数"

#: src/chcon.c:563 src/runcon.c:250
#, c-format
msgid "invalid context: %s"
msgstr "无效上下文：%s"

#: src/chcon.c:569
#, c-format
msgid "conflicting security context specifiers given"
msgstr "给出的安全上下文说明冲突"

#: src/chcon.c:578 src/chgrp.c:289 src/chgrp.c:307 src/chmod.c:539
#: src/chmod.c:558 src/chown.c:290 src/chown.c:319 src/cp.c:422 src/cp.c:489
#: src/mv.c:99 src/pwd.c:276 src/rm.c:348 src/touch.c:348
#, c-format
msgid "failed to get attributes of %s"
msgstr "无法取得 %s 的属性"

#: src/chgrp.c:93
#, c-format
msgid "invalid group: %s"
msgstr "无效的组：%s"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... 用户组 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"将每个指定<文件>的属组变更至指定<用户组>。\n"
"使用 --reference 选项时，把指定<文件>的属组设置为与<参考文件>相同。\n"
"\n"

#: src/chgrp.c:120 src/chmod.c:385 src/chown.c:90
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -c, --changes          类似 verbose 选项，但仅在做出修改时进行报告\n"
"  -f, --silent, --quiet  不显示大多数错误消息\n"
"  -v, --verbose          输出各个处理的文件的诊断信息\n"

#: src/chgrp.c:130 src/chown.c:100
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"                         (仅当系统支持更改符号链接的所有者时，\n"
"                         该选项才有用）\n"

#: src/chgrp.c:138
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""
"      --reference=参考文件  使用<参考文件>的属组信息而非指定一个\n"
"                            <用户组>的值\n"

#: src/chgrp.c:160
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s staff /u            将 /u 的属组更改为\"staff\"。\n"
"  %s -hR staff /u    将 /u 及其子目录下所有文件的属组更改为\"staff\"。\n"

#: src/chmod.c:127
#, c-format
msgid "getting new attributes of %s"
msgstr "检查 %s 的新属性"

#: src/chmod.c:151 src/chown-core.c:146
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "符号链接 %s 和该链接所指示的对象都未被更改\n"

#: src/chmod.c:165
#, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "%s 的权限模式已由 %04lo (%s) 更改为 %04lo (%s)\n"

#: src/chmod.c:168
#, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr "将 %s 的权限模式从 %04lo (%s) 更改为 %04lo (%s) 时失败\n"

#: src/chmod.c:171
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "%s 的权限模式保留为 %04lo (%s)\n"

#: src/chmod.c:238
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "无法对已断开的符号链接 %s 进行操作"

#: src/chmod.c:278
#, c-format
msgid "changing permissions of %s"
msgstr "正在更改 %s 的权限"

#: src/chmod.c:314
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s：新的权限为 %s，而非 %s"

#: src/chmod.c:374
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... 模式[,模式]... 文件...\n"
"　或：%s [选项]... 八进制模式 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chmod.c:380
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"将每个文件的权限模式变更至指定模式。\n"
"使用 --reference 选项时，把指定文件的模式设置为与参考文件相同。\n"
"\n"

#: src/chmod.c:394
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr "      --reference=参考文件  使用参考文件的模式而非给定模式的值\n"

#: src/chmod.c:397
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr "  -R, --recursive        递归修改文件和目录\n"

#: src/chmod.c:402
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"每个模式字符串都应该匹配如下格式：\"[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=]"
"[0-7]+\"。\n"

#: src/chmod.c:516
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "无法组合使用 mode 和 --reference 选项"

#: src/chmod.c:547
#, c-format
msgid "invalid mode: %s"
msgstr "无效模式：%s"

#: src/chown-core.c:157
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "%s 的所有者已从 %s 更改为 %s\n"

#: src/chown-core.c:158
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "%s 的所属组已从 %s 更改为 %s\n"

#: src/chown-core.c:159
#, c-format
msgid "no change to ownership of %s\n"
msgstr "%s 的归属关系未更改\n"

#: src/chown-core.c:164
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "无法将 %s 的所有者从 %s 更改为 %s\n"

#: src/chown-core.c:165
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "无法将 %s 的所属组从 %s 更改为 %s\n"

#: src/chown-core.c:166 src/chown-core.c:172
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "更改 %s 的所有者失败\n"

#: src/chown-core.c:170
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "无法更改 %s 的所有者为 %s\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "无法更改%s 的所属组为%s\n"

#: src/chown-core.c:179
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "%s 的所有者已保留为%s\n"

#: src/chown-core.c:180
#, c-format
msgid "group of %s retained as %s\n"
msgstr "%s 的所属组已保留为%s\n"

#: src/chown-core.c:181
#, c-format
msgid "ownership of %s retained\n"
msgstr "%s 的所有权已保留\n"

#: src/chown-core.c:378
#, c-format
msgid "cannot dereference %s"
msgstr "无法取消%s 的引用"

#: src/chown-core.c:466
#, c-format
msgid "changing ownership of %s"
msgstr "正在更改%s 的所有者"

#: src/chown-core.c:467
#, c-format
msgid "changing group of %s"
msgstr "正在更改%s 的所属组"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"用法：%s [选项]... [所有者][:[组]] 文件...\n"
"　或：%s [选项]... --reference=参考文件 文件...\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""
"修改每个<文件>的所有者和/或所属组为给定的<所有者>和/或<组>。\n"
"如同时使用 --reference，将每个给定<文件>的所有者和属组修改为<参考文件>\n"
"所具有的对应值。\n"

#: src/chown.c:104
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=当前所有者:当前所属组\n"
"                         \t只当每个文件的所有者和组符合选项所指定时才更改所\n"
"\t\t\t\t有者和组。其中一个可以省略，这时已省略的属性就不\n"
"\t\t\t\t需要符合原有的属性。\n"

#: src/chown.c:115
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""
"      --reference=<参考文件>  使用指定<参考文件>的所有者和所属组信息，而非\n"
"                         手工指定 所有者:组 的值\n"

#: src/chown.c:137
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"如果没有指定所有者，则不会更改所有者信息。若所属组若没有指定也不会对其更"
"改，\n"
"但当加上 ':' 时 GROUP 会更改为指定所有者的主要组。所有者和所属组可以是\n"
"数字或名称。\n"

#: src/chown.c:143
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"示例：\n"
"  %s root /u\t\t将 /u 的属主更改为\"root\"。\n"
"  %s root:staff /u\t和上面类似，但同时也将其属组更改为\"staff\"。\n"
"  %s -hR root /u\t将 /u 及其子目录下所有文件的属主更改为\"root\"。\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:39
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:139 src/install.c:608
#, c-format
msgid "invalid group %s"
msgstr "无效的组%s"

#: src/chroot.c:154
#, c-format
msgid "invalid group list %s"
msgstr "无效的组列表%s"

#: src/chroot.c:187
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [选项] 新根 [命令 [参数]...]\n"
"　或：%s 选项\n"

#: src/chroot.c:192
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"以指定的<新根>作为运行指定<命令>时的的根目录。\n"
"\n"

#: src/chroot.c:197
msgid "  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr "  --groups=组列表         指定附加用户组，形如 组1,组2,组3...,组N\n"

#: src/chroot.c:200
msgid "  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
msgstr "  --userspec=用户:组      指定用户及用户组（可使用编号或名称）\n"

#: src/chroot.c:203
#, c-format
msgid "  --skip-chdir           do not change working directory to %s\n"
msgstr "  --skip-chdir           不要将工作目录变更为 %s\n"

#: src/chroot.c:209
msgid ""
"\n"
"If no command is given, run '\"$SHELL\" -i' (default: '/bin/sh -i').\n"
msgstr ""
"\n"
"如果没有给定命令，则运行 '\"${SHELL}\" -i'）（默认：'/bin/sh -i'）。\n"

#: src/chroot.c:288
#, c-format
msgid "option --skip-chdir only permitted if NEWROOT is old %s"
msgstr "选项 --skip-chdir 只能在指定<新根>为旧有的 %s 时使用"

#: src/chroot.c:331
#, c-format
msgid "cannot change root directory to %s"
msgstr "无法将根目录更改为 %s"

#: src/chroot.c:335
msgid "cannot chdir to root directory"
msgstr "无法切换到根目录"

#: src/chroot.c:377
#, c-format
msgid "no group specified for unknown uid: %d"
msgstr "没有为未知 UID 指定组：%d"

#: src/chroot.c:402
msgid "failed to get supplemental groups"
msgstr "获取附加组失败"

#: src/chroot.c:414
msgid "failed to set supplemental groups"
msgstr "设置附加组失败"

#: src/chroot.c:420
msgid "failed to set group-ID"
msgstr "设置组ID 失败"

#: src/chroot.c:423
msgid "failed to set user-ID"
msgstr "设置用户ID 失败"

#: src/chroot.c:429 src/nohup.c:222 src/stdbuf.c:392 src/timeout.c:519
#, c-format
msgid "failed to run command %s"
msgstr "无法运行命令 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:210
#, c-format
msgid "%s: file too long"
msgstr "%s：文件太大"

#: src/cksum.c:257
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"用法：%s [文件]...\n"
"　或：%s [选项]\n"

#: src/cksum.c:262
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"输出每个文件的 CRC 校验值和字节统计。\n"
"\n"

#: src/comm.c:112 src/join.c:192
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "用法：%s [选项]... 文件1 文件2\n"

#: src/comm.c:116
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "逐行比较已排序的文件文件1 和文件2。\n"

#: src/comm.c:119 src/join.c:201
msgid ""
"\n"
"When FILE1 or FILE2 (not both) is -, read standard input.\n"
msgstr ""
"\n"
"如果<文件1>或<文件2>是\"-\"时（不含两者均为\"-\"的情况），将从标准输入读"
"取。\n"

#: src/comm.c:123
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"如果不附带选项，程序会生成三列输出。第一列包含文件1 特有的行，第二列包含 文件"
"2 特有的行，而第三列包含两个文件共有的行。\n"

#: src/comm.c:129
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1\t\t不输出文件1 特有的行\n"
"  -2\t\t不输出文件2 特有的行\n"
"  -3\t\t不输出两个文件共有的行\n"

#: src/comm.c:135
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order\t\t\t检查输入是否被正确排序，即使所有输入行均成对\n"
"  --nocheck-order\t\t不检查输入是否被正确排序\n"

#: src/comm.c:141
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=STR\t依照STR 分列\n"

#: src/comm.c:144
msgid "  --total           output a summary\n"
msgstr "  --total           输出一份摘要信息\n"

#: src/comm.c:147 src/cut.c:178 src/head.c:134 src/numfmt.c:945 src/paste.c:452
#: src/tail.c:312
msgid "  -z, --zero-terminated    line delimiter is NUL, not newline\n"
msgstr "  -z, --zero-terminated    以 NUL 字符而非换行符作为行尾分隔符\n"

#: src/comm.c:152
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"注意，比较操作遵从“LC_COLLATE”所指定的规则。\n"

#: src/comm.c:156
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"示例：\n"
"  %s -12 文件1 文件2  只打印在文件1 和文件2 中都有的行\n"
"  %s -3  文件1 文件2  打印在文件1 中有，而文件2 中没有的行。反之亦然。\n"

#: src/comm.c:238
#, c-format
msgid "file %d is not in sorted order"
msgstr "文件%d 没有被正确排序"

#: src/comm.c:402 src/du.c:1137 src/ls.c:3067 src/wc.c:885
msgid "total"
msgstr "总用量"

#: src/comm.c:458
msgid "multiple output delimiters specified"
msgstr "指定了多个输出分隔符"

#: src/comm.c:496 src/join.c:1195
msgid "input is not in sorted order"
msgstr "输入没有被正确排序"

#: src/copy.c:230 src/copy.c:499
#, c-format
msgid "cannot lseek %s"
msgstr "无法lseek %s"

#: src/copy.c:240 src/copy.c:605
#, c-format
msgid "error deallocating %s"
msgstr "取消分配 %s 时出错"

#: src/copy.c:278 src/dd.c:1928 src/dd.c:2264 src/du.c:1134 src/head.c:157
#: src/head.c:308 src/head.c:390 src/head.c:586 src/head.c:668 src/head.c:737
#: src/head.c:787 src/head.c:810 src/tail.c:464 src/tail.c:557 src/tail.c:606
#: src/tail.c:699 src/tail.c:827 src/tail.c:875 src/tail.c:912 src/tail.c:2037
#: src/tail.c:2070 src/uniq.c:461
#, c-format
msgid "error reading %s"
msgstr "读取 %s 时出错"

#: src/copy.c:311 src/dd.c:2327 src/dd.c:2389 src/head.c:185 src/tail.c:438
#, c-format
msgid "error writing %s"
msgstr "写入 %s 出错"

#: src/copy.c:340
#, c-format
msgid "overflow reading %s"
msgstr "读取 %s 时溢出"

#: src/copy.c:453
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s：无法获得 extent 信息"

#: src/copy.c:525
#, c-format
msgid "%s: write failed"
msgstr "%s：写入失败"

#: src/copy.c:598 src/copy.c:1342
#, c-format
msgid "failed to extend %s"
msgstr "扩展%s 失败"

#: src/copy.c:840
#, c-format
msgid "clearing permissions for %s"
msgstr "清除%s 的权限"

#: src/copy.c:875 src/copy.c:2791 src/cp.c:318
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "无法保留%s 的所有者"

#: src/copy.c:901
#, c-format
msgid "failed to lookup file %s"
msgstr "查阅文件%s 失败"

#: src/copy.c:906
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "保留%s 的作者失败"

#: src/copy.c:943 src/cp.c:1205 src/install.c:961 src/mkdir.c:269
#: src/mkfifo.c:144 src/mknod.c:200
#, c-format
msgid "failed to set default file creation context to %s"
msgstr "无法设置默认文件创建上下文至 %s"

#: src/copy.c:973
#, c-format
msgid "failed to set default file creation context for %s"
msgstr "无法设置 %s 的默认文件创建上下文"

#: src/copy.c:999
#, c-format
msgid "failed to set the security context of %s"
msgstr "设置 %s 的安全上下文失败"

#: src/copy.c:1072 src/csplit.c:655 src/du.c:1026 src/fmt.c:439 src/head.c:889
#: src/split.c:1570 src/tail.c:2011 src/wc.c:770
#, c-format
msgid "cannot open %s for reading"
msgstr "无法打开%s 读取数据"

#: src/copy.c:1078 src/copy.c:1231 src/dd.c:1853 src/dd.c:2401 src/dd.c:2536
#: src/head.c:848 src/tail.c:1851 src/tail.c:1914 src/truncate.c:114
#, c-format
msgid "cannot fstat %s"
msgstr "无法获取%s 的文件状态(fstat)"

#: src/copy.c:1088
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "跳过文件%s，因为在准备复制时它已被其它文件取代"

#: src/copy.c:1128 src/copy.c:2221 src/remove.c:263 src/remove.c:280
#: src/remove.c:406 src/remove.c:432
#, c-format
msgid "cannot remove %s"
msgstr "无法删除 %s"

#: src/copy.c:1133 src/copy.c:1830 src/copy.c:2226 src/remove.c:376
#, c-format
msgid "removed %s\n"
msgstr "已删除 %s\n"

#: src/copy.c:1185
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "无法通过符号链接%s 进行操作"

#: src/copy.c:1223
#, c-format
msgid "cannot create regular file %s"
msgstr "无法创建普通文件%s"

#: src/copy.c:1244
#, c-format
msgid "failed to clone %s from %s"
msgstr "克隆 %s（从 %s 进行）失败"

#: src/copy.c:1357 src/copy.c:2866
#, c-format
msgid "preserving times for %s"
msgstr "正在保留 %s 的时间"

#: src/copy.c:1437 src/copy.c:1443 src/head.c:897 src/sync.c:164
#: src/touch.c:173 src/truncate.c:381
#, c-format
msgid "failed to close %s"
msgstr "关闭 %s 失败"

#: src/copy.c:1719
#, c-format
msgid "%s: replace %s, overriding mode %04lo (%s)? "
msgstr "%s：是否替换 %s，而忽略模式 %04lo (%s)？"

#: src/copy.c:1720
#, c-format
msgid "%s: unwritable %s (mode %04lo, %s); try anyway? "
msgstr "%s：%s 不可写(权限%04lo，%s)；依然尝试？ "

#: src/copy.c:1727
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s：是否覆盖%s？ "

#: src/copy.c:1797
#, c-format
msgid " (backup: %s)"
msgstr " (备份：%s)"

#: src/copy.c:1807
msgid "failed to restore the default file creation context"
msgstr "恢复默认文件创建上下文失败"

#: src/copy.c:1825
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "无法创建指向%2$s 的硬链接%1$s"

#: src/copy.c:1936
#, c-format
msgid "-r not specified; omitting directory %s"
msgstr "未指定 -r；略过目录%s"

#: src/copy.c:1937
#, c-format
msgid "omitting directory %s"
msgstr "略过目录 %s"

#: src/copy.c:1960
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "警告：指定来源文件%s 多于一次"

#: src/copy.c:2015 src/ln.c:275
#, c-format
msgid "%s and %s are the same file"
msgstr "%s 与%s 为同一文件"

#: src/copy.c:2105
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "无法以目录%2$s 来覆盖非目录%1$s"

#: src/copy.c:2123 src/ln.c:246
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "不会以%2$s 覆盖刚创建的%1$s"

#: src/copy.c:2141
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "无法以非目录来覆盖目录%s"

#: src/copy.c:2155
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "无法将目录移动至非目录：%s -> %s"

#: src/copy.c:2182
#, c-format
msgid "backing up %s might destroy source;  %s not moved"
msgstr "备份 %s 可能破坏源文件；未移动 %s"

#: src/copy.c:2183
#, c-format
msgid "backing up %s might destroy source;  %s not copied"
msgstr "备份 %s 可能破坏源文件；未复制 %s"

#: src/copy.c:2205 src/ln.c:305
#, c-format
msgid "cannot backup %s"
msgstr "无法备份 %s"

#: src/copy.c:2260
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "不会以%s 覆盖刚创建的%s"

#: src/copy.c:2340
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "无法将目录%s 复制到自己%s"

#: src/copy.c:2348
#, c-format
msgid "warning: source directory %s specified more than once"
msgstr "警告：指定来源目录 %s 多于一次"

#: src/copy.c:2374
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "不会创建指向目录%2$s 的硬链接%1$s"

#: src/copy.c:2398
#, c-format
msgid "renamed "
msgstr "已重命名 "

#: src/copy.c:2436
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "无法将目录%s 移动至自身的子目录%s 下"

#: src/copy.c:2479
#, c-format
msgid "cannot move %s to %s"
msgstr "无法将%s 移动至%s"

#: src/copy.c:2495
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr "无法进行跨设备的移动：%s 至%s；无法删除目标"

#: src/copy.c:2503
#, c-format
msgid "copied "
msgstr "已复制 "

#: src/copy.c:2540
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "无法复制循环的符号链接%s"

#: src/copy.c:2602
#, c-format
msgid "created directory %s\n"
msgstr "已创建目录 %s\n"

#: src/copy.c:2665
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr "%s：只能于当前目录中创建相对的符号链接"

#: src/copy.c:2675
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "无法创建指向%2$s 的符号链接%1$s"

#: src/copy.c:2729 src/mkfifo.c:170
#, c-format
msgid "cannot create fifo %s"
msgstr "无法创建先进先出文件%s"

#: src/copy.c:2738
#, c-format
msgid "cannot create special file %s"
msgstr "无法创建特殊文件%s"

#: src/copy.c:2749 src/ls.c:3648 src/stat.c:1477
#, c-format
msgid "cannot read symbolic link %s"
msgstr "无法读取符号链接%s"

#: src/copy.c:2775
#, c-format
msgid "cannot create symbolic link %s"
msgstr "无法创建符号链接%s"

#: src/copy.c:2807
#, c-format
msgid "%s has unknown file type"
msgstr "%s 的文件类型不详"

#: src/copy.c:2972 src/ln.c:393
#, c-format
msgid "cannot un-backup %s"
msgstr "无法将%s 的备份还原"

#: src/copy.c:2976
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (还原备份)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/coreutils.c:48
msgid "Alex Deymo"
msgstr "Alex Deymo"

#: src/coreutils.c:65
#, c-format
msgid "Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"
msgstr "用法：%s --coreutils-prog=程序名称 [参数]... \n"

#: src/coreutils.c:68
msgid ""
"Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n"
"\n"
msgstr "使用给定<参数>执行指定<程序名称>对应的内建程序。\n"

#: src/coreutils.c:86
#, c-format
msgid ""
"\n"
"Use: '%s --coreutils-prog=PROGRAM_NAME --help' for individual program help.\n"
msgstr ""
"\n"
"使用：'%s --coreutils-prog=程序名称 --help' 以获取独立程序的帮助信息。\n"

#: src/coreutils.c:178 src/coreutils.c:203
#, c-format
msgid "unknown program %s"
msgstr "未知程序 %s"

#: src/cp.c:148 src/mv.c:292
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"用法：%s [选项]... [-T] 源文件 目标文件\n"
"　或：%s [选项]... 源文件... 目录\n"
"　或：%s [选项]... -t 目录 源文件...\n"

#: src/cp.c:154
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr "将指定<源文件>复制至<目标文件>，或将多个<源文件>复制至<目标目录>。\n"

#: src/cp.c:160
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive\t\t\t等于-dR --preserve=all\n"
"      --attributes-only\t仅复制属性而不复制数据      --backup[=CONTROL\t\t为"
"每个已存在的目标文件创建备份\n"
"  -b\t\t\t\t类似--backup 但不接受参数\n"
"      --copy-contents\t\t在递归处理是复制特殊文件内容\n"
"  -d\t\t\t\t等于--no-dereference --preserve=links\n"

#: src/cp.c:169
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  如果有已存在的目标文件且无法打开，则将其删除并"
"重试\n"
"                                 （该选项在与 -n 选项同时使用时将被忽略）\n"
"  -i, --interactive            覆盖前询问（使前面的 -n 选项失效）\n"
"  -H                           跟随源文件中的命令行符号链接\n"

#: src/cp.c:178
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   硬链接文件以代替复制\n"
"  -L, --dereference            总是跟随源文件中的符号链接\n"

#: src/cp.c:182
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber\t\t不要覆盖已存在的文件(使前面的 -i 选项失效)\n"
"  -P, --no-dereference\t\t不跟随源文件中的符号链接\n"

#: src/cp.c:187
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p\t\t\t\t等于--preserve=模式,所有权,时间戳\n"
"      --preserve[=属性列表\t保持指定的属性(默认：模式,所有权,时间戳)，如果\n"
"\t\t\t\t\t可能保持附加属性：上下文、链接、xattr 等\n"

#: src/cp.c:195
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --sno-preserve=属性列表\t不保留指定的文件属性\n"
"      --parents\t\t\t复制前在目标目录创建来源文件路径中的所有目录\n"

#: src/cp.c:199
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive\t\t递归复制目录及其子目录内的所有内容\n"
"      --reflink[=WHEN]\t\t控制克隆/CoW 副本。请查看下面的内如。\n"
"      --remove-destination\t尝试打开目标文件前先删除已存在的目的地\n"
"\t\t\t\t\t文件 (相对于 --force 选项)\n"

#: src/cp.c:205
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=WHEN\t\t控制创建稀疏文件的方式\n"
"      --strip-trailing-slashes\t删除参数中所有源文件/目录末端的斜杠\n"

#: src/cp.c:210
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link\t\t只创建符号链接而不复制文件\n"
"  -S, --suffix=后缀\t\t自行指定备份文件的后缀\n"
"  -t,  --target-directory=目录\t将所有参数指定的源文件/目录\n"
"                                           复制至目标目录\n"
"  -T, --no-target-directory\t将目标目录视作普通文件\n"

#: src/cp.c:216
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update\t\t\t只在源文件比目标文件新，或目标文件\n"
"\t\t\t\t\t不存在时才进行复制\n"
"  -v, --verbose\t\t显示详细的进行步骤\n"
"  -x, --one-file-system\t不跨越文件系统进行操作\n"

#: src/cp.c:223
msgid ""
"  -Z                           set SELinux security context of destination\n"
"                                 file to default type\n"
"      --context[=CTX]          like -Z, or if CTX is specified then set the\n"
"                                 SELinux or SMACK security context to CTX\n"
msgstr ""
"  -Z                           设置目标文件的 SELinux 安全上下文为默认类型\n"
"      --context[=上下文]       类似 -Z；如果指定了上下文，则将 SELinux 或\n"
"                                 SMACK 安全上下文设置为指定值\n"

#: src/cp.c:231
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
msgstr ""
"\n"
"默认情况下，源文件的稀疏性仅仅通过简单的方法判断，对应的目标文件目标文件\n"
"也将设为稀疏。这是因为默认情况下使用了--sparse=auto 参数。如果明确使用\n"
"--sparse=always 参数，则不论源文件是否包含足够长的 0 序列，都会将目标文件\n"
"创建为稀疏文件。使用 --sparse=never 参数可以禁止创建稀疏文件。\n"

#: src/cp.c:239
msgid ""
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
"Use --reflink=never to ensure a standard copy is performed.\n"
msgstr ""
"\n"
"当指定了 --reflink[=always] 参数时，将进行轻量级复制，此时数据块只在被修改"
"时\n"
"进行复制，如果无法如此操作则复制将会失败。或者如果指定了 --reflink=auto，程"
"序\n"
"将会回退到标准复制操作。使用 --reflink=never 可以确保永远进行标准复制。\n"

#: src/cp.c:247
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"有一个特别情况：如果同时指定--force 和--backup 选项，而源文件和目标文件\n"
"是同一个已存在的一般文件的话，cp 会将源文件备份。\n"

#: src/cp.c:306
#, c-format
msgid "failed to preserve times for %s"
msgstr "无法保留 %s 的时间"

#: src/cp.c:337
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "保留 %s 的权限失败"

#: src/cp.c:473
#, c-format
msgid "cannot make directory %s"
msgstr "无法创建目录 %s"

#: src/cp.c:522 src/cp.c:553
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s 存在但并非目录"

#: src/cp.c:585 src/cp.c:1087 src/install.c:407 src/install.c:942 src/ln.c:204
#: src/ln.c:231 src/ln.c:536 src/mv.c:160 src/mv.c:393
#, c-format
msgid "failed to access %s"
msgstr "访问 %s 失败"

#: src/cp.c:606 src/install.c:970 src/ln.c:567 src/mv.c:436 src/shred.c:1251
#: src/touch.c:430 src/truncate.c:318
#, c-format
msgid "missing file operand"
msgstr "缺少了文件操作数"

#: src/cp.c:608 src/install.c:972 src/ln.c:590 src/mv.c:438
#, c-format
msgid "missing destination file operand after %s"
msgstr "在%s 后缺少了要操作的目标文件"

#: src/cp.c:617 src/install.c:981 src/mv.c:447
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr "无法同时使用--target-directory (-t) 和--no-target-directory (-T) 选项"

#: src/cp.c:635 src/cp.c:1090 src/install.c:409 src/install.c:945
#: src/install.c:994 src/ln.c:539 src/mv.c:396 src/mv.c:468
#, c-format
msgid "target %s is not a directory"
msgstr "目标%s 不是目录"

#: src/cp.c:745
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "当跟随--parents 选项时，目的地必须是目录"

#: src/cp.c:1082 src/install.c:882 src/ln.c:531 src/mv.c:388
msgid "multiple target directories specified"
msgstr "指定了多个目标目录"

#: src/cp.c:1124 src/install.c:918
#, c-format
msgid "warning: ignoring --context; it requires an SELinux-enabled kernel"
msgstr "警告：忽略 --context 参数；它需要启用 SELinux 的内核"

#: src/cp.c:1145
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "无法同时创建硬链接及符号链接"

#: src/cp.c:1155 src/mv.c:478
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "选项--backup 和 --no-clobber 互斥"

#: src/cp.c:1161
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "--reflink 只能与--sparse=auto 一起用"

#: src/cp.c:1166 src/install.c:950 src/ln.c:637 src/mv.c:483
msgid "backup type"
msgstr "备份方式"

#: src/cp.c:1190 src/install.c:957
msgid "cannot set target context and preserve it"
msgstr "无法设置目标上下文并将其保存"

#: src/cp.c:1194
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "无法在未启用 SELinux 支持的内核上保存安全上下文"

#: src/cp.c:1210
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr "无法保留扩展属性，当前使用的 cp 副本编译时没有启用 xattr 支持"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:44 src/dd.c:46
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:545
msgid "input disappeared"
msgstr "输入消失"

#: src/csplit.c:676 src/csplit.c:688
#, c-format
msgid "%s: line number out of range"
msgstr "%s：行数超出范围"

#: src/csplit.c:718
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s：%s：行数超出范围"

#: src/csplit.c:721 src/csplit.c:777
#, c-format
msgid " on repetition %s\n"
msgstr " 在循环位%s\n"

#: src/csplit.c:771
#, c-format
msgid "%s: %s: match not found"
msgstr "%s：%s：无匹配"

#: src/csplit.c:838 src/csplit.c:878 src/nl.c:357 src/tac.c:286
#, c-format
msgid "error in regular expression search"
msgstr "正则表达式搜索时出错"

#: src/csplit.c:1007 src/csplit.c:1054
#, c-format
msgid "write error for %s"
msgstr "写入%s 时出错"

#: src/csplit.c:1089
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s：分界符后应该跟随整数"

#: src/csplit.c:1106
#, c-format
msgid "%s: '}' is required in repeat count"
msgstr "%s：在重复计数中需要\"}\"字符"

#: src/csplit.c:1117
#, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr "%s}：在\"{\"和\"}\"之间需要一个整数声明"

#: src/csplit.c:1144
#, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr "%s：闭合分界符“%c”缺失"

#: src/csplit.c:1161
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s：无效的正则表达式：%s"

#: src/csplit.c:1193
#, c-format
msgid "%s: invalid pattern"
msgstr "%s：无效的模式"

#: src/csplit.c:1196
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s：行号必须大于0"

#: src/csplit.c:1201
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "行号%s 比先前的行号%s 更小"

#: src/csplit.c:1207
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "警告：行号%s 比先前的行号更小"

#: src/csplit.c:1285
msgid "missing conversion specifier in suffix"
msgstr "下标中丢失了转换规格"

#: src/csplit.c:1290
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "下标中出现无效的转换规格：%c"

#: src/csplit.c:1293
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "下标中出现无效的转换规格：\\%.3o"

#: src/csplit.c:1298
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "无效的转换声明%%%c%c"

#: src/csplit.c:1315
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "下标中出现过多的%% 转换规格字符"

#: src/csplit.c:1329
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "下标中丢失了%% 转换规格字符"

#: src/csplit.c:1375 src/dd.c:1563 src/nproc.c:105 src/tail.c:2164
msgid "invalid number"
msgstr "无效的数字"

#: src/csplit.c:1482
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "用法：%s [选项]... 文件 格式...\n"

#: src/csplit.c:1486
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""
"按照指定的格式将文件分块为\"xx00\"、\"xx01\"...并输出。\n"
"同时每个分块文件的字节数也将被输出到标准输出。\n"

#: src/csplit.c:1490
msgid ""
"\n"
"Read standard input if FILE is -\n"
msgstr ""
"\n"
"如果文件为“-”，则读取标准输入。\n"

#: src/csplit.c:1497
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=格式  使用 sprintf 格式字符串代替 %02d\n"
"  -f, --prefix=前缀        使用指定前缀代替\"xx\"\n"
"  -k, --keep-files           不移除错误的输出文件\n"

#: src/csplit.c:1502
msgid "      --suppress-matched     suppress the lines matching PATTERN\n"
msgstr "      --suppress-matched     不显示匹配格式字符串的行\n"

#: src/csplit.c:1505
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=数位\t\t使用指定的进制数位代替二进制\n"
"  -s, --quiet, --silent\t不显示输出文件的尺寸计数\n"
"  -z, --elide-empty-files\t删除空的输出文件\n"

#: src/csplit.c:1512
msgid ""
"\n"
"Each PATTERN may be:\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required '+' or '-' followed by a positive integer.\n"
msgstr ""
"\n"
"每个指定的格式可以为：\n"
"  整数               复制至指定行号（不包括该行）\n"
"  /正则/[偏移量]     复制至匹配行（不包括该行）\n"
"  %正则%[偏移量]     跳过直至匹配行（不包括该行）\n"
"  {整数}             将之前指定的模式重复指定的次数\n"
"  {*}                将之前指定的模式重复尽可能多的次数\n"
"\n"
"一个行的偏移量需要在正整数值之前声明 '+' 或 '-'。\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:45 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:147
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "用法：%s [选项]... [文件]...\n"

#: src/cut.c:151
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr "从每个输入<文件>中输出指定部分到标准输出。\n"

#: src/cut.c:158
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=列表\t\t只选中指定的这些字节\n"
"  -c, --characters=列表\t\t只选中指定的这些字符\n"
"  -d, --delimiter=分界符\t使用指定分界符代替制表符作为区域分界\n"

#: src/cut.c:163
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=列表\t\t只选中指定的这些域；并打印所有不包含分界符的\n"
"\t\t\t\t行，除非-s 选项被指定\n"
"  -n\t\t\t\t(忽略)\n"

#: src/cut.c:169
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr "      --complement\t\t补全选中的字节、字符或域\n"

#: src/cut.c:173
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited\t\t不打印没有包含分界符的行\n"
"      --output-delimiter=字符串\t使用指定的字符串作为输出分界符，默认采用输"
"入\n"
"\t\t\t\t的分界符\n"

#: src/cut.c:183
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"仅使用f -b, -c 或-f 中的一个。每一个列表都是专门为一个类别作出的，或者您可以"
"用逗号隔\n"
"开要同时显示的不同类别。您的输入顺序将作为读取顺序，每个仅能输入一次。\n"

#: src/cut.c:189
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
msgstr ""
"每种参数格式表示范围如下：\n"
"    N     从第1个开始数的第N个字节、字符或域\n"
"    N-    从第N个开始到所在行结束的所有字符、字节或域\n"
"    N-M   从第N个开始到第M个之间(包括第M个)的所有字符、字节或域\n"
"    -M    从第1个开始到第M个之间(包括第M个)的所有字符、字节或域\n"

#: src/cut.c:511 src/cut.c:519
msgid "only one type of list may be specified"
msgstr "只能指定列表中的一种类型"

#: src/cut.c:528 src/numfmt.c:1521
msgid "the delimiter must be a single character"
msgstr "分界符必须是单个字符"

#: src/cut.c:567
msgid "you must specify a list of bytes, characters, or fields"
msgstr "您必须指定一组字节、字符或域的列表"

#: src/cut.c:570
msgid "an input delimiter may be specified only when operating on fields"
msgstr "只有当操作域时才可以指定输入分界符"

#: src/cut.c:574
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"清除没有分界符的行仅在\n"
"\t操作域时才有意义"

#: src/date.c:130
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"用法：%s [选项]... [+格式]\n"
"　或：%s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"

#: src/date.c:135
msgid "Display the current time in the given FORMAT, or set the system date.\n"
msgstr "以给定<格式>字符串的形式显示当前时间，或者设置系统日期。\n"

#: src/date.c:141
msgid ""
"  -d, --date=STRING          display time described by STRING, not 'now'\n"
msgstr ""
"  -d, --date=字符串          显示给定<字符串>描述的时间，而非“当前时间”\n"

#: src/date.c:144
msgid ""
"      --debug                annotate the parsed date,\n"
"                              and warn about questionable usage to stderr\n"
msgstr ""
"      --debug                对解析的日期添加注释，\n"
"                              对不规范的使用方式进行警告，并输出警告信息到\n"
"                              标准错误\n"

#: src/date.c:148
msgid ""
"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\n"
msgstr ""
"  -f, --file=日期文件        类似 --date；使用给定<日期文件>，一次处理一行\n"

#: src/date.c:151
msgid ""
"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n"
"                               FMT='date' for date only (the default),\n"
"                               'hours', 'minutes', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14T02:34:56-06:00\n"
msgstr ""
"  -I[FMT], --iso-8601[=FMT]  以 ISO 8601 格式输出日期/时间。\n"
"                               FMT='date' 时只输出日期（默认行为），\n"
"                               当其为 'hours'、'minutes'、'seconds' 或 'ns' "
"时\n"
"                               则按照所指示的精确度显示日期和时间。\n"
"                               示例：2006-08-14T02:34:56-06:00\n"

#: src/date.c:158
msgid ""
"  -R, --rfc-email            output date and time in RFC 5322 format.\n"
"                               Example: Mon, 14 Aug 2006 02:34:56 -0600\n"
msgstr ""
"  -R, --rfc-email            以 RFC 5322 格式输出日期和时间。\n"
"                               例如：Mon, 14 Aug 2006 02:34:56 -0600\n"

#: src/date.c:162
msgid ""
"      --rfc-3339=FMT         output date/time in RFC 3339 format.\n"
"                               FMT='date', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14 02:34:56-06:00\n"
msgstr ""
"      --rfc-3339=格式        以 RFC 3339 格式输出日期/时间。\n"
"                               <格式>字符串可以是'date'、'seconds' 或 "
"'ns'，\n"
"                               用于指定日期和时间显示的精确度。\n"
"                               例如：2006-08-14 02:34:56-06:00\n"

#: src/date.c:168
msgid ""
"  -r, --reference=FILE       display the last modification time of FILE\n"
msgstr "  -r, --reference=文件       显示指定<文件>的最后修改时间\n"

#: src/date.c:171
msgid ""
"  -s, --set=STRING           set time described by STRING\n"
"  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n"
msgstr ""
"  -s, --set=字符串           按照给定<字符串>描述的时间来设置时间\n"
"  -u, --utc, --universal     按照协调世界时（UTC）显示或设置时间\n"

#: src/date.c:177
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"给定的格式FORMAT 控制着输出，解释序列如下：\n"
"\n"
"  %%\t一个文字的 %\n"
"  %a\t当前locale 的星期名缩写(例如： 日，代表星期日)\n"

#: src/date.c:184
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A\t当前locale 的星期名全称 (如：星期日)\n"
"  %b\t当前locale 的月名缩写 (如：一，代表一月)\n"
"  %B\t当前locale 的月名全称 (如：一月)\n"
"  %c\t当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)\n"

#: src/date.c:190
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C\t世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)\n"
"  %d\t按月计的日期(例如：01)\n"
"  %D\t按月计的日期；等于%m/%d/%y\n"
"  %e\t按月计的日期，添加空格，等于%_d\n"

#: src/date.c:196
msgid ""
"  %F   full date; like %+4Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   完整日期格式，等价于 %+4Y-%m-%d\n"
"  %g   ISO-8601 格式年份的最后两位（参见 %G）\n"
"  %G   ISO-8601 格式年份（参见 %V），一般只和 %V 结合使用\n"

#: src/date.c:201
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h\t等于%b\n"
"  %H\t小时(00-23)\n"
"  %I\t小时(00-12)\n"
"  %j\t按年计的日期(001-366)\n"

#: src/date.c:207
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   小时，空格补充空白位（ 0..23）；与 %_H 相同\n"
"  %l   小时，空格补充空白位（ 1..12）；与 %_I 相同\n"
"  %m   月份（01..12）\n"
"  %M   分钟（00..59）\n"

#: src/date.c:213
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %q   quarter of year (1..4)\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n   换行\n"
"  %N   纳秒（000000000..999999999）\n"
"  %p   当前地区时间设置中 AM 或 PM 的等效值（“上午”或“下午”），未知则为空\n"
"  %P   类似 %p，但使用小写\n"
"  %q   一年中的季度（1..4）\n"
"  %r   当前地区时间中十二小时制钟表时间（例如，下午 11时11分04秒）\n"
"  %R   24 小时制的时间和分钟；和 %H:%M 相同\n"
"  %s   1970-01-01 00:00:00 UTC 以来的秒数\n"

#: src/date.c:223
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S\t秒(00-60)\n"
"  %t\t输出制表符 Tab\n"
"  %T\t时间，等于%H:%M:%S\n"
"  %u\t星期，1 代表星期一\n"

#: src/date.c:229
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U\t一年中的第几周，以周日为每星期第一天(00-53)\n"
"  %V\tISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)\n"
"  %w\t一星期中的第几日(0-6)，0 代表周一\n"
"  %W\t一年中的第几周，以周一为每星期第一天(00-53)\n"

#: src/date.c:235
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x\t当前locale 下的日期描述 (如：12/31/99)\n"
"  %X\t当前locale 下的时间描述 (如：23:13:48)\n"
"  %y\t年份最后两位数位 (00-99)\n"
"  %Y\t年份\n"

#: src/date.c:241
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z +hhmm\t\t数字时区(例如，-0400)\n"
"  %:z +hh:mm\t\t数字时区(例如，-04:00)\n"
"  %::z +hh:mm:ss\t数字时区(例如，-04:00:00)\n"
"  %:::z\t\t\t数字时区带有必要的精度 (例如，-04，+05:30)\n"
"  %Z\t\t\t按字母表排序的时区缩写 (例如，EDT)\n"
"\n"
"默认情况下，日期的数字区域以0 填充。\n"

#: src/date.c:250
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  +  pad with zeros, and put '+' before future years with >4 digits\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"以下可选标记可以跟在\"%\"后：\n"
"\n"
"  -  （连字符）不填充该域\n"
"  _  （下划线）以空格填充\n"
"  0  （数字0）以 0 填充\n"
"  +  以零填充，并且在大于四个数位的未来年份之前放置 '+' 符号\n"
"  ^  如果可能，使用大写字母\n"
"  #  如果可能，使用相反的大小写\n"

#: src/date.c:260
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"在任何标记之后还允许一个可选的域宽度指定，它是一个十进制数字。\n"
"作为一个可选的修饰声明，它可以是E，在可能的情况下使用本地环境关联的\n"
"表示方式；或者是O，在可能的情况下使用本地环境关联的数字符号。\n"

#: src/date.c:267
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""
"\n"
"示例：\n"
"将 epoch（1970-01-01 UTC）以来的秒数转换为日期\n"
"  $ date --date='@2147483647'\n"
"\n"
"显示美国东海岸的当前时间（请使用 tzselect(1) 来查询 TZ 的具体数值）\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"显示美国东海岸下一个星期五当地时间早上九点\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"

#: src/date.c:301 src/dd.c:2475 src/head.c:881 src/md5sum.c:672
#: src/md5sum.c:1107 src/od.c:915 src/od.c:1984 src/pr.c:1149 src/pr.c:1348
#: src/pr.c:1471 src/stty.c:1368 src/tac.c:574 src/tail.c:387 src/tee.c:174
#: src/tr.c:1911 src/tsort.c:535 src/wc.c:223
msgid "standard input"
msgstr "标准输入"

#: src/date.c:330 src/date.c:558
#, c-format
msgid "invalid date %s"
msgstr "无效的日期 %s"

#: src/date.c:444 src/date.c:478
msgid "multiple output formats specified"
msgstr "指定了多种输出格式"

#: src/date.c:456
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "被指定的这几种日期显示选项是相互抵触的"

#: src/date.c:463
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr "显示与设置时间的选项不能同时使用"

#: src/date.c:484
#, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""
"参数 %s 缺少前导的\"+\"；\n"
"当使用选项来描述日期时，任何非选项参数都必须以\"+\"所引导\n"
"的字符串出现"

#: src/date.c:566
#, c-format
msgid "cannot set date"
msgstr "无法设置日期"

#: src/date.c:600 src/du.c:389
#, c-format
msgid "time %s is out of range"
msgstr "时间%s 超出范围"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:44 src/factor.c:128 src/rm.c:40 src/tail.c:76 src/touch.c:42
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:558
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [操作数] ...\n"
"　或：%s 选项\n"

#: src/dd.c:563
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time (default: "
"512);\n"
"                  overrides ibs and obs\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"复制文件，依照指定操作数转换并格式化。\n"
"\n"
"  bs=字节数      一次读写的比特数（默认：512）；\n"
"                 会覆盖 ibs 和 obs 选项\n"
"  cbs=字节数     一次转换的字节数\n"
"  conv=CONVS     依照每个逗号分割的符号列表转换文件\n"
"  count=块数     只将复制指定数量的输入块\n"
"  ibs=字节数     一次读取的字节数（默认：512)\n"

#: src/dd.c:573
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          skip N obs-sized blocks at start of output\n"
"  skip=N          skip N ibs-sized blocks at start of input\n"
"  status=LEVEL    The LEVEL of information to print to stderr;\n"
"                  'none' suppresses everything but error messages,\n"
"                  'noxfer' suppresses the final transfer statistics,\n"
"                  'progress' shows periodic transfer statistics\n"
msgstr ""
"  if=文件         从指定文件而非标准输入来进行读取\n"
"  iflag=标志      按照以逗号分隔的符号列表指定的方式读取\n"
"  obs=字节数      一次写入指定字节数（默认：512）\n"
"  of=文件         写入到指定文件而非标准输出\n"
"  oflag=标志      按照以逗号分隔的符号列表指定的方式写入\n"
"  seek=块数       在输出开始处跳过指定的 obs 大小的块数\n"
"  skip=块数       在输入开始处跳过指定的 ibs 大小的块数\n"
"  status=等级     要输出到标准错误的信息等级；\n"
"                  'none' 将仅输出错误信息，\n"
"                  'noxfer' 将不输出最终传输统计信息，\n"
"                  'progress' 将显示周期性的传输统计信息\n"

#: src/dd.c:586
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n"
"GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"块数和字节数后可以带有以下的一个或多个后缀：\n"
"c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n"
"GB=1000*1000*1000, G=1024*1024*1024 以及相应可使用 T, P, E, Z, Y。\n"
"也可使用二进制进位前缀：如 KiB=K、MiB=M 等等。\n"
"\n"
"每个 CONV 符号可能为：\n"
"\n"

#: src/dd.c:596
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write all-NUL output blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii     由 EBCDIC 码转换至 ASCII 码\n"
"  ebcdic    由 ASCII 码转换至 EBCDIC 码\n"
"  ibm       由 ASCII 码转换至代用的 EBCDIC 码\n"
"  block     在换行符结尾的记录末尾填充空格至 cbs 对应的长度\n"
"  unblock   将 cbs 大小的块中尾部的空格替换为一个换行符\n"
"  lcase     将大写字符转换为小写\n"
"  ucase     将小写字符转换为大写\n"
"  sparse    尝试寻址（seek）而非写入全空（NUL）的输出块\n"
"  swab      交换每一对输入数据字节\n"
"  sync      将每个输入数据块以 NUL 空字符填充至 ibs 的大小；当配合\n"
"            block 或 unblock 使用时，会以空格代替 NUL 字符来填充\n"

#: src/dd.c:609
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl      如果输出文件已存在则认为操作失败\n"
"  nocreat   不要创建输出文件\n"
"  notrunc   不要截断输出文件\n"
"  noerror   读取数据发生错误后仍然继续\n"
"  fdatasync  结束前将输出文件数据物理上写入磁盘\n"
"  fsync     与上者类似，但也将元数据一同写入\n"

#: src/dd.c:617
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"FLAG 符号可以是：\n"
"\n"
"  append\t追加模式(仅对输出有意义；隐含了conv=notrunc)\n"

#: src/dd.c:624
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio       使用并行 I/O 存取数据\n"

#: src/dd.c:626
msgid "  direct    use direct I/O for data\n"
msgstr " direct    使用直接I/O 存取模式\n"

#: src/dd.c:628
msgid "  directory  fail unless a directory\n"
msgstr "  directory  除非是目录，否则操作失败\n"

#: src/dd.c:630
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     使用同步 I/O 存取模式\n"

#: src/dd.c:632
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync      与上者类似，但同时也对元数据生效\n"

#: src/dd.c:633
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock\t为输入积累完整块(仅iflag)\n"

#: src/dd.c:636
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock\t使用无阻塞I/O 存取模式\n"

#: src/dd.c:638
msgid "  noatime   do not update access time\n"
msgstr "  noatime   不更新访问时间\n"

#: src/dd.c:641
msgid "  nocache   Request to drop cache.  See also oflag=sync\n"
msgstr "  nocache   请求不使用缓存。参见 oflag=sync\n"

#: src/dd.c:645
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty\t不根据文件指派控制终端\n"

#: src/dd.c:648
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  不跟随链接文件\n"

#: src/dd.c:650
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks\t如果有多重链接，则nolinks 失败\n"

#: src/dd.c:652
msgid "  binary    use binary I/O for data\n"
msgstr "  binary    使用二进制 I/O 存取模式\n"

#: src/dd.c:654
msgid "  text      use text I/O for data\n"
msgstr "  text      使用文本 I/O 存取模式\n"

#: src/dd.c:656
msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
msgstr "  count_bytes  把 'count=N' 看作字节计数（仅 iflag）\n"

#: src/dd.c:659
msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
msgstr "  skip_bytes  把 'skip=N' 看作字节计数（仅 iflag）\n"

#: src/dd.c:662
msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
msgstr "  seek_bytes  把 'seek=N' 看作字节计数（仅 oflag）\n"

#: src/dd.c:666
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"向正在运行的 'dd' 进程发送 %s 信号可以令其向标准错误输出 I/O\n"
"统计数据并继续进行复制。\n"
"\n"
"选项有：\n"
"\n"

#: src/dd.c:702
#, c-format
msgid "memory exhausted by input buffer of size %<PRIuMAX> bytes (%s)"
msgstr "%<PRIuMAX> 字节的输入缓冲导致内存耗尽（%s）"

#: src/dd.c:730
#, c-format
msgid "memory exhausted by output buffer of size %<PRIuMAX> bytes (%s)"
msgstr "%<PRIuMAX> 字节的输出缓冲导致内存耗尽（%s）"

#: src/dd.c:798 src/du.c:401
msgid "Infinity"
msgstr "无穷量"

#: src/dd.c:817
#, c-format
msgid "%<PRIuMAX> byte copied, %s, %s"
msgid_plural "%<PRIuMAX> bytes copied, %s, %s"
msgstr[0] "%<PRIuMAX>字节已复制，%s，%s"

#: src/dd.c:823
#, c-format
msgid "%<PRIuMAX> bytes (%s) copied, %s, %s"
msgstr "%<PRIuMAX>字节（%s）已复制，%s，%s"

#: src/dd.c:826
#, c-format
msgid "%<PRIuMAX> bytes (%s, %s) copied, %s, %s"
msgstr "%<PRIuMAX>字节（%s，%s）已复制，%s，%s"

#: src/dd.c:858
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"记录了%<PRIuMAX>+%<PRIuMAX> 的读入\n"
"记录了%<PRIuMAX>+%<PRIuMAX> 的写出\n"

#: src/dd.c:864
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> 个被截断了的块\n"

#: src/dd.c:966
#, c-format
msgid "closing input file %s"
msgstr "正在关闭输入文件%s"

#: src/dd.c:973
#, c-format
msgid "closing output file %s"
msgstr "正在关闭输出文件%s"

#: src/dd.c:1207
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "无法关闭O_DIRECT：%s"

#: src/dd.c:1282 src/dd.c:2202
#, c-format
msgid "writing to %s"
msgstr "正在写入%s"

#: src/dd.c:1452
#, c-format
msgid "warning: %s is a zero multiplier; use %s if that is intended"
msgstr "警告：%s 是一个零乘数；如这与意图相同，请使用 %s"

#: src/dd.c:1490 src/dd.c:1551
#, c-format
msgid "unrecognized operand %s"
msgstr "无法识别的操作数 %s"

#: src/dd.c:1502
msgid "invalid conversion"
msgstr "转换无效"

#: src/dd.c:1505 src/dd.c:1594
msgid "invalid input flag"
msgstr "输入标志无效"

#: src/dd.c:1508 src/dd.c:1588 src/dd.c:1600
msgid "invalid output flag"
msgstr "输出标志无效"

#: src/dd.c:1511
msgid "invalid status level"
msgstr "状态等级无效"

#: src/dd.c:1646
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "不可将{ascii、ebcdic、idm}中的任意两个结合使用"

#: src/dd.c:1648
msgid "cannot combine block and unblock"
msgstr "不可将block 和unblock 结合使用"

#: src/dd.c:1650
msgid "cannot combine lcase and ucase"
msgstr "不可将lcase 和ucase 结合使用"

#: src/dd.c:1652
msgid "cannot combine excl and nocreat"
msgstr "不可将excl 和nocreat 结合使用"

#: src/dd.c:1655
msgid "cannot combine direct and nocache"
msgstr "不可将direct 和nocreat 结合使用"

#: src/dd.c:1812
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"警告：暂时避免有关文件%s 的lseek 内核错误\n"
"  错误地址在mt_type=0x%0lx -- 有关mt_type 类型的列表请参考<sys/mtio.h>"

#: src/dd.c:1900
#, c-format
msgid "%s: cannot skip"
msgstr "%s：无法跳过"

#: src/dd.c:1902 src/dd.c:1933 src/dd.c:1994
#, c-format
msgid "%s: cannot seek"
msgstr "%s：无法搜索"

#: src/dd.c:1974
#, c-format
msgid "offset overflow while reading file %s"
msgstr "读入文件%s 时偏移量溢出"

#: src/dd.c:1986
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "警告：文件读取失败后偏移错误"

#: src/dd.c:1990
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "无法避免内核的错误"

#: src/dd.c:2129
#, c-format
msgid "setting flags for %s"
msgstr "正在设置%s 的标记"

#: src/dd.c:2183
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s：无法跳至指定偏移量"

#: src/dd.c:2412
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr "无法针对输出文件 %2$s 的 %1$<PRIdMAX> 字节处实施截断"

#: src/dd.c:2425
#, c-format
msgid "fdatasync failed for %s"
msgstr "%s 的fdatasync 失败"

#: src/dd.c:2433
#, c-format
msgid "fsync failed for %s"
msgstr "%s 的fsync 失败"

#: src/dd.c:2481 src/dd.c:2511 src/nohup.c:157 src/nohup.c:159
#, c-format
msgid "failed to open %s"
msgstr "打开%s 失败"

#: src/dd.c:2521
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr "偏移量过大：无法在seek=%<PRIuMAX> (%lu-字节) 块的长度上实施截断"

#: src/dd.c:2542
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "无法针对输出文件%2$s 的%1$<PRIuMAX> 字节处实施截断"

#: src/dd.c:2559 src/dd.c:2565
#, c-format
msgid "failed to discard cache for: %s"
msgstr "无法丢弃缓存：%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:50 src/du.c:56 src/expr.c:153 src/kill.c:34 src/pathchk.c:31
#: src/shuf.c:41 src/sleep.c:35 src/sort.c:68
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:182
msgid "Filesystem"
msgstr "文件系统"

#: src/df.c:185
msgid "Type"
msgstr "类型"

#: src/df.c:188 src/df.c:602
msgid "blocks"
msgstr "块"

#: src/df.c:191
msgid "Used"
msgstr "已用"

#: src/df.c:194
msgid "Available"
msgstr "可用"

#: src/df.c:197
msgid "Use%"
msgstr "已用%"

#: src/df.c:200
msgid "Inodes"
msgstr "Inodes"

#: src/df.c:203
msgid "IUsed"
msgstr "已用(I)"

#: src/df.c:206
msgid "IFree"
msgstr "可用(I)"

#: src/df.c:209
msgid "IUse%"
msgstr "已用(I)%"

#: src/df.c:212
msgid "Mounted on"
msgstr "挂载点"

#: src/df.c:215
msgid "File"
msgstr "文件"

#: src/df.c:442
#, c-format
msgid "option --output: field %s unknown"
msgstr "选项 --output：字段 %s 未知"

#: src/df.c:449
#, c-format
msgid "option --output: field %s used more than once"
msgstr "选项 --output：字段 %s 使用了超过一次"

#: src/df.c:470 src/df.c:509
msgid "Size"
msgstr "容量"

#: src/df.c:474 src/df.c:511
msgid "Avail"
msgstr "可用"

#: src/df.c:534
msgid "Capacity"
msgstr "配额"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:605 src/df.c:614
#, c-format
msgid "%s-%s"
msgstr "%s-%s"

#: src/df.c:1343
#, c-format
msgid "cannot access %s: over-mounted by another device"
msgstr "无法访问 %s：已由另一个设备挂载"

#: src/df.c:1512
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr "显示每个指定文件所在的文件系统的信息，默认是显示所有文件系统。\n"

#. TRANSLATORS: The thousands and decimal separators are best
#. adjusted to an appropriate default for your locale.
#: src/df.c:1521
msgid ""
"  -a, --all             include pseudo, duplicate, inaccessible file "
"systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n"
"  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n"
msgstr ""
"  -a, --all             包含虚拟、重复和无法访问的文件系统\n"
"  -B, --block-size=大小  使用指定字节数的块。例如，'-BM' 将以\n"
"                           1,048,576 字节为单位显示大小。\n"
"                           参见 SIZE 格式。\n"
"  -h, --human-readable  以 1024 为基底显示大小（例如：1023M）\n"
"  -H, --si              以 1000 为基底显示大小（例如，1.1G）\n"

#: src/df.c:1529
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes\t\t显示inode 信息而非块使用量\n"
"  -k\t\t\t即--block-size=1K\n"
"  -l, --local\t\t只显示本机的文件系统\n"
"      --no-sync\t\t取得使用量数据前不进行同步动作(默认)\n"

#: src/df.c:1536
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
msgstr ""
"      --output[=域列表]      使用给定域列表定义的输出格式，\n"
"                               或者在缺省情况下输出所有域。\n"
"  -P, --portability     使用 POSIX 兼容的输出格式\n"
"      --sync            取得使用量数据前先调用同步（sync）动作\n"

#: src/df.c:1542
msgid ""
"      --total           elide all entries insignificant to available space,\n"
"                          and produce a grand total\n"
msgstr "      --total           省略所有对可用空间无显著影响的项并生成总计值\n"

#: src/df.c:1546
msgid ""
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -t, --type=类型       只显示指定文件系统为指定类型的信息\n"
"  -T, --print-type      显示文件系统类型\n"
"  -x, --exclude-type=类型   只显示文件系统不是指定类型的信息\n"
"  -v                    （忽略）\n"

#: src/df.c:1556
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n"
msgstr ""
"\n"
"“域列表”是由逗号分隔的列表，指示需要包含在内的列。有效的域名称包括：\n"
"'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size',\n"
"'used', 'avail', 'pcent', 'file' 和 'target'（请参考 info 信息页）。\n"

#: src/df.c:1593
#, c-format
msgid "options %s and %s are mutually exclusive"
msgstr "选项 %s 和 %s 是互斥的"

#: src/df.c:1743
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "不能同时选择和排除文件系统类型 %s"

#: src/df.c:1802
msgid "Warning: "
msgstr "警告："

#: src/df.c:1804 src/stat.c:944
msgid "cannot read table of mounted file systems"
msgstr "%s 无法读取已挂载上的文件系统的目录"

#: src/df.c:1841
msgid "no file systems processed"
msgstr "未处理文件系统"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:37
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:100
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"输出用来设置 LS_COLORS 环境变量的命令。\n"
"\n"
"指定输出的规格：\n"
"  -b, --sh, --bourne-shell\t输出设置LS_COLORS 的Bourne shell 命令\n"
"  -c, --csh, --c-shell\t\t输出设置LS_COLORS 的C shell 命令\n"
"  -p, --print-database\t\t输出默认的色彩设置\n"

#: src/dircolors.c:110
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""
"\n"
"如果指定了文件，则读取该文件的数据来决定文件类型及扩展名相应的颜色。\n"
"否则，会使用默认的数据库。如要了解此文件格式的细节，请执行：\n"
"\"dircolors --print-database\"。\n"

#: src/dircolors.c:288
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s：%lu：此行无效；缺少了第二栏数据"

#: src/dircolors.c:360
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s：%lu：无法识别的关键字%s"

#: src/dircolors.c:361
msgid "<internal>"
msgstr "<内部数据>"

#: src/dircolors.c:442
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"显示 dircolors 内部数据库的选项和选择 shell 语法的选项\n"
"是互相抵触的"

#: src/dircolors.c:452
msgid "file operands cannot be combined with --print-database (-p)"
msgstr "文件操作和--print-database (-p)不能同时使用"

#: src/dircolors.c:475
msgid "no SHELL environment variable, and no shell type option given"
msgstr "没有设置SHELL 环境变量，也没有指定shell 类型的选项"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "用法：%s [选项] 名称...\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""
"输出已经去除了尾部的\"/\"字符之后部分和最末尾斜线的名称；\n"
"如果名称中不包含\"/\"，则显示\".\"（表示当前目录）。\n"
"\n"

#: src/dirname.c:59
msgid "  -z, --zero     end each output line with NUL, not newline\n"
msgstr "  -z, --zero     以 NUL 空字符而非换行符结束每一输出行\n"

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""
"\n"
"示例：\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" 后接 \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"

#: src/du.c:285 src/sort.c:415 src/wc.c:118
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"　或：%s [选项]... --files0-from=F\n"

#: src/du.c:289
msgid ""
"Summarize disk usage of the set of FILEs, recursively for directories.\n"
msgstr "计算每个文件的磁盘用量，目录则取总用量。\n"

#: src/du.c:295
msgid ""
"  -0, --null            end each output line with NUL, not newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -0, --null            每行输出使用 NUL 空字符结尾而非使用换行符\n"
"  -a, --all             输出所有文件的磁盘用量，不仅仅是目录\n"
"      --apparent-size   显示表面用量，而并非是磁盘用量；虽然表面用量通常会\n"
"                          小一些，但有时它会因为稀疏文件间的“洞”、内部碎\n"
"                          片、非直接引用的块等原因显得更大一些。\n"

#: src/du.c:304
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -B, --block-size=大小  以指定大小为单位对块大小进行输出；例如，\n"
"                           'BM' 以 1,048,576 字节为单位输出大小；\n"
"                           详情请参见下方的“SIZE 格式”部分\n"
"  -b, --bytes           等效于 '--apparent-size --block-size=1'\n"
"  -c, --total           显示总计信息\n"
"  -D, --dereference-args  只在符号链接显式在命令行列出时对其进行解引用\n"
"  -d, --max-depth=N     仅当目录（或在 --all 选项启用时包括文件）层级不高于\n"
"                          命令行参数指定的 N 层时输出对应目录或文件的对应大"
"小；\n"
"                          --max-depth=0 等效于 --summarize\n"

#: src/du.c:317
msgid ""
"      --files0-from=F   summarize disk usage of the\n"
"                          NUL-terminated file names specified in file F;\n"
"                          if F is -, then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --inodes          list inode usage information instead of block usage\n"
msgstr ""
"      --files0-from=F   统计由文件 F 给出的由 NUL 空字符结束的文件名列表\n"
"                          所对应各个文件的信息；如果 F 是 -，则从标准输入\n"
"                          读取文件名列表\n"
"  -H                    等效于 --dereference-args (-D)\n"
"  -h, --human-readable  以人类可读的格式输出大小（例如，1K 234M 2G）\n"
"      --inodes          列出 inode 使用信息而非块使用信息\n"

#: src/du.c:326
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k                    等效于 --block-size=1K\n"
"  -L, --dereference     解引用所有符号链接\n"
"  -l, --count-links     如果是硬连接，则重复计算其尺寸\n"
"  -m                    等效于 --block-size=1M\n"

#: src/du.c:332
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   for directories do not include size of "
"subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -P, --no-dereference  不跟随任何符号链接（默认行为）\n"
"  -S, --separate-dirs   不包括子目录的占用量\n"
"      --si              类似 -h，但使用 1000 的倍数，而非 1024\n"
"  -s, --summarize       只分别计算命令列中每个参数所占的总用量\n"

#: src/du.c:338
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using STYLE, which can be:\n"
"                            full-iso, long-iso, iso, or +FORMAT;\n"
"                            FORMAT is interpreted like in 'date'\n"
msgstr ""
"  -t, --threshold=大小  如果指定大小为正值，排除比该值更小的项，\n"
"                          或者在值为负时排除更大的项\n"
"      --time            显示目录中或其子目录下所有文件的最后修改时间\n"
"      --time=关键字     显示指定关键字对应的时间而非最后修改时间：\n"
"                          atime, access, use, ctime 或 status\n"
"      --time-style=格式   使用指定格式显示时间，格式可以为：\n"
"                            full-iso, long-iso, iso 或 +FORMAT；\n"
"                            FORMAT 字符串以与 'date' 工具类似的方式解读\n"

#: src/du.c:349
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""
"  -X, --exclude-from=文件  排除所有与指定<文件>所提供模式匹配的文件\n"
"      --exclude=模式       排除所有与所给<模式>匹配的文件\n"
"  -x, --one-file-system    跳过位于不同文件系统上的目录\n"

#: src/du.c:696
#, c-format
msgid "fts_read failed: %s"
msgstr "fts_read 失败：%s"

#: src/du.c:820
#, c-format
msgid "invalid maximum depth %s"
msgstr "目录最大深度%s 无效"

#: src/du.c:849
msgid "invalid --threshold argument '-0'"
msgstr "无效的 --threshold 参数 '-0'"

#: src/du.c:932
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "不能既显示总用量，同时又显示每个项目"

#: src/du.c:939
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "警告：显示总用量等价于使用--max-depth=0"

#: src/du.c:945
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "警告：显示总用量的选项和--max-depth=%lu 互斥"

#: src/du.c:956
#, c-format
msgid "warning: options --apparent-size and -b are ineffective with --inodes"
msgstr "警告：选项 --apparent-size 和 -b 对 --inodes 无效"

#: src/du.c:1021 src/sort.c:4598 src/wc.c:760
msgid "file operands cannot be combined with --files0-from"
msgstr "文件操作数不能于--files0-from 参数一起使用"

#: src/du.c:1088 src/sort.c:4619 src/wc.c:838
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "当从标准输入读取时，不允许指定文件名%s"

#: src/du.c:1105 src/du.c:1113 src/wc.c:851 src/wc.c:859
msgid "invalid zero-length file name"
msgstr "无效的零长度文件名"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:28
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:42
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"用法：%s [短选项]... [字符串]...\n"
"　或：%s 长选项\n"

#: src/echo.c:46
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"将 STRING 回显到标准输出。\n"
"\n"
"  -n\t\t不尾随换行符\n"

#: src/echo.c:52
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e\t\t启用解释反斜杠的转义功能(默认)\n"
"  -E\t\t禁用解释反斜杠的转义功能\n"

#: src/echo.c:55
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e\t\t启用解释反斜杠的转义功能\n"
"  -E\t\t禁用解释反斜杠的转义功能(默认)\n"

#: src/echo.c:61
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"若-e 可用，则以下序列即可识别：\n"
"\n"

#: src/echo.c:66 src/printf.c:110
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\    反斜杠\n"
"  \\a    响铃声\n"
"  \\b    退格\n"
"  \\c    不再产生新的输出\n"
"  \\e    转义符  \n"
"  \\f    换页\n"
"  \\n    新行\n"
"  \\r    回车\n"
"  \\t    水平制表符\n"
"  \\v    竖直制表符\n"

#: src/echo.c:78
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   字节数以八进制数 NNN (1至3位)表示\n"
"  \\xHH    字节数以十六进制数 HH (1至2位)表示\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:38 src/printenv.c:45 src/whoami.c:35
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:112
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr "用法：%s [选项]... [-] [名称=值]... [命令 [参数]...]\n"

#: src/env.c:115
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr "在环境中设置每个给定变量<名称>的值为给定<值>，并运行给定<命令>。\n"

#: src/env.c:121
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with NUL, not newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"  -i, --ignore-environment  以空环境启动\n"
"  -0, --null           以 NUL 空字符而非换行符结束每一输出行\n"
"  -u,  --unset=名称     从当前环境中移除一个变量\n"

#: src/env.c:126
msgid "  -C, --chdir=DIR      change working directory to DIR\n"
msgstr "  -C, --chdir=目录     将工作目录变更为指定目录\n"

#: src/env.c:129
msgid ""
"  -S, --split-string=S  process and split S into separate arguments;\n"
"                        used to pass multiple arguments on shebang lines\n"
msgstr ""
"  -S, --split-string=S  处理并将 S 字符串分割为多个参数；\n"
"                        用于向 shebang 行传递多个参数\n"

#: src/env.c:133
msgid ""
"      --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\n"
msgstr "      --block-signal[=信号]   阻挡向指定<命令>传递指定的信号\n"

#: src/env.c:136
msgid ""
"      --default-signal[=SIG]  reset handling of SIG signal(s) to the "
"default\n"
msgstr "      --default-signal[=信号]  将对指定信号的处理方式重置为默认方式\n"

#: src/env.c:139
msgid ""
"      --ignore-signal[=SIG]   set handling of SIG signals(s) to do nothing\n"
msgstr "      --ignore-signal[=信号]  将对指定信号的处理方式设置为什么都不做\n"

#: src/env.c:142
msgid ""
"      --list-signal-handling  list non default signal handling to stderr\n"
msgstr "      --list-signal-handling  向标准错误输出非默认的信号处理方式\n"

#: src/env.c:145
msgid ""
"  -v, --debug          print verbose information for each processing step\n"
msgstr "  -v, --debug          为每个处理流程输出详细信息\n"

#: src/env.c:150
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"单纯的 - 意味着 -i。如果没有命令，则打印结果环境。\n"

#: src/env.c:154
msgid ""
"\n"
"SIG may be a signal name like 'PIPE', or a signal number like '13'.\n"
"Without SIG, all known signals are included.  Multiple signals can be\n"
"comma-separated.\n"
msgstr ""
"\n"
"参数中的信号可以是类似 'PIPE' 这样的信号名称，也可以是如 '1'\n"
"这样的信号编码。所有已知信号均包括其中。如需指定多个信号，可以使用\n"
"半角逗号隔开。\n"

#: src/env.c:181
#, c-format
msgid "cannot unset %s"
msgstr "无法取消设置 %s"

#: src/env.c:315
msgid "'\\c' must not appear in double-quoted -S string"
msgstr "'\\c' 不能出现在双引号括起的 -S 字符串中"

#: src/env.c:319
msgid "invalid backslash at end of string in -S"
msgstr "-S 中字符串末尾无效的反斜杠"

#: src/env.c:322
#, c-format
msgid "invalid sequence '\\%c' in -S"
msgstr "-S 中的无效序列 '\\%c'"

#: src/env.c:336
#, c-format
msgid "only ${VARNAME} expansion is supported, error at: %s"
msgstr "只支持 ${VARNAME} 扩展，错误位于：%s"

#: src/env.c:347
msgid "no terminating quote in -S string"
msgstr "-S 字符串中没有结束的引号"

#: src/env.c:613 src/env.c:702 src/operand2sig.c:88
#, c-format
msgid "%s: invalid signal"
msgstr "%s：无效的信号"

#: src/env.c:645
#, c-format
msgid "failed to get signal action for signal %d"
msgstr "获取信号 %d 的处理操作失败"

#: src/env.c:653
#, c-format
msgid "failed to set signal action for signal %d"
msgstr "设置信号 %d 的处理操作失败"

#: src/env.c:725 src/env.c:765
msgid "failed to get signal process mask"
msgstr "获取进程信号掩码失败"

#: src/env.c:754
msgid "failed to set signal process mask"
msgstr "设置进程信号掩码失败"

#: src/env.c:857
#, c-format
msgid "invalid option -- '%c'"
msgstr "无效的选项 -- \"%c\""

#: src/env.c:858 src/env.c:949
#, c-format
msgid "use -[v]S to pass options in shebang lines"
msgstr "使用 -[v]S 以在 shebang 行中传递选项"

#: src/env.c:891
#, c-format
msgid "cannot set %s"
msgstr "无法设定 %s"

#: src/env.c:901
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "无法以命令指定--null (-0)"

#: src/env.c:907
#, c-format
msgid "must specify command with --chdir (-C)"
msgstr "必须带 --chdir (-C) 指定命令"

#: src/env.c:932
#, c-format
msgid "cannot change directory to %s"
msgstr "无法变更目录为 %s"

#: src/expand-common.c:90
msgid "tabs are too far apart"
msgstr "制表符过于分散"

#: src/expand-common.c:103
#, c-format
msgid "'/' specifier only allowed with the last value"
msgstr "‘/’符号只允许与最后一个值合用"

#: src/expand-common.c:120
#, c-format
msgid "'+' specifier only allowed with the last value"
msgstr "‘+’符号只允许与最后一个值合用"

#: src/expand-common.c:172
#, c-format
msgid "'/' specifier not at start of number: %s"
msgstr "‘/’符号没有位于数字之前：%s"

#: src/expand-common.c:183
#, c-format
msgid "'+' specifier not at start of number: %s"
msgstr "‘+’符号没有位于数字之前：%s"

#: src/expand-common.c:204
#, c-format
msgid "tab stop is too large %s"
msgstr "%s：制表符跳格量过大"

#: src/expand-common.c:212
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "制表符尺寸中包含无效字符：%s"

#: src/expand-common.c:244
msgid "tab size cannot be 0"
msgstr "制表符尺寸不可为0"

#: src/expand-common.c:246
msgid "tab sizes must be ascending"
msgstr "制表符尺寸必须是升序的"

#: src/expand-common.c:251
msgid "'/' specifier is mutually exclusive with '+'"
msgstr "‘/’符号和‘+’符号不能同时使用"

#: src/expand-common.c:390
msgid "  -t, --tabs=LIST  use comma separated list of tab positions\n"
msgstr "  -t, --tabs=列表  指定制表符位置列表，用逗号分隔\n"

#: src/expand-common.c:393
msgid ""
"                     The last specified position can be prefixed with '/'\n"
"                     to specify a tab size to use after the last\n"
"                     explicitly specified tab stop.  Also a prefix of '+'\n"
"                     can be used to align remaining tab stops relative to\n"
"                     the last specified tab stop instead of the first "
"column\n"
msgstr ""
"                     最后的指定位置可以前缀加上‘/’符号以声明在最后一个\n"
"                     明确指定制表符位置的声明之后对应位置的倍数均为制表符。\n"
"                     另外，还可以使用‘+’的前缀以声明在最后一个明确指定\n"
"                     位置的制表符之后每隔多少的位置间距是一个制表符\n"

#: src/expand.c:73
msgid "Convert tabs in each FILE to spaces, writing to standard output.\n"
msgstr "将每个指定文件中的制表符转换为空格，写到标准输出。\n"

#: src/expand.c:80
msgid ""
"  -i, --initial    do not convert tabs after non blanks\n"
"  -t, --tabs=N     have tabs N characters apart, not 8\n"
msgstr ""
"  -i, --initial    不转换非空白字符后的制表符\n"
"  -t, --tabs=数字  设置每个制表符为指定数字的宽度，而不是默认的 8\n"

#: src/expand.c:146 src/expand.c:165 src/unexpand.c:181 src/unexpand.c:226
msgid "input line is too long"
msgstr "输入行太长"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:51 src/mv.c:42 src/tee.c:36
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:37
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:345
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 表达式\n"
"　或：%s 选项\n"

#: src/expr.c:353
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"将表达式的值列印到标准输出，分隔符下面的空行可提升算式优先级。\n"
"可用的表达式有：\n"
"\n"
"  ARG1 | ARG2       若ARG1 的值不为0 或者为空，则返回ARG1，否则返回ARG2\n"
"\n"
"  ARG1 & ARG2       若两边的值都不为0 或为空，则返回ARG1，否则返回 0\n"

#: src/expr.c:362
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  ARG1 < ARG2       ARG1 小于ARG2\n"
"  ARG1 <= ARG2      ARG1 小于或等于ARG2\n"
"  ARG1 = ARG2       ARG1 等于ARG2\n"
"  ARG1 != ARG2      ARG1 不等于ARG2\n"
"  ARG1 >= ARG2      ARG1 大于或等于ARG2\n"
"  ARG1 > ARG2       ARG1 大于ARG2\n"

#: src/expr.c:371
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  ARG1 + ARG2       计算 ARG1 与ARG2 相加之和\n"
"  ARG1 - ARG2       计算 ARG1 与ARG2 相减之差\n"

#: src/expr.c:378
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  ARG1 * ARG2       计算 ARG1 与ARG2 相乘之积\n"
"  ARG1 / ARG2       计算 ARG1 与ARG2 相除之商\n"
"  ARG1 % ARG2       计算 ARG1 与ARG2 相除之余数\n"

#: src/expr.c:384
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  字符串 : 表达式\t\t定位字符串中匹配表达式的模式\n"
"\n"
"  match 字符串 表达式\t\t等于\"字符串 :表达式\"\n"
"  substr 字符串 偏移量 长度\t替换字符串的子串，偏移的数值从 1 起计\n"
"  index 字符串 字符\t\t在字符串中发现字符的地方建立下标，或者标0\n"
"  length 字符串\t\t\t字符串的长度\n"

#: src/expr.c:393
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + 记号                     将给定记号解析为字符串，即使它是一个类似\n"
"                               “match”或运算符\"/\"那样的关键字\n"
"\n"
"  ( 表达式 )                 给定<表达式>的值\n"

#: src/expr.c:399
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"请注意有许多运算操作符都可能需要由 shell 先实施转义。\n"
"如果参与运算的 ARG 自变量都是数字，比较符就会被视作数学符号，否则就是多义"
"的。\n"
"模式匹配会返回\"\\\"和\"\\\"之间被匹配的子字符串或空(null)；如果未使用\"\\"
"\"和\"\\\"，\n"
"则会返回匹配字符数量或是 0。\n"

#: src/expr.c:406
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"若表达式的值既不是空也不是 0，退出状态值为 0；若表达式的值为空或为 0，\n"
"退出状态值为 1。如果表达式的句法无效，则会在出错时返回退出状态值 3。\n"

#: src/expr.c:462
#, c-format
msgid "syntax error: unexpected argument %s"
msgstr "语法错误：未预期的参数 %s"

#: src/expr.c:665
#, c-format
msgid "syntax error: missing argument after %s"
msgstr "语法错误：%s 后缺少参数"

#: src/expr.c:748 src/ptx.c:289
msgid "error in regular expression matcher"
msgstr "正则表达式匹配器出错"

#: src/expr.c:776
#, c-format
msgid "syntax error: expecting ')' after %s"
msgstr "语法错误：期望在 %s 后得到“)”"

#: src/expr.c:779
#, c-format
msgid "syntax error: expecting ')' instead of %s"
msgstr "语法错误：期望得到“)”而非 %s"

#: src/expr.c:785
msgid "syntax error: unexpected ')'"
msgstr "语法错误：未预期的“)”"

#: src/expr.c:931 src/expr.c:968
msgid "non-integer argument"
msgstr "非整数参数"

#: src/expr.c:933 src/truncate.c:278
msgid "division by zero"
msgstr "除以零"

#: src/expr.c:1027 src/sort.c:2119
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "请设置 LC_ALL='C' 以避免出现问题"

#: src/expr.c:1029
#, c-format
msgid "the strings compared were %s and %s"
msgstr "已比较的字符串为%s 和%s"

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:130
msgid "Niels Moller"
msgstr "Niels Moller"

#: src/factor.c:1276 src/factor.c:1376 src/factor.c:1452
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr "Lucas 素数测试失败。这不应该发生"

#: src/factor.c:2103
msgid "squfof queue overflow"
msgstr "squfof 队列溢出"

#: src/factor.c:2525
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s 不是有效的正整数"

#: src/factor.c:2549 src/od.c:1697 src/od.c:1778
#, c-format
msgid "%s is too large"
msgstr "%s 太大"

#: src/factor.c:2561
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [数字]...\n"
"　或：%s 选项\n"

#: src/factor.c:2566
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr "输出每个指定的数字的素因子，如果没有在命令行中指定则从标准输入读取。\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "无法获得当前目录"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "无法变更目录为 %s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "无法获取当前目录的文件状态(stat，当前目录是%s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:37
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:269
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "用法：%s [-宽度] [选项]... [文件]...\n"

#: src/fmt.c:270
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""
"对给定<文件>的每一段进行重新格式化，写入到标准输出。\n"
"选项“-宽度”是“--width=宽度数字”的缩写。\n"

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        保持前两行的缩进\n"
"  -p, --prefix=字符串       只对以指定字符串开头的行重新格式化，\n"
"                              将前缀重新附着到被重新格式化的行上\n"
"  -s, --split-only          分割过长的行，但不自动补足\n"

#: src/fmt.c:287
#, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""
"  -t, --tagged-paragraph    对第一行进行缩进以和第二行区分\n"
"  -u, --uniform-spacing     单词间保留一个空格，每句之后保留两个空格\n"
"  -w, --width=宽度          最大行宽（默认为 75 列）\n"
"  -g, --goal=目标宽度       目标宽度（默认为上述最大行宽的 93%）\n"
"\n"

#: src/fmt.c:355
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr "无效选项 -- %c；宽度必须是第一个选项才能被正确识别；请使用 -w N"

#: src/fmt.c:399 src/fmt.c:406
msgid "invalid width"
msgstr "无效的宽度"

#: src/fold.c:70
msgid "Wrap input lines in each FILE, writing to standard output.\n"
msgstr ""
"对每个指定的文件设置自动换行（折行），并将重新排版后的结果输出到标准输出。\n"

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes\t\t计算字节数而不是列数\n"
"  -s,  --spaces\t\t在空格处断行\n"
"  -w, --width=宽度\t使用指定的列宽度代替默认的80\n"

#: src/fold.c:284 src/pr.c:841
msgid "invalid number of columns"
msgstr "无效的列数"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:30 src/md5sum.c:107 src/realpath.c:33 src/stdbuf.c:38
#: src/timeout.c:78 src/truncate.c:38
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "用法：%s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"为Shell 脚本格式输出基于操作平台的限制参数。\n"
"\n"

#: src/group-list.c:68 src/id.c:401
#, c-format
msgid "failed to get groups for user %s"
msgstr "获取用户 %s 的属组失败"

#: src/group-list.c:73 src/id.c:404
#, c-format
msgid "failed to get groups for the current process"
msgstr "获取当前进程用户组失败"

#: src/group-list.c:113
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "无法找到 ID 为 %lu 的用户的属组"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "用法：%s [选项]... [用户名]...\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"显示每个输入的用户名所在的全部组，如果没有指定用户名则默认为当前进程用户(当用"
"户组数据库发生变更时可能导致差异)。\n"
"\n"

#: src/groups.c:106 src/id.c:289
msgid "cannot get real UID"
msgstr "无法获取真实 UID"

#: src/groups.c:111 src/id.c:297
msgid "cannot get effective GID"
msgstr "无法获取有效 GID"

#: src/groups.c:116 src/id.c:302
msgid "cannot get real GID"
msgstr "无法获取真实 UID"

#: src/groups.c:130 src/id.c:255
#, c-format
msgid "%s: no such user"
msgstr "%s：无此用户"

#: src/head.c:114
#, c-format
msgid ""
"Print the first %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"将每个指定文件的前 %d 行输出到标准输出。\n"
"如果指定了多于一个文件，在每块输出之前附加文件名称作为头部。\n"

#: src/head.c:122
#, c-format
msgid ""
"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM bytes of each file\n"
"  -n, --lines=[-]NUM       print the first NUM lines instead of the first "
"%d;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM lines of each file\n"
msgstr ""
"  -c, --bytes=[-]K         显示每个文件的前 K 字节内容；\n"
"                             如果数字前附加“-”字符，则除了每个文件的\n"
"                             最后 K 字节数据外显示其余全部内容\n"
"  -n, --lines=[-]K         显示每个文件的前 K 行内容而非前 %d 行内容；\n"
"                             如果数字前附加“-”字符，则除了每个文件的\n"
"                             最后 K 行数据外显示其余全部内容\n"

#: src/head.c:130
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent\t不显示包含给定文件名的文件头\n"
"  -v, --verbose\t\t总是显示包含给定文件名的文件头\n"

#: src/head.c:139
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"所给定的数字 K 后面可以附加乘数后缀：\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, 对于 T, P, E, Z, Y 同样适用。\n"
"也可以使用二进制前缀，如：KiB=K，MiB=M 等等。\n"

#: src/head.c:160
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s：文件被过度收缩"

#: src/head.c:232 src/tail.c:507
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s：无法检索到偏移量%s"

#: src/head.c:233 src/tail.c:511
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s：无法检索相对偏移量 %s"

#: src/head.c:275
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s：字节数过大"

#: src/head.c:913 src/split.c:1368 src/split.c:1535 src/tail.c:2205
msgid "invalid number of lines"
msgstr "无效的行数"

#: src/head.c:914 src/head.c:1078 src/split.c:1360 src/split.c:1376
#: src/tail.c:2206
msgid "invalid number of bytes"
msgstr "无效的字节数"

#: src/head.c:1004 src/head.c:1066
#, c-format
msgid "invalid trailing option -- %c"
msgstr "无效的附加选项 -- %c"

#: src/hostid.c:41
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"用法：%s [选项]\n"
"显示当前主机的数字标识符(十六进制)。\n"
"\n"

#: src/hostname.c:56
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"用法：%s [名称]\n"
"　或：%s 选项\n"
"显示或设置当前系统的主机名。\n"
"\n"

#: src/hostname.c:93
#, c-format
msgid "cannot set name to %s"
msgstr "无法设置主机名为%s"

#: src/hostname.c:97
msgid "cannot set hostname; this system lacks the functionality"
msgstr "无法设置主机名，此系统似乎不具备此功能"

#: src/hostname.c:105
msgid "cannot determine hostname"
msgstr "无法确定主机名"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:41 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:96 src/pinky.c:489
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "用法: %s [选项]... [用户]...\n"

#: src/id.c:97
msgid ""
"Print user and group information for each specified USER,\n"
"or (when USER omitted) for the current user.\n"
"\n"
msgstr ""
"输出指定<用户>的用户和用户组信息，\n"
"或（当没有指定用户信息时）默认使用当前用户信息 。\n"
"\n"

#: src/id.c:102
msgid ""
"  -a             ignore, for compatibility with other versions\n"
"  -Z, --context  print only the security context of the process\n"
"  -g, --group    print only the effective group ID\n"
"  -G, --groups   print all group IDs\n"
"  -n, --name     print a name instead of a number, for -ugG\n"
"  -r, --real     print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user     print only the effective user ID\n"
"  -z, --zero     delimit entries with NUL characters, not whitespace;\n"
"                   not permitted in default format\n"
msgstr ""
"  -a             忽略，仅为与其他版本相兼容而设计\n"
"  -Z, --context  仅显示当前用户的安全上下文\n"
"  -g, --group    仅显示有效用户组ID\n"
"  -G, --groups   显示所有组ID\n"
"  -n, --name     显示组名称而非数字，与 -ugG 一起使用\n"
"  -r, --real     显示真实ID 而非有效ID，与 -ugG 一起使用\n"
"  -u, --user     仅显示有效用户ID\n"
"   -z, --zero     使用 NUL 字符而非空格来分隔各个条目，在默认格式下不可使用\n"
"\n"

#: src/id.c:115
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"如果不附带任何选项，程序会显示一些可供识别用户身份的有用信息。\n"

#: src/id.c:153
msgid "--context (-Z) works only on an SELinux/SMACK-enabled kernel"
msgstr "--context (-Z) 选项只能在开启 SELinux/SMACK 支持的内核上使用"

#: src/id.c:158
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) 选项只能在开启 SELinux 支持的内核上使用"

#: src/id.c:192
msgid "cannot print security context when user specified"
msgstr "不能显示特定用户的安全上下文"

#: src/id.c:195
msgid "cannot print \"only\" of more than one choice"
msgstr "有多种选择，无法输出唯一的"

#: src/id.c:204
msgid "cannot print only names or real IDs in default format"
msgstr "以默认格式无法只显示名称或只显示真实ID"

#: src/id.c:208
msgid "option --zero not permitted in default format"
msgstr "默认格式不允许使用选项 --zero"

#: src/id.c:224
msgid "can't get process context"
msgstr "不能得到进程上下文"

#: src/id.c:280
msgid "cannot get effective UID"
msgstr "无法获取有效 UID"

#: src/id.c:344
#, c-format
msgid "cannot find name for user ID %s"
msgstr "无法找到 ID 为 %s 的用户的名称"

#: src/id.c:362
#, c-format
msgid "uid=%s"
msgstr "用户id=%s"

#: src/id.c:367
#, c-format
msgid " gid=%s"
msgstr " 组id=%s"

#: src/id.c:374
#, c-format
msgid " euid=%s"
msgstr " 有效用户id=%s"

#: src/id.c:382
#, c-format
msgid " egid=%s"
msgstr " 有效组id=%s"

#: src/id.c:410
msgid " groups="
msgstr " 组="

#: src/id.c:426
#, c-format
msgid " context=%s"
msgstr " 上下文=%s"

#: src/install.c:378
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "警告：%s：切换上下文至 %s 失败"

#: src/install.c:420
#, c-format
msgid "creating directory %s"
msgstr "正在创建目录 %s"

#: src/install.c:432 src/mkdir.c:128 src/mkdir.c:161
#, c-format
msgid "failed to set default creation context for %s"
msgstr "设置 %s 的默认创建上下文失败"

#: src/install.c:462 src/mkdir.c:181
#, c-format
msgid "failed to restore context for %s"
msgstr "恢复 %s 的上下文失败"

#: src/install.c:510
#, c-format
msgid "cannot change ownership of %s"
msgstr "无法更改 %s 的所有权"

#: src/install.c:534
#, c-format
msgid "cannot set timestamps for %s"
msgstr "无法设置 %s 的时间戳"

#: src/install.c:556 src/split.c:523 src/timeout.c:506
#, c-format
msgid "fork system call failed"
msgstr "fork 系统调用失败"

#: src/install.c:560
#, c-format
msgid "cannot run %s"
msgstr "无法运行 %s"

#: src/install.c:563
#, c-format
msgid "waiting for strip"
msgstr "正在等待 strip"

#: src/install.c:565
#, c-format
msgid "strip process terminated abnormally"
msgstr "strip 进程非正常中止"

#: src/install.c:589
#, c-format
msgid "invalid user %s"
msgstr "无效的用户 %s"

#: src/install.c:627
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"用法：%s [选项]... [-T] 源文件 目标文件\n"
"　或：%s [选项]... 源文件... 目录\n"
"　或：%s [选项]... -t 目录 源文件...\n"
"　或：%s [选项]... -d 目录...\n"

#: src/install.c:634
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""
"\n"
"本 install 程序将文件（通常是刚编译生成的文件）复制到您所选择的目标\n"
"位置。如果您希望在 GNU/Linux 操作系统上下载并安装一个即时可用的软件包，\n"
"您应当使用诸如 yum(1) 和 apt-get(1) 的软件包管理器而非本程序。\n"
"\n"
"在前三种形式中，将指定<源文件>复制到<目标文件>或将多个<源文件>复制到一个\n"
"已存在的<目录>中，同时设置其所有权和权限模式。在第四种形式中，\n"
"创建给出目标<目录>中的所有组件。\n"

#: src/install.c:648
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=CONTROL]  为每个已存在的文件创建备份\n"
"  -b                  类似--backup 但不接受参数\n"
"  -c                  （被忽略）\n"
"  -C, --compare       比较每组源文件和目标文件，在一些情况下不修改目标文件\n"
"  -d, --directory     将所有参数视为目录名称；为指定的目录创建所有组件\n"

#: src/install.c:657
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        or all components of --target-directory,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                  创建<目标文件>的所有必要的父目录，或者\n"
"                        --target-directory 路径的所有部分，\n"
"                        然后将<源文件>复制为给定的<目标文件>\n"
"  -g, --group=组     显式设置文件所属组，而不是进程目前的所属组\n"
"  -m, --mode=模式    显式设置权限模式（如 chmod），而非 rwxr-xr-x\n"
"  -o, --owner=所有者  显式设置所有者（适用于超级用户）\n"

#: src/install.c:665
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps\t修改源文件的访问/修改时间以与目标文件保持一致\n"
"  -s, --strip\t\t\t拆解符号表\n"
"      --strip-program=程序\t指定拆解二进制文件的程序\n"
"  -S, --suffix=后缀\t\t覆盖常用备份文件后缀\n"
"  -t, --target-directory=目录\t将源文件所有参数复制到指定目录\n"
"  -T, --no-target-directory\t将目标文件视为普通文件\n"
"  -v, --verbose\t\t\t创建目录时显示其名称\n"

#: src/install.c:675
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z                      set SELinux security context of destination\n"
"                            file and each created directory to default type\n"
"      --context[=CTX]     like -Z, or if CTX is specified then set the\n"
"                            SELinux or SMACK security context to CTX\n"
msgstr ""
"      --preserve-context  保持 SELinux 安全上下文\n"
"  -Z                      设置每个创建的目录和目标文件的 SELinux 安全上下文\n"
"                            为默认格式\n"
"      --context[=上下文]  类似 -Z，或者如果指定了上下文，则将 SELinux 或\n"
"                            SMACK 安全上下文设置为给定的值\n"

#: src/install.c:711 src/unlink.c:85
#, c-format
msgid "cannot unlink %s"
msgstr "无法清除 %s 的链接（unlink 失败）"

#: src/install.c:892
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr ""
"警告：忽略 --preserve-context 参数；当前运行的内核没有启用 SELinux 支持"

#: src/install.c:932
msgid "the strip option may not be used when installing a directory"
msgstr "安装目录时不能用strip 选项"

#: src/install.c:935
msgid "target directory not allowed when installing a directory"
msgstr "安装目录时不能用目标目录选项"

#: src/install.c:1002 src/mkdir.c:284 src/stdbuf.c:352
#, c-format
msgid "invalid mode %s"
msgstr "无效模式%s"

#: src/install.c:1009
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr "警告：忽略 --strip-program 选项，因为 -s 选项没有指明"

#: src/install.c:1014
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr "选项--compare (-C) 和--preserve-timestamps 是互斥的"

#: src/install.c:1021
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "选项--compare (-C) 和--strip 是互斥的"

#: src/install.c:1027
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr "当您使用不允许的比特数指定模式是--compare (-C) 选项被忽略"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:41 src/sort.c:67
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:196
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited by blanks.\n"
msgstr ""
"对具有相同的合并域的每一对输入行，在标准输出写出一行信息。默认的合并\n"
"域是第一列的内容，使用空白字符分隔。\n"

#: src/join.c:205
msgid ""
"\n"
"  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"\n"
"  -a 文件编号       文件编号的值可以是1或2，分别对应<文件1>和<文件2>。\n"
"                      此选项用于根据指定文件编号输出不成对的行目。\n"
"  -e 填充字符       将缺失的输入区块替换为指定字符\n"

#: src/join.c:211
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case  比较各个域时忽略大小写\n"
"  -j 域              等效于 \"-1 域 -2 域\"\n"
"  -o 格式            按照指定格式构造输出行\n"
"  -t 字符            使用指定字符作为输入和输出域的分隔符\n"

#: src/join.c:217
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""
"  -v 文件编号        \t类似 -a 文件编号，但禁止组合输出行\n"
"  -1 域          \t在文件1 的此域组合\n"
"  -2 域          \t在文件2 的此域组合\n"
"  --check-order     \t检查输入行是否正确排序，即使所有输入行均是成对的\n"
"  --nocheck-order   \t不检查输入是否正确排序\n"
"  --header          \t将首行视作域的头部，直接输出而不对其进行匹配\n"

#: src/join.c:227 src/shuf.c:83 src/sort.c:500 src/uniq.c:201
msgid "  -z, --zero-terminated     line delimiter is NUL, not newline\n"
msgstr "  -z, --zero-terminated     以 NUL 空字符而非换行符作为行尾分隔符\n"

#: src/join.c:232
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"除非使用了“-t 字符串”选项，否则前导空格分隔的域将被忽略，如果指定了\n"
"字符串，则使用指定字符串分隔任意的域并从 1 开始计数的域编号。可以指定的\n"
"格式是由一个或多个逗号活空格所分隔的描述，其形式为“文件编号.域”或者\n"
"“0”。默认的格式输出合并后的域、文件1和文件2剩下的域，均由该指定字符\n"
"串分隔。\n"
"\n"
"重要提示：<文件1>和<文件2>必须在合并域中排序。\n"
"例如，如果“join”后没有选项，使用“sort -k 1b,1”。\n"
"注意，所进行的比较遵从“LC_COLLATE”所指定的的规则。\n"
"如果输入没有被排序并导致某些行无法合并，将会显示警告信息。\n"

#: src/join.c:417
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr "%s:%<PRIuMAX>：未排序：%.*s"

#: src/join.c:848 src/join.c:1046
#, c-format
msgid "invalid field number: %s"
msgstr "无效的区块编号%s"

#: src/join.c:869 src/join.c:878
#, c-format
msgid "invalid field specifier: %s"
msgstr "无效的区块定义符：%s"

#: src/join.c:885
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "在区块定义中出现无效的文件编号：%s"

#: src/join.c:929
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "不兼容的连接区块%lu，%lu"

#: src/join.c:1057
msgid "conflicting empty-field replacement strings"
msgstr "有冲突的空区块替换字符串"

#: src/join.c:1109 src/sort.c:4535
#, c-format
msgid "multi-character tab %s"
msgstr "多字符标签%s"

#: src/join.c:1113 src/sort.c:4540
msgid "incompatible tabs"
msgstr "不兼容的标签"

#: src/join.c:1186
msgid "both files cannot be standard input"
msgstr "不能从标准输入同时读取两个文件"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"用法：%s [-s 信号 | -信号] 进程号...\n"
"　或：%s -l [信号]...\n"
"　或：%s -t [信号]...\n"

#: src/kill.c:83
msgid "Send signals to processes, or list signals.\n"
msgstr "向进程发送信号，或是列出可用信号。\n"

#: src/kill.c:89
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=信号，-信号\n"
"                   \t指定要发送的信号名或信号代码。\n"
"  -l, --list    \t列出可用的信号名称，同时提供信号名与信号代码的对照\n"
"  -t, --table    \t显示一个有关信号具体信息的表格。\n"

#: src/kill.c:97
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"参数中的信号可以是类似\"HUP\"的信号名称，也可以是如\"1\"这样的信号编码，\n"
"或者进程被信号终止后的退出状态号。\n"
"进程号（PID）是一个整数，如果为负数则表示一个进程组。\n"

#: src/kill.c:206
#, c-format
msgid "%s: invalid process id"
msgstr "%s：无效的进程号"

#: src/kill.c:260
#, c-format
msgid "invalid option -- %c"
msgstr "无效的选项 -- %c"

#: src/kill.c:269
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s：同时指定了多个信号"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "同时指定了多个-l 或-t 选项"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "无法将-l 或-t 选项结合使用"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "未指定进程号"

#: src/libstdbuf.c:108
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "%2$s 的缓冲模式%1$s 无效\n"

#: src/libstdbuf.c:120
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "分配 %<PRIuMAX> 字节标准输入输出(stdio)缓冲区失败\n"

#: src/libstdbuf.c:130
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "无法将%2$s 的缓冲模式设置为%1$s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:52
msgid "Michael Stone"
msgstr "Michael Ston"

#: src/link.c:45
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 文件1 文件2\n"
"　或：%s 选项\n"

#: src/link.c:48
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"调用 link 函数创建从既存的文件1 到文件2 的链接。\n"
"\n"

#: src/link.c:89
#, c-format
msgid "cannot create link %s to %s"
msgstr "无法创建指向%2$s 的链接%1$s"

#: src/ln.c:213
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: 不允许将硬链接指向目录"

#: src/ln.c:238
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s：无法覆盖目录"

#: src/ln.c:285
#, c-format
msgid "%s: replace %s? "
msgstr "%s：是否替换%s？ "

#: src/ln.c:380
#, c-format
msgid "failed to create symbolic link %s"
msgstr "无法创建符号链接 %s"

#: src/ln.c:381
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "无法创建符号链接 %s -> %s"

#: src/ln.c:383
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "无法创建硬链接%.0s%s"

#: src/ln.c:386
#, c-format
msgid "failed to create hard link %s"
msgstr "无法创建硬链接 %s"

#: src/ln.c:387
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "无法创建硬链接 %s => %s"

#: src/ln.c:409
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME\n"
"  or:  %s [OPTION]... TARGET\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...\n"
msgstr ""
"用法：%s [选项]... [-T] 目标 链接名\n"
"　或：%s [选项]... 目标\n"
"　或：%s [选项]... 目标... 目录\n"
"　或：%s [选项]... -t 目录 目标...\n"

#: src/ln.c:416
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""
"在第一种格式中，创建具有指定<链接名>且指向指定<目标>的链接。\n"
"在第二种格式中，在当前目录创建指向<目标>位置的链接。\n"
"在第三、四种格式中，在指定<目录>中创建指向指定<目标>的链接。\n"
"默认创建硬链接，当使用--symbolic 时创建符号链接。\n"
"默认情况下，创建每个目标时不应存在与新链接的名称相同的文件。\n"
"创建硬链接时，每个指定的<目标>都必须存在。符号链接可以指向任意的位置；\n"
"当链接解析正常时，将其解析为一个相对于其父目录的相对链接。\n"

#: src/ln.c:429
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=CONTROL]      为每个已存在的目标文件创建备份文件\n"
"  -b                          类似--backup，但不接受任何参数\n"
"  -d, -F, --directory         允许超级用户尝试创建指向目录的硬链接\n"
"                              （注意：此操作可能因系统限制而失败)\n"
"  -f, --force                 强行删除任何已存在的目标文件\n"

#: src/ln.c:437
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              create symbolic links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive           删除目标文件前进行确认\n"
"  -L, --logical               如目标为符号链接，本次创建链接时将其解引用\n"
"  -n, --no-dereference        如果给定<链接名>是一个链接至某目录的符号链"
"接，\n"
"                                将其作为普通文件处理\n"
"  -P, --physical              创建直接指向符号链接文件的硬链接\n"
"  -r, --relative              创建相对于链接位置的符号链接\n"
"  -s, --symbolic              创建符号链接而非硬链接\n"

#: src/ln.c:446
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=后缀           自行指定备份文件的后缀\n"
"  -t, --target-directory=目录  在指定<目录>中创建链接\n"
"  -T, --no-target-directory   总是将给定的<链接名>当作普通文件\n"
"  -v, --verbose               列出每个链接的文件名称\n"

#: src/ln.c:456
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""
"\n"
"使用 -s 选项会忽略 -L 和 -P。\n"
"否则当<目标>为一个符号链接（默认为 %s）时，会由最后一个指定的选项来控制行"
"为。\n"

#: src/ln.c:572
msgid "cannot do --relative without --symbolic"
msgstr "无 --symbolic 选项时无法启用 --relative"

#: src/ln.c:584
msgid "cannot combine --target-directory and --no-target-directory"
msgstr "无法同时使用 --target-directory 和 --no-target-directory"

#: src/ln.c:632
#, c-format
msgid "target %s"
msgstr "目标 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME：未知"

#: src/logname.c:39
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "用法：%s [选项]\n"

#: src/logname.c:40
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"显示当前用户的名称。\n"
"\n"

#: src/logname.c:78
msgid "no login name"
msgstr "无登录名"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:777
msgid "%b %e  %Y"
msgstr "%b %e  %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:790
msgid "%b %e %H:%M"
msgstr "%b %e %H:%M"

#: src/ls.c:1930
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr "忽略无效的环境变量 COLUMNS 所示的宽度值：%s"

#: src/ls.c:1955
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr "忽略无效的环境变量 TABSIZE 所示的制表符尺寸值：%s"

#: src/ls.c:2074
msgid "invalid line width"
msgstr "无效的行宽"

#: src/ls.c:2142
msgid "invalid tab size"
msgstr "无效的制表符"

#: src/ls.c:2376
#, c-format
msgid "invalid time style format %s"
msgstr "无效的日期时间格式%s"

#: src/ls.c:2400
msgid "Valid arguments are:\n"
msgstr "有效的参数为：\n"

#: src/ls.c:2404
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr "  - +格式字符串（例如，+%H:%M）使用类似“date”风格的格式\n"

#: src/ls.c:2778
#, c-format
msgid "unrecognized prefix: %s"
msgstr "无法识别的前缀：%s"

#: src/ls.c:2808
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "LS_COLORS 环境变量中存在无法解析的值"

#: src/ls.c:2838 src/stat.c:1046
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr "忽略无效的环境变量QUOTING_STYLE 的键值：%s"

#: src/ls.c:2905 src/pwd.c:164
#, c-format
msgid "cannot open directory %s"
msgstr "无法打开目录 %s"

#: src/ls.c:2920
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "无法决定%s 所在的设备及inode"

#: src/ls.c:2929
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s：不会再列出已经列出的目录"

#: src/ls.c:2954 src/ls.c:3390 src/selinux.c:127 src/selinux.c:300
#, c-format
msgid "error canonicalizing %s"
msgstr "标准化 %s 出错"

#: src/ls.c:3017 src/ls.c:3032 src/pwd.c:232
#, c-format
msgid "reading directory %s"
msgstr "正在读取目录 %s"

#: src/ls.c:3048
#, c-format
msgid "closing directory %s"
msgstr "正在关闭目录 %s"

#: src/ls.c:3765
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "无法比较文件名 %s 和 %s"

#: src/ls.c:5343
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""
"列出给定文件（默认为当前目录）的信息。\n"
"如果不指定 -cftuvSUX 中任意一个或--sort 选项，则根据字母大小排序。\n"

#: src/ls.c:5350
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all                  不隐藏任何以 . 开始的项目\n"
"  -A, --almost-all           列出除 . 及 .. 以外的任何项目\n"
"      --author               与 -l 同时使用时，列出每个文件的作者\n"
"  -b, --escape               以 C 风格的转义序列表示不可打印的字符\n"

#: src/ls.c:5356
msgid ""
"      --block-size=SIZE      with -l, scale sizes by SIZE when printing "
"them;\n"
"                               e.g., '--block-size=M'; see SIZE format "
"below\n"
msgstr ""
"      --block-size=大小      与 -l 同时使用时，将文件大小以此处给定的大小为\n"
"                               单位进行缩放；例如：“--block-size=M”；\n"
"                               请参考下文的大小格式说明\n"

#: src/ls.c:5360
msgid ""
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information);\n"
"                               with -l: show ctime and sort by name;\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""
"  -B, --ignore-backups       不列出任何以 ~ 字符结束的项目\n"
"  -c                         与 -lt 共同使用时：根据 ctime 排序并显示\n"
"                             ctime（文件状态最后更改的时间）；\n"
"                             与 -l 共同使用时：显示 ctime 并按照名称排序；\n"
"                             其它情况：按照 ctime 排序，最新的最前\n"

#: src/ls.c:5367
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output; WHEN can be "
"'always' (default\n"
"                               if omitted), 'auto', or 'never'; more info "
"below\n"
"  -d, --directory            list directories themselves, not their "
"contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         每栏由上至下列出项目\n"
"      --color[=WHEN]         控制是否使用带颜色的输出；WHEN 可以是\n"
"                               “always”（默认缺省值）、“auto”或\n"
"                               “never”；更多信息请见下文\n"
"  -d, --directory            当遇到目录时列出目录本身而非目录内的文件\n"
"  -D, --dired                产生适合 Emacs 的 dired 模式使用的结果\n"

#: src/ls.c:5376
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append '*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         不进行排序，-aU 选项生效，禁用 -ls --color\n"
"  -F, --classify             加上文件类型的指示符号（*/=@| 其中一个）\n"
"      --file-type            类似，但不后缀‘*’字符\n"
"      --format=关键字        交错 -x，逗号分隔 -m，水平 -x，长 -l，\n"
"                               单栏 -1，详细 -l，垂直 -C\n"
"      --full-time            类似 -l --time-style=full-iso\n"

#: src/ls.c:5384
msgid "  -g                         like -l, but do not list owner\n"
msgstr "  -g                         类似 -l，但不列出所有者\n"

#: src/ls.c:5387
msgid ""
"      --group-directories-first\n"
"                             group directories before files;\n"
"                               can be augmented with a --sort option, but "
"any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"                             在文件前分组目录；\n"
"                               此选项可与--sort 一起使用，但是一旦使用\n"
"                               --sort=none (-U) 将禁用分组\n"

#: src/ls.c:5393
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
msgstr "  -G, --no-group             以一个长列表的形式，不输出组名\n"

#: src/ls.c:5396
msgid ""
"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G "
"etc.\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -h, --human-readable       与 -l 和 -s 一起，以易于阅读的格式输出文件\n"
"                             大小（例如 1K 234M 2G等）\n"
"      --si                   同上面类似，但是使用 1000 为基底而非 1024\n"

#: src/ls.c:5400
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                               that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             跟随命令行列出的符号链接\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             跟随命令行列出的指向目录的符号链接\n"
"      --hide=PATTERN         隐藏符合 shell PATTERN 模式的项目\n"
"                               （-a 或 -A 将覆盖此选项）\n"

#: src/ls.c:5410
msgid ""
"      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
"                               (default if omitted), 'auto', or 'never'\n"
msgstr ""
"      --hyperlink[=WHEN]     文件名使用超链接；WHEN 可以是“always”\n"
"                               （缺省时的默认选项）、“auto”或\n"
"                               “never”\n"

#: src/ls.c:5414
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
msgstr ""
"      --indicator-style=方式  指定在每个项目名称后加上指示符号方式：\n"
"                               none（默认）、slash（-p）、\n"
"                               file-type（--file-type）以及 classify（-F）\n"
"  -i, --inode                显示每个文件的索引编号（inode 号）\n"
"  -I, --ignore=模式          不显示任何匹配指定 shell <模式>的项目\n"

#: src/ls.c:5423
msgid ""
"  -k, --kibibytes            default to 1024-byte blocks for disk usage;\n"
"                               used only with -s and per directory totals\n"
msgstr ""
"  -k, --kibibytes            默认使用 1024 字节的块显示磁盘使用量；\n"
"                               只用于 -s 和每个目录的总计\n"

#: src/ls.c:5427
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l\t\t\t\t使用较长格式列出信息\n"
"  -L, --dereference\t\t当显示符号链接的文件信息时，显示符号链接所指示\n"
"\t\t\t\t的对象而并非符号链接本身的信息\n"
"  -m\t\t\t\t所有项目以逗号分隔，并填满整行行宽\n"

#: src/ls.c:5435
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print entry names without quoting\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      类似 -l，但列出用户和组的 ID 号\n"
"  -N, --literal              输出未经引号括起的项目名称\n"
"  -o                         类似 -l，但不列出有关组的信息\n"
"  -p, --indicator-style=slash\n"
"                             对目录附加“/”作为指示符号\n"

#: src/ls.c:5442
msgid ""
"  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
"      --show-control-chars   show nongraphic characters as-is (the default,\n"
"                               unless program is 'ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
"                               (overrides QUOTING_STYLE environment "
"variable)\n"
msgstr ""
"  -q, --hide-control-chars   以“?”字符代替无法打印的字符\n"
"      --show-control-chars   原样显示无法打印的字符（这是默认行为，除非被调"
"用\n"
"                               本程序的名称是“ls”而且是在终端中进行输出）\n"
"  -Q, --quote-name           将条目名称括上双引号\n"
"      --quoting-style=方式   使用指定引用的方式显示条目的名称：\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
"                               （该选项优先于 QUOTING_STYLE 环境变量的配"
"置）\n"

#: src/ls.c:5453
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse\t\t\t逆序排列\n"
"  -R, --recursive\t\t递归显示子目录\n"
"  -s, --size\t\t\t以块数形式显示每个文件分配的尺寸\n"

#: src/ls.c:5458
#, fuzzy
msgid ""
"  -S                         sort by file size, largest first\n"
"      --sort=WORD            sort by WORD instead of name: none (-U), size (-"
"S),\n"
"                               time (-t), version (-v), extension (-X)\n"
"      --time=WORD            change the default of using modification "
"times;\n"
"                               access time (-u): atime, access, use;\n"
"                               change time (-c): ctime, status;\n"
"                               birth time: birth, creation;\n"
"                             with -l, WORD determines which time to show;\n"
"                             with --sort=time, sort by WORD (newest first)\n"
msgstr ""
"  -S                         根据文件大小排序，最大的最前\n"
"      --sort=关键字          按照指定关键字而非名称进行排序：\n"
"                               none（无，-U）、size（大小，-S）、\n"
"                               time（时间，-t）、version（版本，-v）、\n"
"                               extension（扩展名，-X）\n"
"      --time=关键字          和 -l 同时使用时显示给定关键字所代表的时间\n"
"                               而非默认文件修改时间：atime 或 access 或\n"
"                               use（-u）；ctime 或 status（-c）；另外加上\n"
"                               --sort=time 选项时会以指定时间作为排序关键字\n"
"                               （最新的最靠前）\n"

#: src/ls.c:5470
msgid ""
"      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE "
"below\n"
msgstr ""
"      --time-style=TIME_STYLE  使用 -l 时显示的时间/日期格式；请见下面\n"
"                                 TIME_STYLE 的相关内容\n"

#: src/ls.c:5473
msgid ""
"  -t                         sort by time, newest first; see --time\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         按时间排序，最新的最前；参见 --time\n"
"  -T, --tabsize=COLS         指定制表符（Tab）的宽度，而非默认8字符\n"

#: src/ls.c:5477
msgid ""
"  -u                         with -lt: sort by, and show, access time;\n"
"                               with -l: show access time and sort by name;\n"
"                               otherwise: sort by access time, newest first\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u                         同 -lt 一起使用：按照访问时间排序并显示；\n"
"                               同 -l 一起使用：显示访问时间并按文件名排序\n"
"                               其它：按照访问时间排序，最新的最靠前\n"
"  -U                         不进行排序；按照目录顺序列出项目\n"
"  -v                         在文本中进行数字（版本）的自然排序\n"

#: src/ls.c:5484
msgid ""
"  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any security context of each file\n"
"  -1                         list one file per line.  Avoid '\\n' with -q or "
"-b\n"
msgstr ""
"  -w, --width=COLS           设置输出宽度为 COLS 对应的值。0 代表无限制\n"
"  -x                         逐行列出项目而不是逐栏列出\n"
"  -X                         根据扩展名按字母顺序排序\n"
"  -Z, --context              输出每个文件的所有安全上下文信息\n"
"  -1                         每行只列出一个文件。与 -q 或 -b 共用时避免 "
"'\\n'\n"

#: src/ls.c:5495
msgid ""
"\n"
"The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n"
"FORMAT is interpreted like in date(1).  If FORMAT is "
"FORMAT1<newline>FORMAT2,\n"
"then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n"
"TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX "
"locale.\n"
"Also the TIME_STYLE environment variable sets the default style to use.\n"
msgstr ""
"\n"
"TIME_STYLE 参数可以是 full-iso、long-iso、iso、locale 或 +格式。\n"
"这里的格式字符串按照类似 date(1) 的方式进行解读。如果格式字符串是\n"
"格式1<换行符>格式2 的形式的话，格式1对应的字符串将应用于不是最近使用的文件\n"
"而格式2对应的字符串将应用于最近使用的文件。TIME_STYLE 如果带有“posix-”\n"
"前缀，它只会在 POSIX locale 之外发挥作用。另外，TIME_STYLE 环境变量如果存在\n"
"则会作为默认使用的格式。\n"

#: src/ls.c:5503
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"使用色彩来区分文件类型的功能已被禁用，默认设置和 --color=never 同时禁用了"
"它。\n"
"使用 --color=auto 选项，ls 只在标准输出被连至终端时才生成颜色代码。\n"
"LS_COLORS 环境变量可改变此设置，可使用 dircolors 命令来设置。\n"
"\n"

#: src/ls.c:5510
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"退出状态：\n"
" 0  正常\n"
" 1  一般问题 (例如：无法访问子文件夹)\n"
" 2  严重问题 (例如：无法使用命令行参数)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:108
msgid "Samuel Neves"
msgstr "Samuel Neves"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:111 src/seq.c:48
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:112
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:113
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:229
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"显示或检查 %s（%d位）校验和。\n"

#: src/md5sum.c:239
msgid ""
"\n"
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"\n"
"  -b, --binary         以二进制模式读取（除非从 tty 标准输入读取，否则为默"
"认）\n"

#: src/md5sum.c:244
msgid ""
"\n"
"  -b, --binary         read in binary mode\n"
msgstr ""
"\n"
"  -b, --binary         以二进制模式读取\n"

#: src/md5sum.c:249
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr "  -c, --check\t\t从文件中读取%s 的校验值并予以检查\n"

#: src/md5sum.c:253
msgid ""
"  -l, --length         digest length in bits; must not exceed the maximum "
"for\n"
"                       the blake2 algorithm and must be a multiple of 8\n"
msgstr ""
"  -l, --length         摘要长度，以比特位计算；不能超过 blake2 算法的最大值\n"
"                       且必须是 8 的倍数\n"

#: src/md5sum.c:258
msgid "      --tag            create a BSD-style checksum\n"
msgstr "      --tag            创建一个 BSD 风格的校验和\n"

#: src/md5sum.c:262
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr "  -t, --text\t\t以纯文本模式读取(从tty 标准输入读取时为默认)\n"

#: src/md5sum.c:266
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text\t\t以纯文本模式读取(默认)\n"

#: src/md5sum.c:269
msgid ""
"  -z, --zero           end each output line with NUL, not newline,\n"
"                       and disable file name escaping\n"
msgstr ""
"  -z, --zero           以 NUL 空字符而非换行符结束每一输出行，\n"
"                       同时禁用文件名转义\n"

#: src/md5sum.c:273
msgid ""
"\n"
"The following five options are useful only when verifying checksums:\n"
"      --ignore-missing  don't fail or report status for missing files\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"      --strict         exit non-zero for improperly formatted checksum "
"lines\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"以下五个选项在进行校验时非常有用：\n"
"      --ignore-missing  不要为缺失的文件进行报告或者返回失败状态\n"
"      --quiet          不为校验成功的文件输出 OK\n"
"      --status         不输出任何内容，使用退出状态号显示成功\n"
"      --strict         为格式不准确的校验和行返回非零状态\n"
"  -w, --warn           对格式不准确的校验和行进行警告\n"
"\n"

#: src/md5sum.c:285
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print a\n"
"line with checksum, a space, a character indicating input mode ('*' for "
"binary,\n"
"' ' for text or where binary is insignificant), and name for each FILE.\n"
"\n"
"Note: There is no difference between binary mode and text mode on GNU "
"systems.\n"
msgstr ""
"\n"
"校验和会按照 %s 所描述的规范生成。在进行检查时，给出的输入格式应该和\n"
"程序先前输出的格式相同。默认的输出模式时输出一行校验和的校验结果、一个空格\n"
"以及一个指示输入模式的字符（“*”代表二进制，“ ”代表纯文本或者二进制特性\n"
"不明显的数据），并同时显示每个文件的名称。\n"
"\n"
"注意：GNU 系统上二进制模式和文本模式没有区别。\n"

#: src/md5sum.c:697
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s：校验和的行数过多"

#: src/md5sum.c:720
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s：%<PRIuMAX>：%s 的校验和行目格式不适当"

#: src/md5sum.c:752
msgid "FAILED open or read"
msgstr "打开或读取失败"

#: src/md5sum.c:790
msgid "FAILED"
msgstr "失败"

#: src/md5sum.c:792
msgid "OK"
msgstr "成功"

#: src/md5sum.c:816
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s：找不到格式适用的%s 校验和"

#: src/md5sum.c:826
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "警告：%<PRIuMAX> 行的格式不适当"

#: src/md5sum.c:834
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "警告：%<PRIuMAX> 个列出的文件无法读取"

#: src/md5sum.c:842
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "警告：%<PRIuMAX> 个校验和不匹配"

#: src/md5sum.c:848
#, c-format
msgid "%s: no file was verified"
msgstr "%s：未验证任何文件"

#: src/md5sum.c:898
msgid "invalid length"
msgstr "无效的长度"

#: src/md5sum.c:902 src/md5sum.c:954
#, c-format
msgid "invalid length: %s"
msgstr "无效的长度：%s"

#: src/md5sum.c:903
msgid "length is not a multiple of 8"
msgstr "长度不是 8 的倍数"

#: src/md5sum.c:956
#, c-format
msgid "maximum digest length for %s is %<PRIuMAX> bits"
msgstr "%s 最大摘要长度为 %<PRIuMAX> 比特"

#: src/md5sum.c:974
#, c-format
msgid "--tag does not support --text mode"
msgstr "--tag 不支持 --text 模式"

#: src/md5sum.c:980
#, c-format
msgid "the --zero option is not supported when verifying checksums"
msgstr "在校验时不支持 --zero 选项"

#: src/md5sum.c:987
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "在校验时--tag 选项无意义"

#: src/md5sum.c:994
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "在校验时--binary 和--text 选项无意义"

#: src/md5sum.c:1002
#, c-format
msgid "the --ignore-missing option is meaningful only when verifying checksums"
msgstr "仅在校验时 --ignore-missing 选项有意义"

#: src/md5sum.c:1010
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "仅在校验时 --status 选项有意义"

#: src/md5sum.c:1017
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "仅在校验时 --warn 选项才有意义"

#: src/md5sum.c:1024
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "只有在校验时 --quiet 选项才有意义"

#: src/md5sum.c:1031
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "只有在校验时 --strict 选项才有意义"

#: src/mkdir.c:59 src/rmdir.c:164
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "用法：%s [选项]... 目录...\n"

#: src/mkdir.c:60
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr "若指定<目录>不存在则创建目录。\n"

#: src/mkdir.c:66
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""
"  -m, --mode=模式   设置权限模式（类似chmod），而不是 a=rwx 减 umask\n"
"  -p, --parents     需要时创建目标目录的上层目录，但即使这些目录已存在\n"
"                      也不当作错误处理\n"
"  -v, --verbose     每次创建新目录都显示信息\n"

#: src/mkdir.c:71
msgid ""
"  -Z                   set SELinux security context of each created "
"directory\n"
"                         to the default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   设置每个创建的目录的 SELinux 安全上下文为默认类型\n"
"      --context[=CTX]  类似 -Z，或如果指定了 CTX，则将 SELinux 或 SMACK 安"
"全\n"
"                         上下文设置为 CTX 对应的值\n"

#: src/mkdir.c:221
#, c-format
msgid "created directory %s"
msgstr "已创建目录 %s"

#: src/mkdir.c:239 src/mkfifo.c:117 src/mknod.c:134
#, c-format
msgid ""
"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel"
msgstr "警告：忽略 --context 参数；它需要启用 SELinux/SMARK 的内核"

#: src/mkfifo.c:54 src/pathchk.c:88
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "用法：%s [选项]... 名称...\n"

#: src/mkfifo.c:55
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr "以指定的<名称>创建命名管道（FIFO）。\n"

#: src/mkfifo.c:61 src/mknod.c:63
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=模式   \t设置权限模式(类似chmod)，而不是rwxrwxrwx 减umask\n"

#: src/mkfifo.c:64 src/mknod.c:66
msgid ""
"  -Z                   set the SELinux security context to default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   设置 SELinux 安全上下文为默认类型\n"
"      --context[=CTX]  类似 -Z，或者如果指定了 CTX 则设置 SELinux 或\n"
"                         SMACK 安全上下文为给定的 CTX 值\n"

#: src/mkfifo.c:154 src/mknod.c:151
msgid "invalid mode"
msgstr "无效的权限模式"

#: src/mkfifo.c:161 src/mknod.c:158
msgid "mode must specify only file permission bits"
msgstr "模式必须只指定文件许可位"

#: src/mkfifo.c:175 src/mknod.c:271
#, c-format
msgid "cannot set permissions of %s"
msgstr "无法设置 %s 的权限"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "用法：%s [选项]... 名称 类型 [主设备号 次设备号]\n"

#: src/mknod.c:57
msgid "Create the special file NAME of the given TYPE.\n"
msgstr "以指定的名称和指定的类型创建特殊文件。\n"

#: src/mknod.c:73
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"当类型为\"p\"时可不指定主设备号和次设备号，否则它们是必须指定的。\n"
"如果主设备号和次设备号以\"0x\"或\"0X\"开头，它们会被视作十六进制数来\n"
"解析；如果以\"0\"开头，则被视作八进制数；其余情况下被视作十进制数。\n"
"可用的类型包括：\n"

#: src/mknod.c:80
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      创建(有缓冲的)区块特殊文件\n"
"  c, u   创建(没有缓冲的)字符特殊文件\n"
"  p      创建先进先出(FIFO)特殊文件\n"

#: src/mknod.c:176
msgid "Special files require major and minor device numbers."
msgstr "创建块设备文件时，必需指定主、次设备号。"

#: src/mknod.c:186
msgid "Fifos do not have major and minor device numbers."
msgstr "先进先出(FIFO)文件不需要指定主、次设备号。"

#: src/mknod.c:211
msgid "block special files not supported"
msgstr "不支持区块特殊文件"

#: src/mknod.c:220
msgid "character special files not supported"
msgstr "不支持字符特殊文件"

#: src/mknod.c:236
#, c-format
msgid "invalid major device number %s"
msgstr "无效的主设备号 %s"

#: src/mknod.c:241
#, c-format
msgid "invalid minor device number %s"
msgstr "无效的次设备号 %s"

#: src/mknod.c:246
#, c-format
msgid "invalid device %s %s"
msgstr "无效的设备文件%s %s"

#: src/mknod.c:266
#, c-format
msgid "invalid device type %s"
msgstr "无效的设备类型 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:67
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "用法：%s [选项]... [模板]\n"

#: src/mktemp.c:68
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"安全地创建一个临时文件或目录，并且输出它的名字。\n"
"<模板>的最后部分必须含有至少 3 个连续的 'X'。\n"
"如果没有指定<模板>，将会使用 tmp.XXXXXXXXXX，同时隐含启用 --tmpdir 选项。\n"

#: src/mktemp.c:73
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""
"文件创建时采用 u+rw 权限，对目录则使用 u+rwx；同时会减去 umask 限制所给定的"
"值。\n"

#: src/mktemp.c:77
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     创建一个目录而非文件\n"
"  -u, --dry-run       不创建任何东西，仅打印出名字。（不安全）\n"
"  -q, --quiet         不显示任何有关文件或目录创建错误信息\n"

#: src/mktemp.c:82
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X\n"
msgstr ""
"      --suffix=后缀   将给定的<后缀>添加至<模板>字符串之后。后缀字符串中不能"
"带斜杠。\n"
"                        所先前所给<模板>字符串不以 X 结尾，则隐含启用该选"
"项。\n"

#: src/mktemp.c:86
msgid ""
"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name;\n"
"                        unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""
"  -p 目录, --tmpdir[=目录]  将<模板>解释为相对于给定<目录>；如果未指定\n"
"                        <目录>，在设置了 $TMPDIR 变量时使用这个变量的值，\n"
"                        否则使用 /tmp。使用该选项时，<模板>不能是绝对路径；\n"
"                        与 -t 不同，<模板>字符串可以包含斜线，但此时\n"
"                        mktemp 只会创建斜线后的部分\n"

#: src/mktemp.c:93
msgid ""
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -t                  将<模板>解释为相对与一个目录的单个文件名部分：该目录\n"
"                        在 $TMPDIR 变量已设置时取该变量的值，否则使用 -p\n"
"                        参数指定的目录，再次将回退至使用 /tmp [不推荐]\n"

#: src/mktemp.c:211
#, c-format
msgid "too many templates"
msgstr "模板过多"

#: src/mktemp.c:231
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "使用 --suffix，模板 %s 必须以 X 结尾"

#: src/mktemp.c:256 src/split.c:1345
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "无效后缀 %s，含有目录分隔符"

#: src/mktemp.c:261
#, c-format
msgid "too few X's in template %s"
msgstr "模板 %s 中的 X 太少"

#: src/mktemp.c:277
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "无效模板，%s，包含目录分隔符"

#: src/mktemp.c:291
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "无效模板，%s；如果与--tmpdir 同时使用则不可以是绝对路径"

#: src/mktemp.c:312
#, c-format
msgid "failed to create directory via template %s"
msgstr "无法通过模板 %s 创建目录"

#: src/mktemp.c:323
#, c-format
msgid "failed to create file via template %s"
msgstr "无法通过模板 %s 创建文件"

#: src/mv.c:298
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr "将<源文件>重命名为<目标文件>，或将<源文件>移动至指定<目录>。\n"

#: src/mv.c:304
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=CONTROL]       为每个已存在的目标文件创建备份\n"
"  -b                           类似--backup 但不接受参数\n"
"  -f, --force                  覆盖前不询问\n"
"  -i, --interactive            覆盖前询问\n"
"  -n, --no-clobber             不覆盖已存在文件\n"
"如果您指定了-i、-f、-n 中的多个，仅最后一个生效。\n"

#: src/mv.c:313
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes\t去掉每个源文件参数尾部的斜线\n"
"  -S, --suffix=SUFFIX\t\t替换常用的备份文件后缀\n"

#: src/mv.c:318
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -Z, --context                set SELinux security context of destination\n"
"                                 file to default type\n"
msgstr ""
"  -t, --target-directory=目录  将所有<源文件>移动至指定的<目录>中\n"
"  -T, --no-target-directory    将参数中所有<目标文件>部分视为普通文件\n"
"  -u, --update                 仅在<源文件>比目标文件更新，或者目标文件\n"
"                               不存在时进行移动操作\n"
"  -v, --verbose                对正在发生的操作给出解释\n"
"  -Z, --context                将目标文件的 SELinux 安全上下文设置为\n"
"                                 默认类型\n"

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "用法：%s [选项] [命令 [参数]...]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""
"以指定的优先级运行命令，这会影响相应进程的调度。\n"
"如果不指定命令，程序会显示当前的优先级。优先级的范围是从 %d\n"
"（最大优先级）到 %d（最小优先级）。\n"

#: src/nice.c:83
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr "  -n, --adjustment=N   在优先级数值上加上数字 N（默认为 10）\n"

#: src/nice.c:173
#, c-format
msgid "invalid adjustment %s"
msgstr "无效的调整值%s"

#: src/nice.c:182
#, c-format
msgid "a command must be given with an adjustment"
msgstr "命令必须和调整值配合指定"

#: src/nice.c:189 src/nice.c:200
msgid "cannot get niceness"
msgstr "无法获取优先级"

#: src/nice.c:206
#, c-format
msgid "cannot set niceness"
msgstr "无法设置优先级"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:41
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:180
msgid "Write each FILE to standard output, with line numbers added.\n"
msgstr "将指定的各个<文件>添加行号标注后写到标准输出。\n"

#: src/nl.c:187
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for logical page delimiters\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=样式       使用指定样式编号文件的正文行目\n"
"  -d, --section-delimiter=CC      使用指定的 CC 作为逻辑页分隔符\n"
"  -f, --footer-numbering=样式     使用指定样式编号文件的页脚行目\n"

#: src/nl.c:192
#, fuzzy
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers for each "
"section\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=样式\t使用指定样式编号文件的页眉行目\n"
"  -i, --page-increment=数值\t设置每一行遍历后的自动递增值\n"
"  -l, --join-blank-lines=数值\t设置数值为多少的若干空行被视作一行\n"
"  -n, --number-format=格式\t根据指定格式插入行号\n"
"  -p, --no-renumber\t\t在逻辑页数切换时不将行号值复位\n"
"  -s, --number-separator=字符串\t可能的话在行号后添加字符串\n"

#: src/nl.c:200
#, fuzzy
msgid ""
"  -v, --starting-line-number=NUMBER  first line number for each section\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=数字\t每个逻辑页上的第一行的行号\n"
"  -w, --number-width=数字\t为行号使用指定的栏数\n"

#: src/nl.c:206
msgid ""
"\n"
"Default options are: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n"
"\n"
"CC are two delimiter characters used to construct logical page delimiters;\n"
"a missing second character implies ':'.\n"
msgstr ""
"\n"
"默认的选项设置是：-bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n"
"\n"
"CC 是用于构建逻辑分页符的两个分界符号；如第二个符号缺失，则认为默认\n"
"使用 \":\"。\n"

#: src/nl.c:213
#, fuzzy
msgid ""
"\n"
"STYLE is one of:\n"
"\n"
"  a      number all lines\n"
"  t      number only nonempty lines\n"
"  n      number no lines\n"
"  pBRE   number only lines that contain a match for the basic regular\n"
"         expression, BRE\n"
msgstr ""
"\n"
"  a\t对所有行编号\n"
"  t\t对非空行编号\n"
"  n\t不编行号\n"
"  pBRE\t只对符合正则表达式BRE 的行编号\n"
"\n"
"FORMAT 是下列之一:\n"
"\n"
"  ln\t左对齐，空格不用0 填充\n"
"  rn \t右对齐，空格不用0 填充\n"
"  rz \t右对齐，空格用0 填充\n"
"\n"

#: src/nl.c:223
msgid ""
"\n"
"FORMAT is one of:\n"
"\n"
"  ln     left justified, no leading zeros\n"
"  rn     right justified, no leading zeros\n"
"  rz     right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"格式字符串取下面列表中的任一项：\n"
"\n"
"  ln     左对齐，空格不用 0 填充\n"
"  rn     右对齐，空格不用 0 填充\n"
"  rz     右对齐，空格用 0 填充\n"
"\n"

#: src/nl.c:281
msgid "line number overflow"
msgstr "行号溢出"

#: src/nl.c:484
#, c-format
msgid "invalid header numbering style: %s"
msgstr "无效的页眉号样式：%s"

#: src/nl.c:492
#, c-format
msgid "invalid body numbering style: %s"
msgstr "无效的正文号样式：%s"

#: src/nl.c:500
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "无效的页脚号样式：%s"

#: src/nl.c:507
msgid "invalid starting line number"
msgstr "无效的起始行号"

#: src/nl.c:512
msgid "invalid line number increment"
msgstr "无效的行号递增值"

#: src/nl.c:519
msgid "invalid line number of blank lines"
msgstr "无效的空行数"

#: src/nl.c:526
msgid "invalid line number field width"
msgstr "无效的行宽数值"

#: src/nl.c:537
#, c-format
msgid "invalid line numbering format: %s"
msgstr "无效的编号格式：%s"

#: src/nohup.c:50
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 命令 [参数]...\n"
"　或：%s 选项\n"

#: src/nohup.c:56
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"忽略挂起信号运行指定的命令。\n"
"\n"

#: src/nohup.c:62
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from an unreadable file.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"如果标准输入是一个终端，则将其重定向为使用一个无法读取的文件。\n"
"如果标准输出是一个终端，在可能的情况下将输出附加到“nohup.out”，\n"
"否则使用“$HOME/nohup.out”文件。\n"
"如果标准错误输出是一个终端，重定向它到标准输出。\n"
"要保存输出内容到一个文件，使用 \"%s COMMAND > FILE\" 形式的命令。\n"

#: src/nohup.c:123
#, c-format
msgid "failed to render standard input unusable"
msgstr "标准输入不可用，无法重定向"

#: src/nohup.c:125
#, c-format
msgid "ignoring input"
msgstr "忽略输入"

#: src/nohup.c:169
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "忽略输入并把输出追加到%s"

#: src/nohup.c:170
#, c-format
msgid "appending output to %s"
msgstr "把输出追加到 %s"

#: src/nohup.c:188
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "忽略输入重定向错误到标准输出端"

#: src/nohup.c:189
#, c-format
msgid "redirecting stderr to stdout"
msgstr "重定向标准错误到标准输出"

#: src/nohup.c:193
#, c-format
msgid "failed to redirect standard error"
msgstr "重定向标准错误失败"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33 src/sync.c:34
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:121 src/whoami.c:44
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "用法：%s [选项]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"打印当前进程可用的处理器数，\n"
"此数目可能小于实际工作数\n"
"\n"

#: src/nproc.c:63
msgid ""
"      --all      print the number of installed processors\n"
"      --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"      --all      打印所拥有的处理器数目\n"
"      --ignore=N  可能的话，排除 N 个处理单元\n"

#: src/numfmt.c:694
#, c-format
msgid "value too large to be converted: %s"
msgstr "值过大而无法转换：%s"

#: src/numfmt.c:698
#, c-format
msgid "invalid number: %s"
msgstr "无效的数字：%s"

#: src/numfmt.c:702
#, c-format
msgid "rejecting suffix in input: %s (consider using --from)"
msgstr "拒绝输入中的后缀：%s（请考虑使用 --from）"

#: src/numfmt.c:706
#, c-format
msgid "invalid suffix in input: %s"
msgstr "输入中存在无效后缀：%s"

#: src/numfmt.c:710
#, c-format
msgid "missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)"
msgstr "输入中缺少 'i' 后缀：%s（例如，Ki/Mi/Gi）"

#: src/numfmt.c:757 src/numfmt.c:809
#, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr "为输出准备值“%Lf”失败"

#: src/numfmt.c:858
#, c-format
msgid "invalid unit size: %s"
msgstr "无效的单位大小：%s"

#: src/numfmt.c:884
#, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr "用法: %s [选项]... [数字]...\n"

#: src/numfmt.c:887
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""
"对参数给出的数字进行格式化，或者在参数未给出数字的情况下从标准输入获取数"
"字。\n"

#: src/numfmt.c:891
msgid "      --debug          print warnings about invalid input\n"
msgstr "      --debug          对无效输入内容打印警告信息\n"

#: src/numfmt.c:894
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr "  -d, --delimiter=X    使用 X 替代空白作为域定界符\n"

#: src/numfmt.c:897
msgid ""
"      --field=FIELDS   replace the numbers in these input fields "
"(default=1)\n"
"                         see FIELDS below\n"
msgstr ""
"      --field=域       将这些输入域中的数字进行替换（默认=1)\n"
"                         请见下面给出的域的详细信息\n"

#: src/numfmt.c:901
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""
"      --format=格式    使用 printf 风格的浮点格式；参见下文的“格式”\n"
"                         部分以了解细节\n"

#: src/numfmt.c:905
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""
"      --from=UNIT      将输入数字自动使用指定的单位进行缩放；默认为 none；\n"
"                         详情请见下面的“单位”相关内容\n"

#: src/numfmt.c:909
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr "      --from-unit=N    指定输入的单位大小（默认为 1）\n"

#: src/numfmt.c:912
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""
"      --grouping       使用时间和区域设置所定义的方法对数字进行分组，例如\n"
"                         1,000,000（即该设置在 C/POSIX 的区域设置下无作用）\n"

#: src/numfmt.c:916
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""
"      --header[=N]     原样输出起始的 N 行头部内容（不进行转换）；\n"
"                         如未指定 N，默认取值为 1\n"

#: src/numfmt.c:920
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""
"      --invalid=模式   遇到无效数字时的处理模式：给定的模式可以是：\n"
"                         abort（默认）, fail, warn, ignore\n"

#: src/numfmt.c:924
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""

#: src/numfmt.c:931
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""
"      --round=方法     缩放时使用指定方法四舍五入；指定的方法可以是：\n"
"                         up, down, from-zero（默认）, towards-zero, nearest\n"

#: src/numfmt.c:935
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""
"      --suffix=后缀    将指定的后缀添加到输出数字之后，并接受输入数字中\n"
"                         存在该后缀的情况\n"

#: src/numfmt.c:939
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""
"      --to=UNIT        将输出数字使用指定单位自动缩放；详见下方“单位”内容\n"

#: src/numfmt.c:942
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr "      --to-unit=N      输出单位大小（默认值为 1)\n"

#: src/numfmt.c:951
msgid ""
"\n"
"UNIT options:\n"
msgstr ""
"\n"
"单位选项：\n"

#: src/numfmt.c:954
msgid "  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr "  none       不进行自动缩放；带后缀会触发错误\n"

#: src/numfmt.c:957
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""
"  auto       接受可选的单字符或双字符后缀：\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"

#: src/numfmt.c:963
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""
"  si         接受可选的单字符后缀：\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"

#: src/numfmt.c:968
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""
"  iec        接受可选的单字符后缀：\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"

#: src/numfmt.c:973
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""
"  iec-i      接受可选的双字符后缀：\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"

#: src/numfmt.c:979
msgid ""
"\n"
"FIELDS supports cut(1) style field ranges:\n"
"  N    N'th field, counted from 1\n"
"  N-   from N'th field, to end of line\n"
"  N-M  from N'th to M'th field (inclusive)\n"
"  -M   from first to M'th field (inclusive)\n"
"  -    all fields\n"
"Multiple fields/ranges can be separated with commas\n"
msgstr ""
"\n"
"参数中的域支持 cut(1) 风格的域范围：\n"
"  N    从第 1 个开始数的第 N 个域\n"
"  N-   从第 N 个开始到所在行结束的域\n"
"  N-M  从第 N 个开始到第 M 个之间（包括头尾）的域\n"
"  -M   从第 1 个开始到第 M 个之间（包括头尾）的域\n"
"  -    所有域\n"
"多个域/范围可以使用逗号分隔\n"

#: src/numfmt.c:989
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional zero (%010f) width\n"
"will zero pad the number. Optional negative values (%-10f) will left align.\n"
"Optional precision (%.1f) will override the input determined precision.\n"
msgstr ""

#: src/numfmt.c:997
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""

#: src/numfmt.c:1006
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""
"\n"
"示例：\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"

#: src/numfmt.c:1059 src/seq.c:248
#, c-format
msgid "format %s has no %% directive"
msgstr "格式%s 没有%% 指令"

#: src/numfmt.c:1086
#, c-format
msgid "invalid format %s (width overflow)"
msgstr "无效的格式 %s（宽度溢出）"

#: src/numfmt.c:1091
#, c-format
msgid "--format padding overriding --padding"
msgstr "--format 的填充值将覆盖 --padding"

#: src/numfmt.c:1110 src/seq.c:265
#, c-format
msgid "format %s ends in %%"
msgstr "格式 %s 以 %% 结束"

#: src/numfmt.c:1126
#, c-format
msgid "invalid precision in format %s"
msgstr "格式 %s 中存在无效的精度"

#: src/numfmt.c:1132
#, c-format
msgid "invalid format %s, directive must be %%[0]['][-][N][.][N]f"
msgstr "无效的格式 %s，指令必须为 %%[0]['][-][N][.][N]f"

#: src/numfmt.c:1140 src/seq.c:272
#, c-format
msgid "format %s has too many %% directives"
msgstr "格式%s 中%% 指令过多"

#: src/numfmt.c:1183
#, c-format
msgid "invalid suffix in input %s: %s"
msgstr "在输入 %s:%s 中有无效后缀"

#: src/numfmt.c:1212
#, c-format
msgid ""
"value/precision too large to be printed: '%Lg/%<PRIuMAX>' (consider using --"
"to)"
msgstr "值/精确度过大无法打印：“%Lg/%<PRIuMAX>”（请考虑使用 --to）"

#: src/numfmt.c:1216
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr "值过大无法输出：'%Lg'（请考虑使用 --to）"

#: src/numfmt.c:1225
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr "值过大无法输出：'%Lg'（无法处理 > 999Y 的值）"

#: src/numfmt.c:1311
#, c-format
msgid "large input value %s: possible precision loss"
msgstr "较大的输入值 %s：可能出现精度丢失"

#: src/numfmt.c:1500
#, c-format
msgid "invalid padding value %s"
msgstr "无效的填充值 %s"

#: src/numfmt.c:1513
msgid "multiple field specifications"
msgstr "无效的域规格"

#: src/numfmt.c:1547
#, c-format
msgid "invalid header value %s"
msgstr "无效的头部值 %s"

#: src/numfmt.c:1574
msgid "--grouping cannot be combined with --format"
msgstr "--grouping 不能与 --format 结合使用"

#: src/numfmt.c:1577 src/sort.c:4686
#, c-format
msgid "failed to set locale"
msgstr "设置区域语言 locale 失败"

#: src/numfmt.c:1582
#, c-format
msgid "no conversion option specified"
msgstr "未指定转换选项"

#: src/numfmt.c:1590
msgid "grouping cannot be combined with --to"
msgstr "分组操作不能和 --to 共同使用"

#: src/numfmt.c:1592
#, c-format
msgid "grouping has no effect in this locale"
msgstr "当前区域设置下分组没有效果"

#: src/numfmt.c:1605
#, c-format
msgid "--header ignored with command-line input"
msgstr "在命令行输入下 --header 已被忽略"

#: src/numfmt.c:1632
#, c-format
msgid "error reading input"
msgstr "读取输入时出错"

#: src/numfmt.c:1643
#, c-format
msgid "failed to convert some of the input numbers"
msgstr "转换某些输入数字时失败"

#: src/od.c:323
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"用法：%s [选项]... [文件]...\n"
"　或：%s [-abcdfilosx]... [文件] [[+]偏移量[.][b]]\n"
"　或：%s --traditional [选项]... [文件] [[+]偏移量[.][b] [+][标签][.][b]]\n"

#: src/od.c:329
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
msgstr ""
"\n"
"以无歧义的表示方式将指定文件输出至标准输出，默认为八进制字节形式。\n"
"如果指定了多于一个文件，将它们以列出的顺序连接起来作为输入。\n"

#: src/od.c:337
#, fuzzy
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"如果两个调用格式都适用，系统会在最后一个运算量以\"+\"或数字开始\n"
"(如果有两个运算量)的情况下采用第二种格式。\n"
"偏移量是指 -j 偏移量。标签是第一个字节的伪地址，\n"
"随着累积过程递增。偏移量和标签如果冠以\"0x\"或\"0X\"前缀则\n"
"表示十六进制数；后缀\".\"代表八进制数，后缀\"b\"表示乘以 512。\n"

#: src/od.c:349
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"      --endian={big|little}   swap input bytes according the specified "
"order\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""

#: src/od.c:355
#, fuzzy
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars;\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""
"  -N, --read-bytes=字节数\t限制要转储的输入字节为指定的字节数\n"
"  -S, --strings[=字节数]\t输出至少包含指定字节数的字符相应的字串\n"
"  -t, --format=类型\t\t选取输出格式类型\n"
"  -v, --output-duplicates\t不使用\"*\"字符标记屏蔽的行\n"
"  -w, --width[=字节数]\t\t每一行只输出指定的字节数\n"
"      --traditional\t\t接受传统形式提交的参数\n"

#: src/od.c:368
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select printable characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"\n"
"传统格式命令可混合使用，不同的格式可叠加：\n"
"  -a   即 -t a， 使用命名的字符，忽略高阶位\n"
"  -b   即 -t o1，使用八进制单字节字符\n"
"  -c   即 -t c， 使用可打印字符或者反斜杠转义的特殊字符\n"
"  -d   即 -t u2，使用无符号十进制双字节字符\n"

#: src/od.c:377
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f\t即 -t fF，指定浮点数对照输出格式\n"
"  -i\t即 -t dl，指定十进制整数对照输出格式\n"
"  -l\t即 -t dL，指定十进制长整数对照输出格式\n"
"  -o\t即 -t o2，指定双字节单位八进制数的对照输出格式\n"
"  -s\t即 -t d2，指定双字节单位十进制数的对照输出格式\n"
"  -x\t即 -t x2，指定双字节单位十六进制数的对照输出格式\n"

#: src/od.c:385
#, fuzzy
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          printable character or backslash escape\n"
msgstr ""
"\n"
"TYPE 是由下面一种或几种参数组成的：\n"
"\n"
"  a\t\t重定义字符，忽略高位字节\n"
"  c\t\tASCII 码字符或者是反斜线字串(如\\n)\n"

#: src/od.c:392
#, fuzzy
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per float\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[尺寸]\t有符号十进制数，每个整形数占指定尺寸的字节\n"
"  f[尺寸]\t浮点数，每个整形数占指定尺寸的字节\n"
"  o[尺寸]\t八进制数，每个整形数占指定尺寸的字节\n"
"  u[尺寸]\t无符号十进制数，每个整形数占指定尺寸的字节\n"
"  x[尺寸]\t十六进制数，每个整形数占指定尺寸的字节\n"

#: src/od.c:399
#, fuzzy
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"尺寸应该是一个数字。对 doux 等类型来说，适用的尺寸有：\n"
"C 代表 sizeof(char)、S 代表 sizeof(short)、I 代表 \n"
"sizeof(int)，或 L 代表 sizeof(long)；\n"
"如果类型是 f，可适用的尺寸有：\n"
"F 代表 sizeof(float)、D 代表sizeof(double)，或 L 代表\n"
"sizeof(long double)。\n"

#: src/od.c:406
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""

#: src/od.c:411
#, fuzzy
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"K 后面可以跟乘号:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, 对于T, P, E, Z, Y 同样适用。\n"

#: src/od.c:685 src/od.c:805
#, c-format
msgid "invalid type string %s"
msgstr "无效类型的字符串%s"

#: src/od.c:695
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"无效的类型字符串%s；\n"
"系统无法提供对%lu-字节整形类型数值的支持"

#: src/od.c:816
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"无效的类型字符串%s；\n"
"系统无法提供对%lu-字节浮点类型数值的支持"

#: src/od.c:874
#, c-format
msgid "invalid character '%c' in type string %s"
msgstr "无效字符“%c”出现在类型字符串 %s 中"

#: src/od.c:1110
msgid "cannot skip past end of combined input"
msgstr "无法略过输入内容的报尾"

#: src/od.c:1660
#, c-format
msgid "invalid output address radix '%c'; it must be one character from [doxn]"
msgstr "无效的输出地址基数\"%c\"；它必须是 [doxn] 四个字符中的一个"

#: src/od.c:1798
msgid "no type may be specified when dumping strings"
msgstr "在转储字符串时不能指定类型"

#: src/od.c:1873
msgid "compatibility mode supports at most one file"
msgstr "兼容模式最多支持一个文件"

#: src/od.c:1894
msgid "skip-bytes + read-bytes is too large"
msgstr "略过字节数+ 读入字节数的值过大"

#: src/od.c:1937
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "警告：无效的宽度值%lu，已使用%d 代替"

#: src/paste.c:222
msgid "standard input is closed"
msgstr "标准输入已关闭"

#: src/paste.c:440
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
msgstr ""
"将每个指定文件里的各行整合到对应一行里写到标准输出，之间用制表符分隔。\n"

#: src/paste.c:448
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=列表\t改用指定列表里的字符替代制表分隔符\n"
"  -s, --serial\t\t不使用平行的行目输出模式，而是每个文件占用一行\n"

#: src/paste.c:518
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "分割符列表以一个未跳过的反斜线结束：%s"

#: src/pathchk.c:89
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"判断无效或未移植的文件名。\n"
"\n"
"  -p                  \t为类POSIX 兼容系统检查\n"
"  -P                  \t检查空文件名和前导\"-\"文件名\n"
"      --portability   \t为完整POSIX 兼容系统检查(等于-p -P)\n"

#: src/pathchk.c:169
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr "文件名 %s 以\"-\"符号开头"

#: src/pathchk.c:195
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "有不通用的字符%s 被包含在文件名%s 中"

#: src/pathchk.c:271
#, c-format
msgid "empty file name"
msgstr "空文件名"

#: src/pathchk.c:313
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s：不能确定最大文件名长度"

#: src/pathchk.c:324
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "文件名%3$s 的长度%2$lu 超出限值%1$lu"

#: src/pathchk.c:410
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr "文件名成分%3$s 的长度%2$lu 超出限值%1$lu"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:37 src/uptime.c:45 src/users.c:35 src/who.c:50
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:39 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:241
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:265
msgid "?????"
msgstr "?????"

#: src/pinky.c:313
#, c-format
msgid "Login name: "
msgstr "登录名： "

#: src/pinky.c:316
#, c-format
msgid "In real life: "
msgstr "真名： "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:320
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:340
#, c-format
msgid "Directory: "
msgstr "主目录： "

#: src/pinky.c:342
#, c-format
msgid "Shell: "
msgstr "Shell： "

#: src/pinky.c:361
#, c-format
msgid "Project: "
msgstr "项目： "

#: src/pinky.c:385
#, c-format
msgid "Plan:\n"
msgstr "计划：\n"

#: src/pinky.c:404
msgid "Login"
msgstr "登录名"

#: src/pinky.c:406
msgid "Name"
msgstr "名字"

#: src/pinky.c:407
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:409
msgid "Idle"
msgstr "空闲时间"

#: src/pinky.c:410
msgid "When"
msgstr "起始时间"

#: src/pinky.c:413
msgid "Where"
msgstr "来自"

#: src/pinky.c:490
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l\t对指定用户输出完整的长格式信息\n"
"  -b\t在长格式中省略用户主目录以及登录 shell\n"
"  -h\t在长格式中省略用户的项目文件\n"
"  -p\t在长格式中省略用户的计划文件\n"
"  -s\t输出短格式信息(默认)\n"

#: src/pinky.c:498
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f\t在短格式中省略列栏报头\n"
"  -w\t在短格式中省略用户全名\n"
"  -i\t在短格式中省略用户全名以及远程主机\n"
"  -q\t在短格式中省略用户全名、远程主机以及空闲时间\n"

#: src/pinky.c:507
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"一个轻量级的\"finger\"程序，用于显示用户信息。\n"
"用到的 utmp 文件为 %s。\n"

#: src/pinky.c:591
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr "没有指定用户名，当使用 -l 选项时至少需要指定一个"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:332
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:333
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:778
msgid "integer overflow"
msgstr "整数溢出"

#: src/pr.c:917
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "\"--pages=首页[:末页]\" 缺失参数"

#: src/pr.c:919
#, c-format
msgid "invalid page range %s"
msgstr "页码范围%s 无效"

#: src/pr.c:979
msgid "'-l PAGE_LENGTH' invalid number of lines"
msgstr "“-l 页长”中含有无效的行号"

#: src/pr.c:994
msgid "'-N NUMBER' invalid starting line number"
msgstr "“-N 编号”中含有无效的起始行号"

#: src/pr.c:998
msgid "'-o MARGIN' invalid line offset"
msgstr "“-o 页边距”中含有无效的行偏移量"

#: src/pr.c:1035
msgid "'-w PAGE_WIDTH' invalid number of characters"
msgstr "\"-w 页面宽度\" 中含有无效的字符数"

#: src/pr.c:1044
msgid "'-W PAGE_WIDTH' invalid number of characters"
msgstr "\"-w 页面宽度\" 中含有无效的字符数"

#: src/pr.c:1073
msgid "cannot specify number of columns when printing in parallel"
msgstr "在平行输出参数时不能指定栏数"

#: src/pr.c:1077
msgid "cannot specify both printing across and printing in parallel"
msgstr "无法同时指定相交输出和平行输出参数"

#: src/pr.c:1180
#, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr "“-%c”有多余字符或无效数字出现在参数中：%s"

#: src/pr.c:1282
msgid "page width too narrow"
msgstr "页宽过窄"

#: src/pr.c:2338
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr "起始页码%<PRIuMAX> 超出了最大页数%<PRIuMAX>"

#: src/pr.c:2365
msgid "page number overflow"
msgstr "页码溢出"

#: src/pr.c:2370
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "第 %<PRIuMAX> 页"

#: src/pr.c:2742
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr "对给定文件进行分页或分栏以便后续打印使用。\n"

#: src/pr.c:2749
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +首页[:末页], --pages=首页[:末页]\n"
"\t\t\t在指定的首页/末页处开始/停止打印\n"
"  -列数, --columns=列数\n"
"\t\t\t输出指定的列数。如果指定了-a 选项，则从上到下列印。\n"
"\t\t\t程序会自动在每一页均衡每列占用的行数。\n"

#: src/pr.c:2757
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across\t\t设置每列从上到下输出，配合\"-列数\"选项一起使用\n"
"  -c, --show-control-chars\n"
"\t\t\t使用头标(^G)和八进制反斜杠标记\n"
"  -d, --double-space\t加倍输出空白区域\n"

#: src/pr.c:2765
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=格式\n"
"\t\t\t使用遵循指定格式的页眉日期\n"
"  -e[字符[宽度]], --expand-tabs[=字符[宽度]]\n"
"\t\t\t扩展输入的字符(制表符) 到制表符宽度(8)\n"
"  -F, -f, --form-feed\t使用出纸页页标代替新行作为页面间的分隔符\n"
"\t\t\t(使用-F 选项时报头为3 行,不使用时为5 行)\n"

#: src/pr.c:2775
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h, --header=页眉\t在页眉中使用居中的指定字符代替文件名\n"
"\t\t\t-h \"\" 输出一个空行，不要使用 -h\"\"\n"
"  -i[字符[宽度]], --output-tabs[=字符[宽度]]\n"
"\t\t\t使用指定字符(或制表符)代替空格不足到指定制表符宽度(默认8)\n"
"  -J, --join-lines\t合并整个行，关闭-W 选项的行截断，不使用栏调整，使用\n"
"\t\t\t\t--sep-string[=字符串] 设置分隔符\n"

#: src/pr.c:2784
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63).\n"
"                    implies -t if PAGE_LENGTH <= 10\n"
msgstr ""
"  -l, --length=页长\n"
"                    使用指定页长的行数（默认为66）\n"
"                    (默认文本行数为 56,当启用 -F 时为 63)\n"
"                    如果指定页长小于等于 10 则隐含启用 -t\n"

#: src/pr.c:2790
msgid ""
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -m, --merge       在同一行显示所有文件，每个文件占用一栏，分割行，但是当\n"
"                    使用 -J 时将行合并到完整长度\n"

#: src/pr.c:2794
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[分隔符[位数]], --number-lines[=分隔符[位数]]\n"
"\t\t\t显示行号，使用指定(默认5) 位数，后接分隔符(默认TAB)\n"
"\t\t\t默认从输入文件的第一行开始计数\n"
"  -N, --first-line-number=数字\n"
"\t\t\t从首页的首行以指定数字开始计数(参看\"+首页\")\n"

#: src/pr.c:2802
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=缩进量\n"
"\t\t\t将每行缩进(默认0)个空格，不影响-w 或-W 参数，\n"
"\t\t\t缩进亮的值将被加入页面宽度\n"
"  -r, --no-file-warnings\n"
"\t\t\t当文件无法打开时忽略警告\n"

#: src/pr.c:2809
#, fuzzy
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -"
"w.\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[CHAR], --separator[=CHAR]\n"
"\t\t\t由单个字符分隔各列，未附加-w 时默认为制表符，否则为空。\n"
"\t\t\t另外除非-w 选项被指定，否则\"-s[CHAR]\"会屏蔽三个列相关\n"
"\t\t\t的截行选项(-COLUMN|-a -COLUMN|-m)\n"

#: src/pr.c:2817
#, fuzzy
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
msgstr ""
"  -S字符串, --sep-string[=字符串]\n"
"\t\t\t使用指定的字符串分栏，不使用-S 则使用默认的制表符\n"
"\t\t\tTAB 作为分隔符，与-J 和空格一起使用(等于-S\" \")对\n"
"\t\t\t分栏选项无影响\n"
"  -t, --omit-header\t忽略页眉和页脚\n"

#: src/pr.c:2823
msgid ""
"  -t, --omit-header  omit page headers and trailers;\n"
"                     implied if PAGE_LENGTH <= 10\n"
msgstr ""
"  -t, --omit-header  省略页面头部和尾部；\n"
"                     在所指定<页长>小于等于 10 时默认启用\n"

#: src/pr.c:2827
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"\t\t\t按照输入文件中的设置忽略页眉和页脚并除去所有分页记号\n"
"  -v, --show-nonprinting\n"
"\t\t\t使用八进制反斜杠标记\n"
"  -w, --width=页面宽度\n"
"\t\t\t为多栏页面输出将设置为指定的字符数(默认72)，\n"
"\t\t\t仅当-s[char] 选项不启用时有效(即保持默认值 72)。\n"

#: src/pr.c:2837
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=页宽\n"
"\t\t\t总是将页宽设置为指定的(默认72)字符数，\n"
"\t\t\t除非-J 选项启用总是截断行，此参数与-S 或-s 冲突\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"用法： %s [选项]... [变量]...\n"
"显示指定的环境变量的值。\n"
"如果没有指定变量，则打印出所有变量的名称和值。\n"
"\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with NUL, not newline\n"
msgstr "  -0, --null     以空字符而非换行符结束每一输出行\n"

#: src/printf.c:84
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr "警告：%s：跟随在常量字符后的其它字符已被忽略"

#: src/printf.c:93
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 格式 [参数]\n"
"　或：%s 选项\n"

#: src/printf.c:98
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"按照指定格式打印参数或按照选项执行该参数：\n"
"\n"

#: src/printf.c:104
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"指定格式类似 C 中的 printf 函数，可控制输出。有效的解释序列有：\n"
"\n"
"  \\\"\t\t双引号\n"

#: src/printf.c:122
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN          字节以八进制数 NNN(1至3位数)表示\n"
"  \\xHH\t\t字节以十六进制数 HH(1至2位数)表示\n"
"  \\uHHHH\tUnicode(ISO/IEC 10646)字符以十六进制数 HHHH(4位数)表示\n"
"  \\UHHHHHHHH\tUnicode 字符以十六进制数 HHHHHHHH(8位数)表示\n"

#: src/printf.c:128
#, fuzzy
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"  %q      ARGUMENT is printed in a format that can be reused as shell "
"input,\n"
"          escaping non-printable characters with the proposed POSIX $'' "
"syntax.\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%\t\t一个 \"%\"\n"
"  %b\t\t带\"\\\"的指定的参数是禁用转义符的字符串，\n"
"          例外：八进制数的转义串采用\"\\0\"或\"\\0NNN\"的形式\n"
"\n"
"同时，所有以diouxXfeEgGcs 结尾的C 格式化说明，将首先把指定的参数转换为\n"
"合适的类型。变量的宽度将得到恰当处理。\n"

#: src/printf.c:155
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s：需要一个数值"

#: src/printf.c:157
#, c-format
msgid "%s: value not completely converted"
msgstr "%s：给定值不能完全转换"

#: src/printf.c:254 src/printf.c:281
msgid "missing hexadecimal number in escape"
msgstr "在 escape 中缺失十六进制数"

#: src/printf.c:293
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "无效的通用字符名称\\%c%0*x"

#: src/printf.c:566
#, c-format
msgid "invalid field width: %s"
msgstr "无效的域宽度：%s"

#: src/printf.c:601
#, c-format
msgid "invalid precision: %s"
msgstr "无效的精度：%s"

#: src/printf.c:628
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s：无效的转换声明"

#: src/printf.c:711
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "警告：从%s 开始已忽略超量的参数"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "F. Pinard"

#: src/ptx.c:424
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (正则表达式 %s)"

#: src/ptx.c:823
#, c-format
msgid "error: regular expression has a match of length zero: %s"
msgstr "错误：正则表达式匹配的长度为零：%s"

#: src/ptx.c:1814
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"用法：%s [选项]... [输入]... (不包括 -G 选项)\n"
"　或：%s -G [选项]... [输入 [输出]]\n"

#: src/ptx.c:1818
#, fuzzy
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr "输出一串预排的文件索引信息，包括输入文件中各单词的环境。\n"

#: src/ptx.c:1825
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
msgstr ""
"  -A, --auto-reference           输出自动生成的引用\n"
"  -G, --traditional              行为类似 System V 的“ptx”\n"

#: src/ptx.c:1829
msgid ""
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
"                                 The default is '/'\n"
msgstr ""

#: src/ptx.c:1833
#, fuzzy
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=字符串\t指定代替\"xx\"的宏名\n"
"  -O, --format=roff\t\t生成roff 格式输出\n"
"  -R, --right-side-refs\t\t将关联引用放置在右侧，不能和-w 选项叠加\n"
"  -S, --sentence-regexp=正则表达式\t用于匹配行末或句末\n"
"  -T, --format=tex\t\t生成TeX 格式输出\n"

#: src/ptx.c:1840
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=正则表达式\t使用正则表达式匹配每个关键字\n"
"  -b, --break-file=文件\t\t以文件中包含的单词为分隔字符\n"
"  -f, --ignore-case\t\t排序时合并小写字母和大写字母\n"
"  -g, --gap-size=数值\t\t指定多个输出区块间的列间隙尺寸\n"
"  -i, --ignore-file=文件\t从指定文件中读取忽略单词的列表\n"
"  -o, --only-file=文件\t\t只从指定文件中读取单词列表\n"

#: src/ptx.c:1848
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references\t\t设置每行的第一个区块为关联引用\n"
"  -t, --typeset-mode\t\t -- 此功能尚未实现 --\n"
"  -w, --width=数值\t\t每列的输出宽度，不计关联引用\n"

#: src/ptx.c:1945
#, c-format
msgid "invalid gap width: %s"
msgstr "无效的间隙宽度：%s"

#: src/ptx.c:1972
#, c-format
msgid "invalid line width: %s"
msgstr "无效的行宽：%s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"输出当前工作目录的完整名称。\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical\t\t使用环境变量中的PWD，即使其中包含符号链接\n"
"  -P, --physical\t避免所有符号链接\n"

#: src/pwd.c:68
msgid ""
"\n"
"If no option is specified, -P is assumed.\n"
msgstr ""
"\n"
"如果没有指定任何选项，则假定启用 -P。\n"

#: src/pwd.c:169
#, c-format
msgid "failed to chdir to %s"
msgstr "无法切换到目录 %s"

#: src/pwd.c:173 src/pwd.c:280 src/split.c:469
#, c-format
msgid "failed to stat %s"
msgstr "获取%s 的文件状态失败(stat)"

#: src/pwd.c:238
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "在匹配的inode %s 上找不到目录入口"

#: src/pwd.c:367
#, c-format
msgid "ignoring non-option arguments"
msgstr "忽略不是选项的参数"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/shred.c:170 src/stat.c:1691
#: src/touch.c:213
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "用法：%s [选项]... 文件...\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"输出符号链接值或权威文件名。\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize\t\t递归跟随给出文件名的所有符号链接以标准化，\n"
"\t\t\t\t除最后一个外所有组件必须存在\n"
"  -e, --canonicalize-existing\t递归跟随给出文件名的所有符号链接以标准化，\n"
"\t\t\t\t所有组件都必须存在\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet\n"
"  -s, --silent                  suppress most error messages (on by "
"default)\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    end each output line with NUL, not newline\n"
msgstr ""
"  -m, --canonicalize-missing    递归跟随给出文件名的所有符号链接以标准化，\n"
"                                但不对各组件的存在性作出要求\n"
"  -n, --no-newline              不输出末尾的新行\n"
"  -q, --quiet,\n"
"  -s, --silent                  缩减大多数的错误消息（默认启用）\n"
"  -v, --verbose                 报告错误消息\n"
"  -z, --zero                    以空字符（NUL）而非换行符结束每个输出行\n"
"\n"

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr "忽略带有多个参数时的 --no-newline 选项"

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""
"打印经过解析的绝对路径文件名；\n"
"路径各部分中除最后一部分以外其它各部分必须存在\n"
"\n"

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no path components need exist or be a "
"directory\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=DIR        print the resolved path relative to DIR\n"
"      --relative-base=DIR      print absolute paths unless paths below DIR\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   end each output line with NUL, not newline\n"
"\n"
msgstr ""

#: src/relpath.c:130
msgid "generating relative path"
msgstr "正在生成相对路径"

#: src/remove.c:273
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s：是否进入有写保护的目录%s ？"

#: src/remove.c:274
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s：是否进入目录%s? "

#. TRANSLATORS: In the next two strings the second %s is
#. replaced by the type of the file.  To avoid grammatical
#. problems, it may be more convenient to translate these
#. strings instead as: "%1$s: %3$s is write-protected and
#. is of type '%2$s' -- remove it? ".
#: src/remove.c:291
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s：是否删除有写保护的%s %s？"

#: src/remove.c:292
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s：是否删除%s %s？"

#: src/remove.c:375
#, c-format
msgid "removed directory %s\n"
msgstr "已删除目录 %s\n"

#: src/remove.c:447
#, c-format
msgid "refusing to remove %s or %s directory: skipping %s"
msgstr "拒绝删除 %s 或 %s 目录：跳过 %s"

#: src/remove.c:476
#, c-format
msgid "failed to stat %s: skipping %s"
msgstr "获取 %s 的文件状态失败(stat)：跳过 %s"

#: src/remove.c:489 src/remove.c:539
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "跳过 %s，因为它位于不同的设备上"

#: src/remove.c:491
#, c-format
msgid "and --preserve-root=all is in effect"
msgstr "且 --preserve-root=all 正在生效"

#: src/remove.c:559
#, c-format
msgid "traversal failed: %s"
msgstr "遍历失败：%s"

#: src/remove.c:565
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"异常错误：fts_info=%d: %s\n"
"请报告给 %s"

#: src/rm.c:117
#, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr "尝试使用\"%s ./%s\"删除文件 %s。\n"

#: src/rm.c:134
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"删除（unlink）指定<文件>。\n"
"\n"
"  -f, --force          强制删除。忽略不存在的文件，不提示确认\n"
"  -i                    每次删除前提示确认\n"

#: src/rm.c:140
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively; less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i); without WHEN, prompt always\n"
msgstr ""
"  -I                    在删除超过三个文件或者递归删除前提示一次并要求确"
"认；\n"
"                          此选项比 -i 提示内容更少，但同样可以阻止大多数\n"
"                          错误发生\n"
"      --interactive[=场景]  根据指定的<场景>进行确认提示：never（从不）、\n"
"                            once（一次，等效于使用 -I）或者 always（总是，\n"
"                            等效于使用 -i）。如果使用此参数没有指定<场景>则\n"
"                            总是提示\n"

#: src/rm.c:147
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system\t\t递归删除一个层级时，跳过所有不符合命令行参\n"
"\t\t\t\t数的文件系统上的文件\n"

#: src/rm.c:152
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root[=all]  do not remove '/' (default);\n"
"                              with 'all', reject any command line argument\n"
"                              on a separate device from its parent\n"
msgstr ""
"      --no-preserve-root  不要对“/”特殊处理\n"
"      --preserve-root[=all]  不要删除“/”（默认行为）；\n"
"                              如添加了“all”参数，将拒绝处理与父目录位于\n"
"                              不同设备上的命令行参数\n"

#: src/rm.c:158
msgid ""
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"  -r, -R, --recursive   递归删除目录及其内容\n"
"  -d, --dir             删除空目录\n"
"  -v, --verbose         详细显示进行的步骤\n"

#: src/rm.c:165
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"默认时，rm 不会删除目录。使用--recursive(-r 或-R)选项可删除每个给定\n"
"的目录，以及其下所有的内容。\n"

#: src/rm.c:170
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"要删除文件名第一个字符为“-”的文件（例如“-foo”），请使用\n"
"以下方法之一：\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"

#: src/rm.c:179
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"请注意，如果使用rm 来删除文件，通常仍可以将该文件恢复原状。如果想保证\n"
"该文件的内容无法还原，请考虑使用shred。\n"

#: src/rm.c:297
msgid "you may not abbreviate the --no-preserve-root option"
msgstr "您不能使用缩写的 --no-preserve-root 选项"

#: src/rm.c:309
#, c-format
msgid "unrecognized --preserve-root argument: %s"
msgstr "无法识别的 --preserve-root 参数：%s"

#: src/rm.c:359
#, c-format
msgid "%s: remove %<PRIuMAX> argument recursively? "
msgid_plural "%s: remove %<PRIuMAX> arguments recursively? "
msgstr[0] "%s：递归删除 %<PRIuMAX> 个参数？"

#: src/rm.c:362
#, c-format
msgid "%s: remove %<PRIuMAX> argument? "
msgid_plural "%s: remove %<PRIuMAX> arguments? "
msgstr[0] "%s：删除 %<PRIuMAX> 个参数？"

#: src/rmdir.c:133 src/rmdir.c:233
#, c-format
msgid "removing directory, %s"
msgstr "正在删除目录，%s"

#: src/rmdir.c:148
#, c-format
msgid "failed to remove directory %s"
msgstr "删除目录 %s 失败"

#: src/rmdir.c:165
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"删除指定的空目录。\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  忽略仅由目录非空产生的所有错误\n"

#: src/rmdir.c:172
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' "
"is\n"
"                    similar to 'rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   删除指定目录及其各个上级文件夹，例如“rmdir -p a/b/c'”\n"
"                    与“rmdir a/b/c a/b a'”类似\n"
"  -v, --verbose   输出每个被处理目录的详情和诊断信息\n"

#: src/rmdir.c:243
#, c-format
msgid "failed to remove %s"
msgstr "删除 %s 失败"

#: src/runcon.c:78
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"用法: %s 上下文 命令 [参数]\n"
"　或: %s [ -c ] [-u 用户] [-r 角色] [-t 类型] [-l 范围] 命令 [参数]\n"

#: src/runcon.c:82
msgid ""
"Run a program in a different SELinux security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""
"在不同的 SELinux 安全上下文中运行程序。\n"
"若未指定上下文和命令，输出当前安全上下文。\n"

#: src/runcon.c:89
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""
"  上下文            完整的安全上下文描述\n"
"  -c, --compute      在更改前计算环境变化\n"
"  -t, --type=类型    类型（与父进程角色相同）\n"
"  -u, --user=用户    用户身份\n"
"  -r, --role=角色    角色\n"
"  -l, --range=范围  级别范围\n"
"\n"

#: src/runcon.c:139
msgid "multiple roles"
msgstr "多角色"

#: src/runcon.c:144
msgid "multiple types"
msgstr "多类型"

#: src/runcon.c:149
msgid "multiple users"
msgstr "多用户"

#: src/runcon.c:154
msgid "multiple levelranges"
msgstr "复合级别范围"

#: src/runcon.c:172 src/runcon.c:208
msgid "failed to get current context"
msgstr "无法获得当前上下文"

#: src/runcon.c:182
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "您必须指定-c，-t，-u，-l，-r 或上下文"

#: src/runcon.c:190
#, c-format
msgid "no command specified"
msgstr "没有指定命令"

#: src/runcon.c:195
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "%s 只能用于启用了 SELinux 支持的内核"

#: src/runcon.c:222
msgid "failed to compute a new context"
msgstr "计算新的上下文失败"

#: src/runcon.c:236
#, c-format
msgid "failed to set new user: %s"
msgstr "设置新用户失败：%s"

#: src/runcon.c:239
#, c-format
msgid "failed to set new type: %s"
msgstr "设置新类型失败：%s"

#: src/runcon.c:242
#, c-format
msgid "failed to set new range: %s"
msgstr "设置新范围失败：%s"

#: src/runcon.c:245
#, c-format
msgid "failed to set new role: %s"
msgstr "设置新角色失败：%s"

#: src/runcon.c:254
#, c-format
msgid "unable to set security context %s"
msgstr "无法设置安全上下文 %s"

#: src/seq.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"用法：%s [选项]... 尾数\n"
"　或：%s [选项]... 首数 尾数\n"
"　或：%s [选项]... 首数 增量 尾数\n"

#: src/seq.c:85
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr "从给定首数到尾数依次进行打印，每两个数字之间的增量等于给定增量。\n"

#: src/seq.c:91
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"  -f, --format=格式        使用 printf 样式的浮点格式\n"
"  -s, --separator=字符串   使用指定<字符串>分隔数字（默认使用：\\n）\n"
"  -w, --equal-width        在列前添加 0 使得宽度相同\n"

#: src/seq.c:98
#, fuzzy
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"
msgstr ""
"\n"
"如果省略了首数或者增量，则默认其值为1，即使这样尾数仍小于首数。\n"
"首数、增量和尾数均以浮点数形式解释。当首数小于尾数时增量一般为正值，\n"
"相反在首数大于尾数时增量一般为负数。\n"

#: src/seq.c:109
#, fuzzy
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"指定的格式必须适用于显示\"double\"类型的参数；当首数、增量和尾数均为指定\n"
"精确度的定点十进制数时默认为\"%.精确度f\"，否则默认为\"%g\"。\n"

#: src/seq.c:155
#, c-format
msgid "invalid floating point argument: %s"
msgstr "无效的浮点参数：%s"

#: src/seq.c:161
#, c-format
msgid "invalid %s argument: %s"
msgstr "无效的 %s 参数：%s"

#: src/seq.c:268
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "格式%s 中包含未知%%%c 指令"

#: src/seq.c:648
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr "当输出等宽字符串时不应再指定格式字符串"

#: src/seq.c:693
#, fuzzy, c-format
msgid "invalid Zero increment value: %s"
msgstr "无效的行号递增值：%s"

#: src/set-fields.c:167
msgid "invalid byte or character range"
msgstr "无效的字节或自负范围"

#: src/set-fields.c:168
msgid "invalid field range"
msgstr "无效的字段范围"

#: src/set-fields.c:175 src/set-fields.c:221
msgid "byte/character positions are numbered from 1"
msgstr "字节/字符位置从 1 开始计数"

#: src/set-fields.c:176 src/set-fields.c:222
msgid "fields are numbered from 1"
msgstr "序号从 1 开始计数"

#: src/set-fields.c:196
msgid "invalid range with no endpoint: -"
msgstr "无终点的无效的范围：-"

#: src/set-fields.c:210
msgid "invalid decreasing range"
msgstr "无效的缩小的范围"

#: src/set-fields.c:259
#, c-format
msgid "byte/character offset %s is too large"
msgstr "字节/字符偏移量 %s 过大"

#: src/set-fields.c:260
#, c-format
msgid "field number %s is too large"
msgstr "域编号%s 过大"

#: src/set-fields.c:271
#, c-format
msgid "invalid byte/character position %s"
msgstr "无效的字节/字符位置 %s"

#: src/set-fields.c:272
#, c-format
msgid "invalid field value %s"
msgstr "无效的字段值 %s"

#: src/set-fields.c:280
msgid "missing list of byte/character positions"
msgstr "缺少字节/字符位置列表"

#: src/set-fields.c:281
msgid "missing list of fields"
msgstr "缺少域列表"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:171
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr "多次覆盖指定文件，使得即使是昂贵的硬件探测仪器也难以将数据复原。\n"

#: src/shred.c:175
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
msgstr ""
"\n"
"如果指定<文件>是 -，则对标准输出进行 shred 操作。\n"

#: src/shred.c:182
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force\t\t必要时修改权限以使目标可写\n"
"  -n, --iterations=N\t覆盖N 次，而非使用默认的%d 次\n"
"      --random-source=文件\t从指定文件中取出随机字节\n"
"  -s, --size=N\t\t粉碎数据为指定字节的碎片(可使用K、M 和G 作为单位)\n"

#: src/shred.c:188
#, fuzzy
msgid ""
"  -u             deallocate and remove file after overwriting\n"
"      --remove[=HOW]  like -u but give control on HOW to delete;  See below\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u, --remove\t\t覆盖后截断并删除文件\n"
"  -v, --verbose\t\t显示详细信息\n"
"  -x, --exact\t\t不将文件大小增加至最接近的块大小\n"
"  -z, --zero \t\t最后一次使用0 进行覆盖以隐藏覆盖动作\n"

#: src/shred.c:198
#, fuzzy
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.\n"
"The optional HOW parameter indicates how to remove a directory entry:\n"
"'unlink' => use a standard unlink call.\n"
"'wipe' => also first obfuscate bytes in the name.\n"
"'wipesync' => also sync each obfuscated byte to disk.\n"
"The default mode is 'wipesync', but note it can be expensive.\n"
"\n"
msgstr ""
"\n"
"如果指定文件为\"-\"，粉碎标准输出的数据。\n"
"\n"
"如果加上--remove (-u)选项表示删除文件。默认的方式是不删除文件，因为\n"
"覆盖像/dev/hda 等的设备文件是很普遍的，而这些文件通常不应删除。当覆盖\n"
"一般文件时，绝大多数人都会使用--remove 选项。\n"
"\n"

#: src/shred.c:210
msgid ""
"CAUTION: shred assumes the file system and hardware overwrite data in "
"place.\n"
"Although this is common, many platforms operate otherwise.  Also, backups\n"
"and mirrors may contain unremovable copies that will let a shredded file\n"
"be recovered later.  See the GNU coreutils manual for details.\n"
msgstr ""

#: src/shred.c:310
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s：fadatsync 失败"

#: src/shred.c:321
#, c-format
msgid "%s: fsync failed"
msgstr "%s：fsync 失败"

#: src/shred.c:438
#, c-format
msgid "%s: cannot rewind"
msgstr "%s：无法反绕操作"

#: src/shred.c:458
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s：第%lu 次，共%lu 次 (%s)..."

#: src/shred.c:509
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s：在位置%s 写入时出现错误"

#: src/shred.c:530
#, c-format
msgid "%s: lseek failed"
msgstr "%s：lseek 失败"

#: src/shred.c:542
#, c-format
msgid "%s: file too large"
msgstr "%s：文件过大"

#: src/shred.c:566
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s：第%lu 次，共%lu 次 (%s)...%s"

#: src/shred.c:582
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s：第%lu 次，共%lu 次 (%s)...%s/%s %d%%"

#: src/shred.c:840
#, c-format
msgid "%s: fstat failed"
msgstr "%s：获取文件状态失败(fstat)"

#: src/shred.c:851
#, c-format
msgid "%s: invalid file type"
msgstr "%s：无效的文件类型"

#: src/shred.c:856
#, c-format
msgid "%s: file has negative size"
msgstr "%s：文件的大小为负数"

#: src/shred.c:952 src/sort.c:972 src/split.c:475
#, c-format
msgid "%s: error truncating"
msgstr "%s：截断文件时出错"

#: src/shred.c:971
#, c-format
msgid "%s: fcntl failed"
msgstr "%s：文件控制操作失败(fcntl)"

#: src/shred.c:976
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s：不能对只可追加数据的文件描述符(file descriptor) 进行粉碎"

#: src/shred.c:1059
#, c-format
msgid "%s: removing"
msgstr "%s：正在删除"

#: src/shred.c:1084
#, c-format
msgid "%s: renamed to %s"
msgstr "%s：名称已更改为 %s"

#: src/shred.c:1093
#, c-format
msgid "%s: failed to remove"
msgstr "%s：删除失败"

#: src/shred.c:1097
#, c-format
msgid "%s: removed"
msgstr "%s：已删除"

#: src/shred.c:1104 src/shred.c:1147
#, c-format
msgid "%s: failed to close"
msgstr "%s：无法关闭"

#: src/shred.c:1140
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s：无法以写模式打开"

#: src/shred.c:1203
msgid "invalid number of passes"
msgstr "覆盖次数无效"

#: src/shred.c:1208 src/shuf.c:462 src/sort.c:4508
msgid "multiple random sources specified"
msgstr "指定了多个随机源"

#: src/shred.c:1222
msgid "invalid file size"
msgstr "无效的文件大小"

#: src/shuf.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"用法： %s [选项]... [文件]\n"
"　或者:  %s -e [选项]... [参数]...\n"
"　或者:  %s -i LO-HI [选项]...\n"

#: src/shuf.c:68
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr "把输入行按随机顺序输出到标准输出。\n"

#: src/shuf.c:75
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -r, --repeat              output lines can be repeated\n"
msgstr ""
"  -e, --echo                将每个参数视为输入行\n"
"  -i, --input-range=LO-HI   将 LO 到 HI 的每个数字视为输入行\n"
"  -n, --head-count=行数     最多输出指定的行数\n"
"  -o, --output=文件         将结果输出到指定文件而非标准输出\n"
"      --random-source=文件  从指定文件获得随机字节\n"
"  -r, --repeat              输出行可以重复\n"
"\n"

#: src/shuf.c:226
msgid "too many input lines"
msgstr "输入行过多"

#: src/shuf.c:418
msgid "multiple -i options specified"
msgstr "指定了多个 -i 选项"

#: src/shuf.c:425 src/shuf.c:431 src/shuf.c:436
msgid "invalid input range"
msgstr "无效的输入范围"

#: src/shuf.c:449
#, c-format
msgid "invalid line count: %s"
msgstr "无效的行数：%s"

#: src/shuf.c:456 src/sort.c:4502
msgid "multiple output files specified"
msgstr "指定了多个输出文件"

#: src/shuf.c:486
#, c-format
msgid "cannot combine -e and -i options"
msgstr "不能同时指定-e 和-i 选项"

#: src/shuf.c:575
msgid "no lines to repeat"
msgstr "没有可重复的行"

#: src/sleep.c:44
#, fuzzy, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  NUMBER need not be an\n"
"integer.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"用法：%s 数字[时间单位]...\n"
"　或：%s 选项\n"
"暂停指定的秒数。时间单位可以是s 表示秒(默认设置)，m 表示分钟，\n"
"h 表示小时，d 表示天。 指定数字可以是一个整数，也可以是浮点数。\n"
"如果参数个数超过2 个，暂停的总时间为各个参数的值的和。\n"
"\n"

#: src/sleep.c:132 src/timeout.c:332
#, c-format
msgid "invalid time interval %s"
msgstr "无效的时间间隔%s"

#: src/sleep.c:143 src/tail.c:1311
msgid "cannot read realtime clock"
msgstr "无法读取实时时钟"

#: src/sort.c:420
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr "串联排序所有指定文件并将结果写到标准输出。\n"

#: src/sort.c:427
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"排序选项：\n"
"\n"

#: src/sort.c:431
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks\t忽略前导的空白区域\n"
"  -d, --dictionary-order\t只考虑空白区域和字母字符\n"
"  -f, --ignore-case\t\t忽略字母大小写\n"

#: src/sort.c:437
#, fuzzy
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""
"  -g, --general-numeric-sort\t按照常规数值排序\n"
"  -i, --ignore-nonprinting\t只排序可打印字符\n"
"  -M, --month-sort\t\t比较 (未知) < \"一月\" < ... < \"十二月\"\n"
"\t\t\t\t在LC_ALL=C 时为(unknown) < `JAN' < ... < `DEC'\n"

#: src/sort.c:442
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr "  -h, --human-numeric-sort    使用易读性数字(例如： 2K 1G)\n"

#: src/sort.c:445
#, fuzzy
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           shuffle, but group identical keys.  See "
"shuf(1)\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort\t\t根据字符串数值比较\n"
"  -R, --random-sort\t\t根据随机hash 排序\n"
"      --random-source=文件\t从指定文件中获得随机字节\n"
"  -r, --reverse\t\t\t逆序输出排序结果\n"

#: src/sort.c:451
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=WORD\t\t按照WORD 指定的格式排序：\n"
"\t\t\t\t\t一般数字-g，高可读性-h，月份-M，数字-n，\n"
"\t\t\t\t\t随机-R，版本-V\n"
"  -V, --version-sort\t\t在文本内进行自然版本排序\n"
"\n"

#: src/sort.c:459
msgid ""
"Other options:\n"
"\n"
msgstr ""
"其他选项：\n"
"\n"

#: src/sort.c:463
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=NMERGE\t一次最多合并NMERGE 个输入；如果输入更多\n"
"\t\t\t\t\t则使用临时文件\n"

#: src/sort.c:467
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first\t检查输入是否已排序，若已有序则不进行操"
"作\n"
"  -C, --check=quiet, --check=silent\t类似-c，但不报告第一个无序行\n"
"      --compress-program=程序\t使用指定程序压缩临时文件；使用该程序\n"
"\t\t\t\t\t的-d 参数解压缩文件\n"

#: src/sort.c:474
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug\t\t\t为用于排序的行添加注释，并将有可能有问题的\n"
"\t\t\t\t\t用法输出到标准错误输出\n"
"      --files0-from=文件\t从指定文件读取以NUL 终止的名称，如果该文件被\n"
"\t\t\t\t\t指定为\"-\"则从标准输入读文件名\n"

#: src/sort.c:481
#, fuzzy
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=位置1[,位置2]\t在位置1 开始一个key，在位置2 终止(默认为行尾)\n"
"\t\t\t\t参看POS 语法。\n"
"  -m, --merge\t\t\t合并已排序的文件，不再进行排序\n"

#: src/sort.c:485
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=文件\t\t将结果写入到文件而非标准输出\n"
"  -s, --stable\t\t\t禁用last-resort 比较以稳定比较算法\n"
"  -S, --buffer-size=大小\t指定主内存缓存大小\n"

#: src/sort.c:491
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=分隔符\t使用指定的分隔符代替非空格到空格的转换\n"
"  -T, --temporary-directory=目录\t使用指定目录而非$TMPDIR 或%s 作为\n"
"\t\t\t\t\t临时目录，可用多个选项指定多个目录\n"
"      --parallel=N\t\t将同时运行的排序数改变为N\n"
"  -u, --unique\t\t配合-c，严格校验排序；不配合-c，则只输出一次排序结果\n"

#: src/sort.c:505
#, fuzzy
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"POS 是F[.C][OPTS]，F 代表域编号，C 是域中字母的位置，F 和C 均从1开始计数\n"
"如果没有有效的-t 或-b 选项存在，则从前导空格后开始计数字符。OPTS 是一个或多"
"个\n"
"由单个字母表示的顺序选项，以此覆盖此key 的全局顺序设置。如果没有指定key 则\n"
"将其整个行。\n"
"\n"
"指定的大小可以使用以下单位之一：\n"

#: src/sort.c:518
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"内存使用率% 1%，b 1、K 1024（默认），M、G、T、P、E、Z、Y 等依此类推。\n"
"\n"
"*** 警告 ***\n"
"地区与语言环境变量（locale）会影响排序结果。\n"
"如果希望以字节的自然值获得最传统的排序结果，\n"
"请设置环境变量 LC_ALL=C。\n"

#: src/sort.c:716
#, c-format
msgid "waiting for %s [-d]"
msgstr "等待 %s [-d]"

#: src/sort.c:721
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] 不正常结束"

#: src/sort.c:876
#, c-format
msgid "cannot create temporary file in %s"
msgstr "无法在%s 创建临时文件"

#: src/sort.c:991 src/sort.c:2100 src/sort.c:3137 src/sort.c:3780
#: src/sort.c:3871 src/sort.c:3874
msgid "open failed"
msgstr "打开失败"

#: src/sort.c:1011
msgid "fflush failed"
msgstr "冲洗流失败(fflush)"

#: src/sort.c:1016 src/sort.c:2103 src/sort.c:4778
msgid "close failed"
msgstr "关闭失败"

#: src/sort.c:1155
msgid "couldn't create temporary file"
msgstr "无法创建临时文件"

#: src/sort.c:1194
#, c-format
msgid "couldn't create process for %s -d"
msgstr "无法创建进程%s -d"

#: src/sort.c:1267
#, c-format
msgid "warning: cannot remove: %s"
msgstr "警告：无法删除：%s"

#: src/sort.c:1353
#, c-format
msgid "invalid --%s argument %s"
msgstr "无效的 --%s 参数%s"

#: src/sort.c:1356
#, c-format
msgid "minimum --%s argument is %s"
msgstr "最小 --%s 参数是%s"

#: src/sort.c:1371
#, c-format
msgid "--%s argument %s too large"
msgstr "--%s 参数%s 太长"

#: src/sort.c:1374
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "最大 --%s 参数在当前资源限制(rlimit)设置下是%s"

#: src/sort.c:1456
msgid "number in parallel must be nonzero"
msgstr "单个的数字必须不为零"

#: src/sort.c:1539
msgid "stat failed"
msgstr "获取文件状态失败(stat)"

#: src/sort.c:1801
msgid "read failed"
msgstr "读取失败"

#: src/sort.c:2118
#, c-format
msgid "string transformation failed"
msgstr "字符串转换失败"

#: src/sort.c:2121
#, c-format
msgid "the untransformed string was %s"
msgstr "未转换的字符串为%s"

#: src/sort.c:2284
#, c-format
msgid "^ no match for key\n"
msgstr "^ 没有匹配项\n"

#: src/sort.c:2456
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr "使用了旧的值 %s；考虑转为使用 %s"

#: src/sort.c:2463
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "值 %lu 宽度为零，忽略"

#: src/sort.c:2472
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr "值 %lu 开头有大量空格，考虑同时指定\"b\""

#: src/sort.c:2485
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "值%lu 为数字且跨多个域"

#: src/sort.c:2517
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] "选项\"-%s\"被忽略"

#: src/sort.c:2523
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr "选项 '-r' 仅用于 last-resort 比较"

#: src/sort.c:2797 src/sort.c:2806
msgid "write failed"
msgstr "写入失败"

#: src/sort.c:2849
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s：%s:%s：无序： "

#: src/sort.c:2852
msgid "standard error"
msgstr "标准错误"

#: src/sort.c:3764
msgid "cannot read"
msgstr "无法读取"

#: src/sort.c:4043
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s：无效的区块规格%s"

#: src/sort.c:4053
#, c-format
msgid "options '-%s' are incompatible"
msgstr "选项\"-%s\"不兼容"

#: src/sort.c:4103
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s：在%s 处的计数无效"

#: src/sort.c:4362
msgid "invalid number after '-'"
msgstr "在\"-\"后的编号无效"

#: src/sort.c:4369 src/sort.c:4455 src/sort.c:4483
msgid "invalid number after '.'"
msgstr "在\".\"后的编号无效"

#: src/sort.c:4382 src/sort.c:4488
msgid "stray character in field spec"
msgstr "区块中有孤立字符"

#: src/sort.c:4429
msgid "multiple compress programs specified"
msgstr "指定了多个压缩程序"

#: src/sort.c:4446
msgid "invalid number at field start"
msgstr "区块起始处的编号无效"

#: src/sort.c:4450 src/sort.c:4478
msgid "field number is zero"
msgstr "区块编号为零"

#: src/sort.c:4459
msgid "character offset is zero"
msgstr "字符偏移量为零"

#: src/sort.c:4474
msgid "invalid number after ','"
msgstr "在\",\"后的编号无效"

#: src/sort.c:4524
msgid "empty tab"
msgstr "空标签"

#: src/sort.c:4607 src/wc.c:784
#, c-format
msgid "cannot read file names from %s"
msgstr "无法从%s 中读取文件名"

#: src/sort.c:4629
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s：%lu：无效的 0 长度文件名"

#: src/sort.c:4635
#, c-format
msgid "no input from %s"
msgstr "没有来自 %s 的输入"

#: src/sort.c:4688
#, c-format
msgid "text ordering performed using %s sorting rules"
msgstr "使用 %s 排序规则进行了文字排序"

#: src/sort.c:4692
msgid "text ordering performed using simple byte comparison"
msgstr "使用简单字节比较进行了文字排序"

#: src/sort.c:4724
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "不允许额外的操作数%s 与-%c 一起使用"

#: src/split.c:209
#, c-format
msgid "the suffix length needs to be at least %<PRIuMAX>"
msgstr "后缀长度至少应为 %<PRIuMAX>"

#: src/split.c:226
#, c-format
msgid "Usage: %s [OPTION]... [FILE [PREFIX]]\n"
msgstr "用法：%s [选项]... [文件 [前缀]]\n"

#: src/split.c:230
msgid ""
"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n"
"default size is 1000 lines, and default PREFIX is 'x'.\n"
msgstr ""
"将文件拆分并输出为“前缀aa”、“前缀ab”等等文件；\n"
"默认以 1000 行为拆分单位，默认前缀为“x”。\n"

#: src/split.c:238
#, fuzzy, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n"
"  -d                      use numeric suffixes starting at 0, not "
"alphabetic\n"
"      --numeric-suffixes[=FROM]  same as -d, but allow setting the start "
"value\n"
"  -x                      use hex suffixes starting at 0, not alphabetic\n"
"      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines/records per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files; see explanation "
"below\n"
"  -t, --separator=SEP     use SEP instead of newline as the record "
"separator;\n"
"                            '\\0' (zero) specifies the NUL character\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""
"  -a, --suffix-length=N\t指定后缀长度为N (默认为%d)\n"
"  -b, --bytes=大小\t\t指定每个输出文件的字节大小\n"
"  -C, --line-bytes=大小\t指定每个输出文件里最大行字节大小\n"
"  -d, --numeric-suffixes \t使用数字后缀代替字母后缀\n"
"  -e, --elide-empty-files\t和-n 一起使用时不生成空的输出文件\n"
"  -l, --lines=数值\t\t指定每个输出文件有多少行\n"
"  -n, --number=块数\t\t生成块数输出文件。参看下面的说明。\n"
"  -u, --unbuffered\t\t立即使用-n r/... 复制输入到输出\n"

#: src/split.c:256
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr "      --verbose\t\t在每个输出文件打开前输出文件特征\n"

#: src/split.c:263
#, fuzzy
msgid ""
"\n"
"CHUNKS may be:\n"
"  N       split into N files based on size of input\n"
"  K/N     output Kth of N to stdout\n"
"  l/N     split into N files without splitting lines/records\n"
"  l/K/N   output Kth of N to stdout without splitting lines/records\n"
"  r/N     like 'l' but use round robin distribution\n"
"  r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"块数可能为：\n"
"N\t基于输入的大小分割为N 个文件\n"
"K/N\t将N 个文件中的第K 个输出到标准输出\n"
"l/N\t分割为N 个文件，但分割时不切断行\n"
"l/K/N\t将N 个文件中的第K 个输出到标准输出，但分割时不切断行\n"
"r/N\t类似l 但使用轮询分配\n"
"r/K/N\t类似r/N 但尽将N 个文件中的第K 个输出到标准输出\n"

#: src/split.c:450
msgid "output file suffixes exhausted"
msgstr "已排除输出文件后缀"

#: src/split.c:462
#, c-format
msgid "creating file %s\n"
msgstr "正在创建文件 %s\n"

#: src/split.c:471
#, c-format
msgid "%s would overwrite input; aborting"
msgstr "%s 将会覆写输入；中止"

#: src/split.c:488
msgid "failed to set FILE environment variable"
msgstr "设置 FILE 环境变量失败"

#: src/split.c:490
#, c-format
msgid "executing with FILE=%s\n"
msgstr "正在带 FILE=%s 执行\n"

#: src/split.c:492
msgid "failed to create pipe"
msgstr "创建管道失败"

#: src/split.c:506
msgid "closing prior pipe"
msgstr "正在关闭先前的管道"

#: src/split.c:508
msgid "closing output pipe"
msgstr "正在关闭输出管道"

#: src/split.c:512
msgid "moving input pipe"
msgstr "正在移动输入管道"

#: src/split.c:514
msgid "closing input pipe"
msgstr "正在关闭输入管道"

#: src/split.c:519
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "运行命令失败：“%s -c %s”"

#: src/split.c:525
msgid "failed to close input pipe"
msgstr "关闭输入管道失败"

#: src/split.c:561
msgid "waiting for child process"
msgstr "正在等待子进程"

#: src/split.c:571
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr "带 FILE=%s，信号 %s 来自命令：%s"

#: src/split.c:579
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr "带 FILE=%s，退出状态 %d 来自命令：%s"

#: src/split.c:586
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "来自命令的未知状态 (0x%X)"

#: src/split.c:1274
#, c-format
msgid "cannot split in more than one way"
msgstr "无法以多于一种的方式切分输入"

#: src/split.c:1286 src/split.c:1401 src/split.c:1602
msgid "invalid number of chunks"
msgstr "无效的块数"

#: src/split.c:1291
msgid "invalid chunk number"
msgstr "无效块数"

#: src/split.c:1338
msgid "invalid suffix length"
msgstr "无效的后缀长度"

#: src/split.c:1412
msgid "empty record separator"
msgstr "空的记录分隔符"

#: src/split.c:1423
#, c-format
msgid "multi-character separator %s"
msgstr "多字符分隔符 %s"

#: src/split.c:1431
msgid "multiple separator characters specified"
msgstr "指定了多个分隔用字符"

#: src/split.c:1462
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "行数选项-%s%c... 过大"

#: src/split.c:1479
#, fuzzy, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr "无效的起始行号：%s"

#: src/split.c:1480
#, fuzzy, c-format
msgid "%s: invalid start value for hexadecimal suffix"
msgstr "无效的起始行号：%s"

#: src/split.c:1504
msgid "invalid IO block size"
msgstr "无效的 IO 块大小"

#: src/split.c:1522
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr ""

#: src/split.c:1562
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr ""

#: src/split.c:1594
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s：无法确定文件大小"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:197
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:989
#, c-format
msgid "failed to canonicalize %s"
msgstr "标准化%s 失败"

#: src/stat.c:1092
#, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "警告：无法识别的转义字符“\\%c”"

#: src/stat.c:1153
#, c-format
msgid "%s: invalid directive"
msgstr "%s：无效指令"

#: src/stat.c:1200
#, c-format
msgid "warning: backslash at end of format"
msgstr "警告：格式末尾出现反斜杠"

#: src/stat.c:1231
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr "用 %s 进行标准输入在文件系统模式下无法工作"

#: src/stat.c:1238
#, c-format
msgid "cannot read file system information for %s"
msgstr "无法为 %s 读取文件系统信息"

#: src/stat.c:1362 src/stat.c:1429
#, c-format
msgid "cannot stat standard input"
msgstr "无法从标准输入获取文件信息(stat)"

#: src/stat.c:1364
#, fuzzy, c-format
msgid "cannot statx %s"
msgstr "无法获取%s 的文件状态(stat)"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1608
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  文件：\"%n\"\n"
"    ID：%-8i 文件名长度：%-7l 类型：%T\n"
"块大小：%-10s 基本块大小：%S\n"
"    块：总计：%-10b 空闲：%-10f 可用：%a\n"
"Inodes: 总计：%-10c 空闲：%d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1629
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  文件：%N\n"
"  大小：%-10s\t块：%-10b IO 块：%-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1639
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr "设备：%Dh/%dd\tInode：%-10i  硬链接：%-5h 设备类型：%t,%T\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1647
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr "设备：%Dh/%dd\tInode：%-10i  硬链接：%h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1656
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "权限：(%04a/%10.10A)  Uid：(%5u/%8U)   Gid：(%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1666
#, c-format
msgid "Context: %C\n"
msgstr "环境：%C\n"

#: src/stat.c:1674
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"最近访问：%x\n"
"最近更改：%y\n"
"最近改动：%z\n"
"创建时间：%w\n"

#: src/stat.c:1692
msgid "Display file or file system status.\n"
msgstr "显示文件或文件系统的状态。\n"

#: src/stat.c:1698
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"  -L, --dereference     跟随链接\n"
"  -f, --file-system     显示文件系统状态而非文件状态\n"

#: src/stat.c:1702
msgid ""
"      --cached=MODE     specify how to use cached attributes;\n"
"                          useful on remote file systems. See MODE below\n"
msgstr ""

#: src/stat.c:1706
#, fuzzy
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline;\n"
"                          if you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c --format=格式\t使用指定输出格式代替默认值，每用一次指定格式换一新行\n"
"      --printf=格式\t类似 --format，但是会解释反斜杠转义符，不使用换行作\n"
"\t\t\t\t输出结尾。如果您仍希望使用换行，可以在格式中\n"
"\t\t\t\t加入\"\\n\"\n"
"  -t, --terse\t\t使用简洁格式输出\n"

#: src/stat.c:1717
msgid ""
"\n"
"The --cached MODE argument can be; always, never, or default.\n"
"`always` will use cached attributes if available, while\n"
"`never` will try to synchronize with the latest attributes, and\n"
"`default` will leave it up to the underlying file system.\n"
msgstr ""

#: src/stat.c:1724
#, fuzzy
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   permission bits in octal (note '#' and '0' printf flags)\n"
"  %A   permission bits and file type in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"有效的文件格式序列(不使用 --file-system)：\n"
"\n"
"  %a\t八进制权限\n"
"  %A   用可读性较好的方式输出权限\n"
"  %b   计算已分配块数(参见%B)\n"
"  %B   以字节为单位输出%b 所报告的每个块的大小\n"
"  %C   SELinux 安全上下文字符串\n"

#: src/stat.c:1733
#, fuzzy
msgid ""
"  %d   device number in decimal\n"
"  %D   device number in hex\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""
"  %d\t十进制设备编号\n"
"  %D\t十六进制设备编号\n"
"  %f\t十六进制原始模式\n"
"  %F\t文件类型\n"
"  %g\t文件的属组ID\n"
"  %G\t文件的属组组名\n"

#: src/stat.c:1741
#, fuzzy
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %t   major device type in hex, for character/block device special files\n"
"  %T   minor device type in hex, for character/block device special files\n"
msgstr ""
"  %h\t硬链接数量\n"
"  %i\tInode 编号\n"
"  %m\t挂载点\n"
"  %n\t文件名\n"
"  %N\t如果对象是一个符号链接，显示引用到的其它文件名\n"
"  %o\tI/O 块大小\n"
"  %s\t总计大小，以字节为单位\n"
"  %t\t十六进制主设备类型\n"
"  %T\t十六进制子设备类型\n"

#: src/stat.c:1752
#, fuzzy
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last data modification, human-readable\n"
"  %Y   time of last data modification, seconds since Epoch\n"
"  %z   time of last status change, human-readable\n"
"  %Z   time of last status change, seconds since Epoch\n"
"\n"
msgstr ""
"  %u\t文件的属主ID\n"
"  %U\t文件的属主用户名\n"
"  %w\t文件创建时间，若未知则显示\"-\"\n"
"  %W\t从UNIX 元年起以秒计的文件创建时间，若未知则显示\"-\"\n"
"  %x\t上次访问时间\n"
"  %X\t从UNIX 元年起以秒计的上次访问时间\n"
"  %y\t上次修改时间\n"
"  %Y\t从UNIX 元年起以秒计的上次修改时间\n"
"  %z\t上次更改时间\n"
"  %Z\t从UNIX 元年起以秒计的上次更改时间\n"
"\n"

#: src/stat.c:1766
#, fuzzy
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""
"有效的文件系统格式序列：\n"
"\n"
"  %a\t非超级用户可用的剩余块数\n"
"  %b\t文件系统的总数据块数\n"
"  %c\t文件系统中文件节点总数\n"
"  %d\t文件系统中空闲文件节点数\n"
"  %f\t文件系统中空闲块数\n"

#: src/stat.c:1775
#, fuzzy
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""
"  %i\t十六进制文件系统ID\n"
"  %I\t允许的文件名最大长度\n"
"  %n\t文件名\n"
"  %s\t块大小(用于快速传输)\n"
"  %S\t基本块大小(用于块计数)\n"
"  %t\t十六进制类型描述\n"
"  %T\t可读性较好的类型描述\n"

#: src/stat.c:1785
#, c-format
msgid ""
"\n"
"--terse is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"\n"
"--terse 和下列<格式>等效：:\n"
"    %s"

#: src/stat.c:1796
#, c-format
msgid ""
"--terse --file-system is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"--terse --file-system 与下列<格式>等效：\n"
"    %s"

#: src/stdbuf.c:91
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "用法：%s [选项]... 命令\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr "运行给定的命令，同时改变该命令对应标准输入输出流的缓冲操作配置。\n"

#: src/stdbuf.c:98
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=MODE   调整标准输入流缓冲区\n"
"  -o, --output=MODE  调整标准输出流缓冲区\n"
"  -e, --error=MODE   调整标准错误流缓冲区\n"

#: src/stdbuf.c:105
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"若 MODE 是 \"L\"，则相应的流将是行缓冲模式。\n"
"标准输入流下此选项无效。\n"

#: src/stdbuf.c:108
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"若 MODE 是 \"0\"，则相应的流将不缓冲。\n"

#: src/stdbuf.c:111
#, fuzzy
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"否则 MODE 就应该是以下数字单位中的一个：\n"
"KB 1000，K 1024，MB 1000*1000，M 1024*1024，以及 G、T、P、E、Z、Y。\n"
"在此情况下，相应的流将缓冲由 MODE 指定大小的缓冲字节。\n"
"\n"

#: src/stdbuf.c:118
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for example) then that will override corresponding changes by 'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""
"\n"
"注意：若指定的命令调整了其自身的标准流缓冲区（例如 tee 命令），\n"
"则此操作会覆盖由 \"stdbuf\" 工具所做出的相应设置。\n"
"还有某些过滤器程序（如 \"dd\" 和 \"cat\" 之类）不使用输入输出流，\n"
"因此不受 \"stdbuf\" 设置的影响。\n"

#: src/stdbuf.c:243
#, c-format
msgid "failed to find %s"
msgstr "查找 %s 失败"

#: src/stdbuf.c:267 src/stdbuf.c:300
#, c-format
msgid "failed to update the environment with %s"
msgstr "更新 %s 的环境失败"

#: src/stdbuf.c:346
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "对标准输入进行行缓冲无意义"

#: src/stdbuf.c:377
#, c-format
msgid "you must specify a buffering mode option"
msgstr "您必须指定一个缓冲模式选项"

#: src/stty.c:531
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"用法：%s [-F 设备 | --file=设备] [设置]...\n"
"　或：%s [-F 设备 | --file=设备] [-a|--all]\n"
"　或：%s [-F 设备 | --file=设备] [-g|--save]\n"

#: src/stty.c:537
msgid "Print or change terminal characteristics.\n"
msgstr "输出或变更终端特性。\n"

#: src/stty.c:543
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"  -a, --all          以可读性较好的格式输出全部当前设置\n"
"  -g, --save         以 stty 可读取的格式输出当前全部设置\n"
"  -F, --file=设备    打开并使用指定<设备>代替标准输入\n"

#: src/stty.c:550
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"可选- 在设置前的指示中，* 标记出了非POSIX 标准的设置。以下系\n"
"统定义象征了哪些设置是有效的。\n"

#: src/stty.c:555
msgid ""
"\n"
"Special characters:\n"
msgstr ""
"\n"
"特殊字符：\n"

#: src/stty.c:559
msgid " * discard CHAR  CHAR will toggle discarding of output\n"
msgstr ""

#: src/stty.c:564
msgid ""
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
msgstr ""

#: src/stty.c:568
#, fuzzy
msgid ""
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"\n"
"特殊字符：\n"
" * dsusp 字符\t每当输入刷新时会发送一个用于终端阻塞信号的字符\n"
"   eof\t字符\t表示文件末尾而发送的字符(用于终止输入)\n"
"   eol\t字符\t为表示行尾而发送的字符\n"

#: src/stty.c:573
msgid " * eol2 CHAR     alternate CHAR for ending the line\n"
msgstr ""

#: src/stty.c:577
#, fuzzy
msgid ""
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
" * eol2 字符\t为表示行尾而发送的另一个可选字符\n"
"   erase 字符\t擦除前一个输入文字的字符\n"
"   intr 字符\t用于发送中断信号的字符\n"
"   kill 字符\t用于擦除当前终端行的字符\n"

#: src/stty.c:583
msgid " * lnext CHAR    CHAR will enter the next character quoted\n"
msgstr ""

#: src/stty.c:588
msgid " * status CHAR   CHAR will send an info signal\n"
msgstr ""

#: src/stty.c:592
msgid "   quit CHAR     CHAR will send a quit signal\n"
msgstr ""

#: src/stty.c:596
msgid " * rprnt CHAR    CHAR will redraw the current line\n"
msgstr ""

#: src/stty.c:600
#, fuzzy
msgid ""
"   start CHAR    CHAR will restart the output after stopping it\n"
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
msgstr ""
"   stop 字符\t停止输出的字符\n"
"   susp 字符\t发送终端阻断信号的字符\n"
" * swtch 字符\t在不同的shell 层次间切换的字符\n"
" * werase 字符\t擦除前一个输入的单词的字符\n"

#: src/stty.c:606
msgid " * swtch CHAR    CHAR will switch to a different shell layer\n"
msgstr ""

#: src/stty.c:611
msgid " * werase CHAR   CHAR will erase the last word typed\n"
msgstr ""

#: src/stty.c:615
#, fuzzy
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
msgstr ""
"\n"
"特殊设置：\n"
"   N\t\t设置输入输出速度为N 波特\n"
" * cols N\t统治内核终端上有N 栏\n"
" * columns N\t等于cols N\n"

#: src/stty.c:621
#, fuzzy
msgid ""
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
"\n"
"特殊设置：\n"
"   N\t\t设置输入输出速度为N 波特\n"
" * cols N\t统治内核终端上有N 栏\n"
" * columns N\t等于cols N\n"

#: src/stty.c:626
#, c-format
msgid ""
" * [-]drain      wait for transmission before applying settings (%s by "
"default)\n"
msgstr " * [-]drain      应用设置前等待传输（默认 %s）\n"

#: src/stty.c:628
msgid "on"
msgstr ""

#: src/stty.c:628
msgid "off"
msgstr ""

#: src/stty.c:629
msgid "   ispeed N      set the input speed to N\n"
msgstr "   ispeed N      设置输入速度为 N\n"

#: src/stty.c:633
msgid " * line N        use line discipline N\n"
msgstr ""

#: src/stty.c:637
#, fuzzy
msgid ""
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"   ispeed N\t设置输入速度为N 波特\n"
" * line N\t设置行约束规则为N\n"
"   min N\t和 -icanon 配合使用，设置每次一完整读入的最小字符数为<N>\n"
"   ospeed N\t设置输出速度为N 波特\n"

#: src/stty.c:642
#, fuzzy
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
msgstr ""
" * rows N\t向内核通告此终端有N 行\n"
" * size\t根据内核信息输出当前终端的行数和列数\n"
"   speed\t输出终端速度(单位为波特)\n"
"   time N\t和-icanon 配合使用，设置读取超时为N 个十分之一秒\n"

#: src/stty.c:647
#, fuzzy
msgid ""
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
" * rows N\t向内核通告此终端有N 行\n"
" * size\t根据内核信息输出当前终端的行数和列数\n"
"   speed\t输出终端速度(单位为波特)\n"
"   time N\t和-icanon 配合使用，设置读取超时为N 个十分之一秒\n"

#: src/stty.c:651
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
msgstr ""
"\n"
"控制设置：\n"
"   [-]clocal     禁用调制解调器控制信号\n"
"   [-]cread      允许接收输入\n"

#: src/stty.c:658
msgid " * [-]crtscts    enable RTS/CTS handshaking\n"
msgstr " * [-]crtscts    启用 RTS/CTS 握手\n"

#: src/stty.c:663
msgid " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
msgstr " * [-]cdtrdsr    启用 DTR/DSR 握手\n"

#: src/stty.c:667
msgid "   csN           set character size to N bits, N in [5..8]\n"
msgstr "   csN           将字符大小设置为 N 比特，N 取值在 [5..8] 之间\n"

#: src/stty.c:670
#, fuzzy
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""
"   [-]cstopb\t每个字符使用2 位停止位 (要恢复成1 位配合\"-\"即可)\n"
"   [-]hup\t当最后一个进程关闭标准终端后发送挂起信号\n"
"   [-]hupcl\t等于[-]hup\n"
"   [-]parenb\t对输出生成奇偶校验位并等待输入的奇偶校验位\n"
"   [-]parodd\t设置校验位为奇数 (配合\"-\"则为偶数)\n"

#: src/stty.c:678
msgid " * [-]cmspar     use \"stick\" (mark/space) parity\n"
msgstr ""

#: src/stty.c:682
#, fuzzy
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
"   [-]ignpar     ignore characters with parity errors\n"
msgstr ""
"\n"
"输入设置：\n"
"   [-]brkint\t任务中断会触发中断信号\n"
"   [-]icrnl\t将回车转换为换行符\n"
"   [-]ignbrk\t忽略中断字符\n"
"   [-]igncr\t忽略回车\n"

#: src/stty.c:692
msgid ""
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
msgstr ""

#: src/stty.c:696
#, fuzzy
msgid ""
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"   [-]ignpar\t忽略含有奇偶不对称错误的字符\n"
" * [-]imaxbel\t发出终端响铃但不刷新字符的完整输入缓冲\n"
"   [-]inlcr\t将换行符转换为回车\n"
"   [-]inpck\t启用输入奇偶性校验\n"
"   [-]istrip\t剥除输入字符的高8 位比特\n"

#: src/stty.c:702
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " * [-]iutf8\t假定输入字符都是UTF-8 编码\n"

#: src/stty.c:707
msgid " * [-]iuclc      translate uppercase characters to lowercase\n"
msgstr " * [-]iuclc      将大写字符转换为小写\n"

#: src/stty.c:712
msgid ""
" * [-]ixany      let any character restart output, not only start character\n"
msgstr ""

#: src/stty.c:716
#, fuzzy
msgid ""
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
" * [-]iuclc\t将大写字母转换为小写\n"
" * [-]ixany\t使得任何字符都会重启输出，不仅仅是起始字符\n"
"   [-]ixoff\t启用开始/停止字符传送\n"
"   [-]ixon\t启用XON/XOFF 流控制\n"
"   [-]parmrk\t标记奇偶校验错误 (结合255-0 字符序列)\n"
"   [-]tandem\t等于[-]ixoff\n"

#: src/stty.c:722
msgid ""
"\n"
"Output settings:\n"
msgstr ""
"\n"
"输出设置：\n"

#: src/stty.c:727
msgid " * bsN           backspace delay style, N in [0..1]\n"
msgstr " * bsN           退格延迟风格，N 取值在 [0..1] 范围内\n"

#: src/stty.c:732
msgid " * crN           carriage return delay style, N in [0..3]\n"
msgstr ""

#: src/stty.c:737
msgid " * ffN           form feed delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:742
msgid " * nlN           newline delay style, N in [0..1]\n"
msgstr " * nlN           新行延迟风格，N 取值在 [0..1] 范围内\n"

#: src/stty.c:747
msgid " * [-]ocrnl      translate carriage return to newline\n"
msgstr ""

#: src/stty.c:752
msgid ""
" * [-]ofdel      use delete characters for fill instead of NUL characters\n"
msgstr ""

#: src/stty.c:757
msgid ""
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
msgstr ""

#: src/stty.c:762
msgid " * [-]olcuc      translate lowercase characters to uppercase\n"
msgstr ""

#: src/stty.c:767
msgid " * [-]onlcr      translate newline to carriage return-newline\n"
msgstr ""

#: src/stty.c:772
msgid " * [-]onlret     newline performs a carriage return\n"
msgstr ""

#: src/stty.c:777
msgid " * [-]onocr      do not print carriage returns in the first column\n"
msgstr ""

#: src/stty.c:781
msgid "   [-]opost      postprocess output\n"
msgstr "   [-]opost      对输出进行后处理\n"

#: src/stty.c:785
msgid ""
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
msgstr ""

#: src/stty.c:792
msgid " * vtN           vertical tab delay style, N in [0..1]\n"
msgstr ""

#: src/stty.c:796
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
msgstr ""
"\n"
"本地设置：\n"
"   [-]crterase   将清除字符回显输出为退格-空格-退格\n"

#: src/stty.c:802
#, fuzzy
msgid ""
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
"\n"
"本地设置：\n"
"   [-]crterase\t擦除字符回显为退格符\n"
" * crtkill\t依照echoprt 和echoe 的设置清除所有行\n"
" * -crtkill\t依照echoctl 和echol 的设置清除所有行\n"

#: src/stty.c:808
msgid " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
msgstr ""

#: src/stty.c:812
msgid "   [-]echo       echo input characters\n"
msgstr "   [-]echo       对输入字符进行回显\n"

#: src/stty.c:816
msgid " * [-]echoctl    same as [-]ctlecho\n"
msgstr " * [-]echoctl    和 [-]ctlecho 相同\n"

#: src/stty.c:820
msgid ""
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""

#: src/stty.c:825
msgid " * [-]echoke     same as [-]crtkill\n"
msgstr " * [-]echoke     与 [-]crtkill 相同\n"

#: src/stty.c:829
msgid "   [-]echonl     echo newline even if not echoing other characters\n"
msgstr ""

#: src/stty.c:833
msgid ""
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
msgstr ""

#: src/stty.c:838
msgid " * [-]extproc    enable \"LINEMODE\"; useful with high latency links\n"
msgstr " * [-]extproc    启用“行模式”（LINEMODE）；在高延迟连接下有用\n"

#: src/stty.c:843
msgid " * [-]flusho     discard output\n"
msgstr " * [-]flusho     丢弃输出\n"

#: src/stty.c:847
#, c-format
msgid ""
"   [-]icanon     enable special characters: %s\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"   [-]icanon     启用特殊字符：%s\n"
"   [-]iexten     启用非 POSIX 特殊字符\n"

#: src/stty.c:858
#, fuzzy
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
msgstr ""
"   [-]isig\t启用interrupt、quit和suspend 等特殊字符\n"
"   [-]noflsh\t在interrupt 和 quit 特殊字符后禁止刷新\n"
" * [-]prterase\t等于[-]echoprt\n"
" * [-]tostop\t中止尝试向终端写入数据的后台任务\n"
" * [-]xcase\t和icanon 配合使用，用转义符\"\\\"退出大写状态\n"

#: src/stty.c:863
msgid " * [-]prterase   same as [-]echoprt\n"
msgstr " * [-]prterase   与 [-]echoprt 相同\n"

#: src/stty.c:868
msgid ""
" * [-]tostop     stop background jobs that try to write to the terminal\n"
msgstr " * [-]tostop     停止尝试写入终端的后台任务\n"

#: src/stty.c:873
msgid ""
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""

#: src/stty.c:877
msgid ""
"\n"
"Combination settings:\n"
msgstr ""
"\n"
"组合设置：\n"

#: src/stty.c:882
msgid " * [-]LCASE      same as [-]lcase\n"
msgstr " * [-]LCASE      与 [-]lcase 相同\n"

#: src/stty.c:886
msgid ""
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"   cbreak        与 -icanon 相同\n"
"   -cbreak       与 icanon 相同\n"

#: src/stty.c:890
#, fuzzy
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
msgstr ""
"   cooked\t等于brkint ignpar istrip icrnl ixon opost isig icanon eof \t\t"
"\teol 等的默认值\n"
"   -cooked\t等于-raw\n"
"   crt\t\t等于echoe echoctl echoke\n"

#: src/stty.c:895
#, c-format
msgid "   crt           same as %s\n"
msgstr "   crt           与 %s 相同\n"

#: src/stty.c:905
#, c-format
msgid ""
"   dec           same as %s intr ^c erase 0177\n"
"                 kill ^u\n"
msgstr ""

#: src/stty.c:920
msgid " * [-]decctlq    same as [-]ixany\n"
msgstr " * [-]decctlq    与 [-]ixany 相同\n"

#: src/stty.c:924
msgid ""
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
"   -evenp        same as -parenb cs8\n"
msgstr ""

#: src/stty.c:930
msgid " * [-]lcase      same as xcase iuclc olcuc\n"
msgstr ""

#: src/stty.c:934
msgid ""
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
msgstr ""
"   litout        与 -parenb -istrip -opost cs8 相同\n"
"   -litout       与 parenb istrip opost cs7 相同\n"

#: src/stty.c:938
#, c-format
msgid ""
"   nl            same as %s\n"
"   -nl           same as %s\n"
msgstr ""
"   nl            与 %s 相同\n"
"   -nl           与 %s 相同\n"

#: src/stty.c:956
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"   oddp\t等于parenb parodd cs7\n"
"   -oddp\t等于-parenb cs8\n"
"   [-]parity\t等于[-]evenp\n"
"   pass8\t等于-parenb -istrip cs8\n"
"   -pass8\t等于parenb istrip cs7\n"

#: src/stty.c:963
#, c-format
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"   raw           等效于 -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          等效于 cooked\n"

#: src/stty.c:982
#, c-format
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 all special characters to their default values\n"
msgstr ""
"   sane          等效于 cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s，\n"
"                 所有特殊字符均为其默认值\n"

#: src/stty.c:1068
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"处理连接到标准输入的tty 终端行设置。当不附加参数时，程序会输出波特率、行约"
"束\n"
"规则以及与标准stty 设置间的偏差。在设置中，字符会被逐字读取或是被编码为^c、\n"
"0x37、0177 或127 这样的字符，其中有特殊值^- 或undef 被用于禁止特殊字符。\n"

#: src/stty.c:1097
#, c-format
msgid "missing argument to %s"
msgstr "缺少%s 的参数"

#: src/stty.c:1140 src/stty.c:1258
#, c-format
msgid "invalid argument %s"
msgstr "无效的参数 %s"

#: src/stty.c:1192
#, c-format
msgid "%s: error setting %s"
msgstr "%s：设置 %s 时出错"

#: src/stty.c:1234
#, c-format
msgid "invalid line discipline %s"
msgstr "无效的行约束%s"

#: src/stty.c:1326
msgid "only one device may be specified"
msgstr "只能指定一个设备"

#: src/stty.c:1360
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr "verbose 和 stty-readable 两种输入风格的选项是互相抵触的"

#: src/stty.c:1366
msgid "when specifying an output style, modes may not be set"
msgstr "当指定了输出风格时，模式不能再被设置"

#: src/stty.c:1384
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s：无法重置非阻塞模式"

#: src/stty.c:1447
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s：无法执行所有请求的操作"

#: src/stty.c:1792
#, c-format
msgid "%s: no size information for this device"
msgstr "%s：此设备没有大小信息"

#: src/stty.c:2321
msgid "invalid integer argument"
msgstr "无效的整数参数"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:38
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:63
msgid "Print checksum and block counts for each FILE.\n"
msgstr "输出每个指定文件的校验值和块计数。\n"

#: src/sum.c:69
msgid ""
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"\n"
"  -r              使用 BSD 加和算法，以1 KB 为一个块\n"
"  -s, --sysv      使用System V 加和算法，以512字节为一个块\n"

#: src/sync.c:64
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "用法：%s [选项] [文件]...\n"

#: src/sync.c:65
msgid ""
"Synchronize cached writes to persistent storage\n"
"\n"
"If one or more files are specified, sync only them,\n"
"or their containing file systems.\n"
"\n"
msgstr ""
"将缓存数据写入持久存储设备中\n"
"\n"
"如果指定了一个或多个文件，则只同步这些文件（或包含它们的文件系统）。\n"
"\n"

#: src/sync.c:73
msgid "  -d, --data             sync only file data, no unneeded metadata\n"
msgstr "  -d, --data             仅同步文件数据，不处理无需同步的元数据\n"

#: src/sync.c:76
msgid "  -f, --file-system      sync the file systems that contain the files\n"
msgstr "  -f, --file-system      对包含文件的文件系统也进行同步\n"

#: src/sync.c:115
#, c-format
msgid "error opening %s"
msgstr "打开 %s 时出错"

#: src/sync.c:126
#, c-format
msgid "couldn't reset non-blocking mode %s"
msgstr "无法重置非阻塞模式 %s"

#: src/sync.c:157
#, c-format
msgid "error syncing %s"
msgstr "同步 %s 时出错"

#: src/sync.c:215
msgid "cannot specify both --data and --file-system"
msgstr "无法同时指定 --data 和 --file-system"

#: src/sync.c:219
msgid "--data needs at least one argument"
msgstr "--data 需要至少一个参数"

#: src/system.h:347
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"注意：您的shell 可能内置了自己的%s 程序版本，它会覆盖这里所提及的相应\n"
"版本。请查阅您的shell 文档获知它所支持的选项。\n"

#: src/system.h:353
msgid "      --help     display this help and exit\n"
msgstr "      --help\t\t显示此帮助信息并退出\n"

#: src/system.h:355
msgid "      --version  output version information and exit\n"
msgstr "      --version\t\t显示版本信息并退出\n"

#: src/system.h:583
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"如果没有指定文件，或者文件为\"-\"，则从标准输入读取。\n"

#: src/system.h:590
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"\n"
"必选参数对长短选项同时适用。\n"

#: src/system.h:598
msgid ""
"\n"
"The SIZE argument is an integer and optional unit (example: 10K is "
"10*1024).\n"
"Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""

#: src/system.h:608
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"所显示的数值是来自 --block-size、%s_BLOCK_SIZE、BLOCK_SIZE \n"
"及 BLOCKSIZE 环境变量中第一个可用的 SIZE 单位。\n"
"否则，默认单位是 1024 字节(或是 512，若设定 POSIXLY_CORRECT 的话)。\n"

#: src/system.h:618
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"备份文件的后缀为\"~\"，除非以--suffix 选项或是 SIMPLE_BACKUP_SUFFIX\n"
"环境变量指定。版本控制的方式可通过--backup 选项或 VERSION_CONTROL 环境\n"
"变量来选择。以下是可用的变量值：\n"
"\n"

#: src/system.h:625
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       不进行备份(即使使用了--backup 选项)\n"
"  numbered, t     备份文件加上数字进行排序\n"
"  existing, nil   若有数字的备份文件已经存在则使用数字，否则使用普通方式备"
"份\n"
"  simple, never   永远使用普通方式备份\n"

#: src/system.h:655
#, c-format
msgid ""
"\n"
"%s online help: <%s>\n"
msgstr ""
"\n"
"%s 在线帮助：<%s>\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <https://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at https://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:666
msgid "Report any translation bugs to <https://translationproject.org/team/>\n"
msgstr ""
"请向 <http://translationproject.org/team/zh_CN.html> 报告任何翻译错误\n"

#: src/system.h:669
#, c-format
msgid "Full documentation <%s%s>\n"
msgstr "完整文档 <%s%s>\n"

#: src/system.h:671
#, c-format
msgid "or available locally via: info '(coreutils) %s%s'\n"
msgstr "或者在本地使用：info '(coreutils) %s%s'\n"

#: src/system.h:682
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "请尝试执行 \"%s --help\" 来获取更多信息。\n"

#: src/system.h:726
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"警告：发现循环的目录架构。\n"
"这几乎可以肯定文件系统已经损坏。\n"
"** 请通知系统管理员。**\n"
"以下的目录是循环的一部份：\n"
"  %s\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:136
msgid "Write each FILE to standard output, last line first.\n"
msgstr "将每个指定文件按行倒置并写到标准输出。\n"

#: src/tac.c:143
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before\t\t\t在行前而非行尾添加分隔标志\n"
"  -r, --regex\t\t\t将分隔标志视作正则表达式来解析\n"
"  -s, --separator=字符串\t使用指定字符串代替换行作为分隔标志\n"

#: src/tac.c:223 src/tac.c:233 src/tac.c:343
#, c-format
msgid "%s: seek failed"
msgstr "%s：检索失败"

#: src/tac.c:276
msgid "record too large"
msgstr "记录数据过大"

#: src/tac.c:458
#, c-format
msgid "failed to create temporary file in %s"
msgstr "在 %s 创建临时文件失败"

#: src/tac.c:466
#, c-format
msgid "failed to open %s for writing"
msgstr "以写模式打开 %s 时失败"

#: src/tac.c:484
#, c-format
msgid "failed to rewind stream for %s"
msgstr "为 %s 进行流 rewind 操作时失败"

#: src/tac.c:521 src/tac.c:533
#, c-format
msgid "%s: write error"
msgstr "%s：写入出错"

#: src/tac.c:582
#, c-format
msgid "failed to open %s for reading"
msgstr "以读模式打开 %s 时失败"

#: src/tac.c:650
msgid "separator cannot be empty"
msgstr "分隔符不能为空"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:78
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:269
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"显示每个指定文件的最后 %d 行并输出至标准输出。\n"
"若指定了多于一个文件，程序会在每段输出的开始添加相应文件名作为头。\n"

#: src/tail.c:277
msgid ""
"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
"                             output starting with byte NUM of each file\n"
msgstr ""
"  -c, --bytes=[+]NUM       输出最后 NUM 字节；或者使用 -c +NUM 以输出\n"
"                             每个文件第 NUM 个字节之后的全部内容\n"

#: src/tail.c:281
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                             an absent option argument means 'descriptor'\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           随文件增长即时输出新增数据；\n"
"                             若未给定选项参数，则默认使用 'descriptor'\n"
"  -F                       和 --follow=name --retry 相同\n"

#: src/tail.c:287
#, fuzzy, c-format
msgid ""
"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last "
"%d;\n"
"                             or use -n +NUM to output starting with line "
"NUM\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                             changed size after N (default %d) iterations\n"
"                             to see if it has been unlinked or renamed\n"
"                             (this is the usual case of rotated log files);\n"
"                             with inotify, this option is rarely useful\n"
msgstr ""
"  -n, --lines=K\t输出最后K 行，代替最后%d 行；使用-n +K 从每个文件的第K 字节"
"输出\n"
"      --max-unchanged-stats=N\n"
"\t\t\t使用--follow=name, 重新打开一个在N(默认为%d)\n"
"\t\t\t\t次迭代后没有改变大小的文件来看它是否被解除连\n"
"\t\t\t\t接或重命名(这是循环日志文件的通常情况)。\n"
"\t\t\t\t由于有inotify，这个选项很少使用。\n"

#: src/tail.c:300
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file if it is inaccessible\n"
msgstr ""
"      --pid=PID            同 -f 一起使用，当所指定<PID>对应的进程死去后终"
"止\n"
"  -q, --quiet, --silent    不输出给出文件名的头\n"
"      --retry              即使目标文件不可访问依然重复试图打开\n"

#: src/tail.c:305
#, fuzzy
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations;\n"
"                             with inotify and --pid=P, check process P at\n"
"                             least once every N seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=秒数\t同-f 一起使用，在迭代间暂停约指定秒数的时间\n"
"\t\t\t\t(默认1.0 秒)\n"
"  -v, --verbose\t\t总是输出给出文件名的头\n"

#: src/tail.c:317
#, fuzzy
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
msgstr ""
"\n"
"K 后面可以跟乘号:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, 对于T, P, E, Z, Y 同样适用。\n"

#: src/tail.c:325
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"如果您希望即时追查一个文件的有效名称而非描述内容(例如循环日志)，默认\n"
"的程序动作并不如您所愿。在这种场合可以使用--follow=name 选项，它会使\n"
"tail 定期追踪打开给定名称的文件，以确认它是否被删除或被其它某些程序重新创建"
"过。\n"

#: src/tail.c:416
#, c-format
msgid "closing %s (fd=%d)"
msgstr "正在关闭 %s (fd=%d)"

#: src/tail.c:515
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s：无法检索相对偏移量的末尾 %s"

#: src/tail.c:951
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr "无法定位 %s 的位置，回归为 polling 机制"

#: src/tail.c:1007
#, c-format
msgid "%s has been replaced with an untailable symbolic link"
msgstr "%s 已被替换为 tail 无法处理的符号链接"

#: src/tail.c:1022
#, c-format
msgid "%s has become inaccessible"
msgstr "%s 已不可访问"

#: src/tail.c:1040
#, c-format
msgid "%s has been replaced with an untailable file%s"
msgstr "%s 已被替换为 tail 无法处理的文件 %s"

#: src/tail.c:1042 src/tail.c:2048
msgid "; giving up on this name"
msgstr "；放弃处理该名称"

#: src/tail.c:1048
#, c-format
msgid "%s has been replaced with an untailable remote file"
msgstr "%s 已被替换为 tail 无法处理的远程文件"

#: src/tail.c:1069
#, c-format
msgid "%s has become accessible"
msgstr "%s 已经可以访问"

#: src/tail.c:1081
#, c-format
msgid "%s has appeared;  following new file"
msgstr "%s 已被建立；正在跟随新文件的末尾"

#: src/tail.c:1091
#, c-format
msgid "%s has been replaced;  following new file"
msgstr "%s 已被替换；正在跟随新文件的末尾"

#: src/tail.c:1206
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s：无法更改非阻塞模式"

#: src/tail.c:1252 src/tail.c:1427
#, c-format
msgid "%s: file truncated"
msgstr "%s：文件已截断"

#: src/tail.c:1286 src/tail.c:1628
#, c-format
msgid "no files remaining"
msgstr "没有剩余文件"

#: src/tail.c:1522
#, c-format
msgid "cannot watch parent directory of %s"
msgstr "无法监视 %s 的上级目录"

#: src/tail.c:1525 src/tail.c:1542 src/tail.c:1752
#, c-format
msgid "inotify resources exhausted"
msgstr "inotify 资源耗尽"

#: src/tail.c:1546 src/tail.c:1760
#, c-format
msgid "cannot watch %s"
msgstr "无法监视 %s"

#: src/tail.c:1595
#, c-format
msgid "%s was replaced"
msgstr "%s 已被替换"

#: src/tail.c:1667
msgid "error waiting for inotify and output events"
msgstr "等待 inotify 和输出事件时出错"

#: src/tail.c:1695
msgid "error reading inotify event"
msgstr "读取 inotify 事件出错"

#: src/tail.c:1714
#, c-format
msgid "directory containing watched file was removed"
msgstr "包含所监视文件的目录已被删除"

#: src/tail.c:2046
#, c-format
msgid "%s: cannot follow end of this type of file%s"
msgstr "%s：无法跟随此类型文件的末尾 %s"

#: src/tail.c:2227
msgid "invalid maximum number of unchanged stats between opens"
msgstr ""

#: src/tail.c:2235
msgid "invalid PID"
msgstr "无效的进程号（PID）"

#: src/tail.c:2251
#, c-format
msgid "invalid number of seconds: %s"
msgstr "无效的秒数：%s"

#: src/tail.c:2270
#, c-format
msgid "option used in invalid context -- %c"
msgstr "在无效上下文中使用选项 -- %c"

#: src/tail.c:2282
#, c-format
msgid "warning: --retry ignored; --retry is useful only when following"
msgstr "警告：已忽略 --retry；只有在跟随模式下 --retry 选项才是有用的"

#: src/tail.c:2286
#, c-format
msgid "warning: --retry only effective for the initial open"
msgstr "警告：--retry 仅对初次打开文件有效"

#: src/tail.c:2291
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "警告：已忽略进程号，只有在跟随模式下 --pid=PID 选项才是有用的"

#: src/tail.c:2294
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "警告：此系统不支持 --pid=PID"

#: src/tail.c:2400
#, c-format
msgid "cannot follow %s by name"
msgstr "无法按名称跟随 %s"

#: src/tail.c:2415
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "警告：无限期跟随标准输入是"

#: src/tail.c:2512
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "无法使用 inotify 机制，回退为轮询（polling）机制"

#: src/tee.c:88
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"将标准输入复制到每个指定文件，并显示到标准输出。\n"
"\n"
"  -a, --append\t\t内容追加到给定的文件而非覆盖\n"
"  -i, --ignore-interrupts\t忽略中断信号\n"

#: src/tee.c:94
msgid ""
"  -p                        diagnose errors writing to non pipes\n"
"      --output-error[=MODE]   set behavior on write error.  See MODE below\n"
msgstr ""
"  -p                        对写入非管道的行为排查错误\n"
"      --output-error[=模式]   设置写入出错时的行为。见下面“模式”部分\n"

#: src/tee.c:100
msgid ""
"\n"
"MODE determines behavior with write errors on the outputs:\n"
"  'warn'         diagnose errors writing to any output\n"
"  'warn-nopipe'  diagnose errors writing to any output not a pipe\n"
"  'exit'         exit on error writing to any output\n"
"  'exit-nopipe'  exit on error writing to any output not a pipe\n"
"The default MODE for the -p option is 'warn-nopipe'.\n"
"The default operation when --output-error is not specified, is to\n"
"exit immediately on error writing to a pipe, and diagnose errors\n"
"writing to non pipe outputs.\n"
msgstr ""
"\n"
"模式确定向输出写入出错时的行为：\n"
"  'warn'         对向任何文件输出出错的情况进行诊断\n"
"  'warn-nopipe'  对向除了管道以外的任何文件输出出错的情况进行诊断\n"
"  'exit'         一旦输出出错，则退出程序\n"
"  'exit-nopipe'  一旦输出出错且非管道，则退出程序\n"
"-p 选项的默认模式是“warn-nopipe”。\n"
"当 --output-error 没有给出时，默认的操作是在向管道写入出错时立刻退出，\n"
"且在向非管道写入出错时对问题进行诊断。\n"

#: src/test.c:126
#, c-format
msgid "missing argument after %s"
msgstr "%s 后缺少参数"

#: src/test.c:162
#, c-format
msgid "invalid integer %s"
msgstr "无效的整数 %s"

#: src/test.c:244
#, c-format
msgid "%s expected"
msgstr "预期得到 %s"

#: src/test.c:247
#, c-format
msgid "%s expected, found %s"
msgstr "预期得到 %s，实际得到 %s"

#: src/test.c:328
msgid "-nt does not accept -l"
msgstr "-nt 不能与-l 同时使用"

#: src/test.c:341
msgid "-ef does not accept -l"
msgstr "-ef 不能与-l 同时使用"

#: src/test.c:357
msgid "-ot does not accept -l"
msgstr "-ot 不能于-l 同时使用"

#: src/test.c:366
#, c-format
msgid "%s: unknown binary operator"
msgstr "%s：未知双目运算符"

#: src/test.c:396
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: 预期为单目运算符"

#: src/test.c:632
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: 预期为双目运算符"

#: src/test.c:690
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"用法：%s 表达式\n"
"　或：test\n"
"　或：[表达式]\n"
"　或：[ ]\n"
"　或：[ 选项\n"

#: src/test.c:697
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr ""
"退出状态值取决于表达式。\n"
"\n"

#: src/test.c:703
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"被省略的表达式的值默认为假，否则可能为真也可能为假，\n"
"并会被设为退出状态值。有效的表达式应属于下列之一：\n"

#: src/test.c:708
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( 表达式 )\t\t表达式的值为真\n"
"  ! 表达式\t\t表达式的值为假(非)\n"
"  表达式1 -a 表达式2\t两个表达式的值都为真时结果为真(与)\n"
"  表达式1 -o 表达式2\t两个表达式中任一的值为真时结果为真(或)\n"

#: src/test.c:715
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n 字符串\t\t字符串的长度非零\n"
"  字符串\t\t等于\"-n 字符串\"\n"
"  -z 字符串\t\t字符串的长度为零\n"
"  字符串1 = 字符串2\t两个字符串相等\n"
"  字符串1 != 字符串2\t两个字符串不等\n"

#: src/test.c:723
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  整数1 -eq 整数2\t整数1 等于整数2\n"
"  整数1 -ge 整数2\t整数1 大于等于整数2\n"
"  整数1 -gt 整数2\t整数1 大于 整数2\n"
"  整数1 -le 整数2\t整数1 大于等于整数2\n"
"  整数1 -lt 整数2\t整数1 小于 整数2\n"
"  整数1 -ne 整数2\t整数1 不等于整数2\n"

#: src/test.c:732
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  文件1 -ef  文件2\t文件1 与文件2 的设备和节点号相等\n"
"  文件1 -nt  文件2\t文件1 的上次修改时间新于文件2\n"
"  文件1 -ot  文件2\t文件1 的上次修改时间旧于文件2\n"

#: src/test.c:738
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b 文件\t\t指定文件存在且为块设备文件\n"
"  -c 文件\t\t指定文件存在且为字符设备文件\n"
"  -d 文件\t\t指定文件存在且为目录\n"
"  -e 文件\t\t指定文件存在\n"

#: src/test.c:745
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f 文件\t\t指定文件存在且为普通文件\n"
"  -g 文件\t\t指定文件存在且设置了setgid 位\n"
"  -G 文件\t\t指定文件存在且属组ID 有效\n"
"  -h 文件\t\t指定文件存在且为符号链接 (等价于 -L)\n"
"  -k 文件\t\t指定文件存在且设置了粘附位\n"

#: src/test.c:752
#, fuzzy
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -N FILE     FILE exists and has been modified since it was last read\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L 文件\t\t指定文件存在且为符号链接(等于-h)\n"
"  -O 文件\t\t指定文件存在且属主ID 有效\n"
"  -p 文件\t\t指定文件存在且为命名管道\n"
"  -r 文件\t\t指定文件存在且具备读取权限\n"
"  -s 文件\t\t指定文件存在且其大小大于0\n"

#: src/test.c:760
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S 文件\t\t指定文件存在且为套接字文件\n"
"  -t FD\t\t\t已有一个终端打开了文件的描述符FD\n"
"  -u 文件\t\t指定文件存在且设置了setuid 位\n"
"  -w 文件\t\t指定文件存在且具备写入权限\n"
"  -x 文件\t\t指定文件存在且具备执行或搜索(针对目录)权限\n"

#: src/test.c:767
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"除-h 和-L 以外，其它所有与指定文件相关的测试都会作用于符号链接。\n"
"请留心您在必要时需由shell 转义圆括号字符(例如使用反斜杠)。\n"
"指定整数也可用\"-l 字符串\"表示，这会估算相应字符串的长度。\n"

#: src/test.c:773
msgid ""
"\n"
"NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n"
"EXPR2' or 'test EXPR1 || test EXPR2' instead.\n"
msgstr ""
"\n"
"注意：二元运算符 -a 和 -o 从本质上是具有歧义的。请使用“test 表达式1 &&\n"
"test 表达式2”或者“test 表达式1 || test 表达式2”进行替代。\n"

#: src/test.c:778
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"注意：[ 服从 --help 和 --version 选项但 test 不同。\n"
"test 将其和其他非空字符串同能对待。\n"

#: src/test.c:783
msgid "test and/or ["
msgstr "test 和/或["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:795
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:796
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:850
#, c-format
msgid "missing %s"
msgstr "缺少 %s"

#: src/test.c:864
#, c-format
msgid "extra argument %s"
msgstr "多余的参数 %s"

#: src/timeout.c:135
#, c-format
msgid "warning: timer_settime"
msgstr "警告：timer_settime"

#: src/timeout.c:140
#, c-format
msgid "warning: timer_create"
msgstr "警告：timer_create"

#: src/timeout.c:207
#, c-format
msgid "sending signal %s to command %s"
msgstr "正在发送信号 %s 至命令 %s"

#: src/timeout.c:235
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"用法：%s [选项] 停留时间 命令 [参数]...\n"
"　或：%s 选项\n"

#: src/timeout.c:239
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr "运行指定命令，在指定的停留时间后若该命令仍在运行则将其中止。\n"

#: src/timeout.c:245
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                   command times out\n"
"      --foreground\n"
"                 when not running timeout directly from a shell prompt,\n"
"                   allow COMMAND to read from the TTY and get TTY signals;\n"
"                   in this mode, children of COMMAND will not be timed out\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                   this long after the initial signal was sent\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout;\n"
"                   SIGNAL may be a name like 'HUP' or a number;\n"
"                   see 'kill -l' for a list of signals\n"
msgstr ""
"      --preserve-status\n"
"                 退出时返回值与所运行命令的返回值保持相同，即使命令超时也\n"
"                   这样设置\n"
"      --foreground\n"
"                 当 timeout 不是直接从 shell 命令行开始运行时，允许所运行的\n"
"                   命令从 TTY 读取输入并获取 TTY 信号；在此模式下，所运行的\n"
"                   命令的子进程不会受超时的影响\n"
"  -k, --kill-after=持续时间\n"
"                 如果所运行命令在初始信号发出后再经过所指定持续时间以后仍然\n"
"                   在运行，则对其发送 KILL 信号\n"
"  -s, --signal=信号\n"
"                 指定超时发生时要发送的信号；\n"
"                   所指定的信号可以是如“HUP”这样的名称，或是一个数字；\n"
"                   请参见“kill -l”以获取可用信号列表\n"

#: src/timeout.c:260
msgid "  -v, --verbose  diagnose to stderr any signal sent upon timeout\n"
msgstr "  -v, --verbose  对任何超时后发送的信号，向标准错误输出诊断信息\n"

#: src/timeout.c:266
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
"A duration of 0 disables the associated timeout.\n"
msgstr ""
"\n"
"指定的持续时间应是一个附加有下列后缀的浮点数：\n"
"“s”代表秒（默认值），“m”代表分，“h”代表小时，“d”代表天数。\n"
"若持续时间设置为0,将禁用所关联的超时配置。\n"
"\n"

#: src/timeout.c:271
msgid ""
"\n"
"If the command times out, and --preserve-status is not set, then exit with\n"
"status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n"
"is specified, send the TERM signal upon timeout.  The TERM signal kills\n"
"any process that does not block or catch that signal.  It may be necessary\n"
"to use the KILL (9) signal, since this signal cannot be caught, in which\n"
"case the exit status is 128+9 rather than 124.\n"
msgstr ""
"\n"
"如果命令超时且未设置 --preserve-status，程序退出的状态值将为 124。\n"
"否则将使用所运行程序的退出状态值作为退出状态值。\n"
"如果没有指定信号则默认使用 TERM 信号。TERM 信号在进程没有捕获此信号时将\n"
"杀死进程。对于另一些进程可能需要使用 KILL (9)信号。因此信号无法被捕获，\n"
"退出返回值将为 128+9 而非 124。\n"

#: src/timeout.c:346 src/timeout.c:403
#, c-format
msgid "warning: sigprocmask"
msgstr "警告：sigprocmask"

#: src/timeout.c:425
#, c-format
msgid "warning: disabling core dumps failed"
msgstr "警告：禁用核心转储失败"

#: src/timeout.c:544
#, c-format
msgid "error waiting for command"
msgstr "等待命令出错"

#: src/timeout.c:555
#, c-format
msgid "the monitored command dumped core"
msgstr "监视的命令已核心转储"

#: src/timeout.c:568
#, c-format
msgid "unknown status from command (%d)"
msgstr "来自命令的未知状态（%d）"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:310
#, c-format
msgid "invalid date format %s"
msgstr "日期格式 %s 无效"

#: src/touch.c:192
#, c-format
msgid "cannot touch %s"
msgstr "无法创建 %s"

#: src/touch.c:198
#, c-format
msgid "setting times of %s"
msgstr "正在设置 %s 的时间"

#: src/touch.c:214
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""
"将所指定的每个文件的访问时间和修改时间更改为当前时间。\n"
"\n"
"除非提供 -c 或 -h 选项，否则指定不存在的文件将会被创建为空文件。\n"
"\n"
"如果所指定文件名为 - 则特殊处理，程序将更改与标准输出相关联的文件的\n"
"访问时间。\n"

#: src/touch.c:226
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a\t\t\t只更改访问时间\n"
"  -c, --no-create\t不创建任何文件\n"
"  -d, --date=字符串\t使用指定字符串表示时间而非当前时间\n"
"  -f\t\t\t(忽略)\n"

#: src/touch.c:232
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference\t\t会影响符号链接本身，而非符号链接所指示的目的地\n"
"\t\t\t\t(当系统支持更改符号链接的所有者时，此选项才有用)\n"
"  -m\t\t\t只更改修改时间\n"

#: src/touch.c:238
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=文件   使用指定文件的时间属性而非当前时间\n"
"  -t 时间戳              使用给定 [[CC]YY]MMDDhhmm[.ss] 的时间戳而非当前时"
"间\n"
"      --time=类型        修改指定类型的时间：\n"
"                           若所指定类型是 access、atime 或 use：与 -a 等效\n"
"                           若所指定类型是 modify 或 mtime：与 -m 等效\n"

#: src/touch.c:247
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"请注意，-d 和-t 选项可接受不同的时间/日期格式。\n"

#: src/touch.c:336
#, c-format
msgid "cannot specify times from more than one source"
msgstr "无法由多于一种的来源来指定时间"

#: src/touch.c:410
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"警告：\"touch %s\" 已过时；请使用 \"touch -t %04ld%02d%02d%02d%02d.%02d\" 代"
"替"

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "用法：%s [选项]... SET1 [SET2]\n"

#: src/tr.c:291
#, fuzzy
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each sequence of a repeated character\n"
"                            that is listed in the last specified SET,\n"
"                            with a single occurrence of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"从标准输入中替换、缩减和/或删除字符，并将结果写到标准输出。\n"
"\n"
"  -c, -C, --complement\t\t首先补足SET1\n"
"  -d, --delete\t\t\t删除匹配SET1 的内容，并不作替换\n"
"  -s, --squeeze-repeats\t如果匹配于SET1 的字符在输入序列中存在连续的\n"
"\t\t\t\t重复，在替换时会被统一缩为一个字符的长度\n"
"  -t, --truncate-set1\t\t先将SET1 的长度截为和SET2 相等\n"

#: src/tr.c:304
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"SET 是一组字符串，一般都可按照字面含义理解。解析序列如下：\n"
"\n"
"  \\NNN\t八进制值为NNN 的字符(1 至3 个数位)\n"
"  \\\\\t\t反斜杠\n"
"  \\a\t\t终端鸣响\n"
"  \\b\t\t退格\n"
"  \\f\t\t换页\n"
"  \\n\t\t换行\n"
"  \\r\t\t回车\n"
"  \\t\t\t水平制表符\n"

#: src/tr.c:318
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v\t\t垂直制表符\n"
"  字符1-字符2\t从字符1 到字符2 的升序递增过程中经历的所有字符\n"
"  [字符*]\t在SET2 中适用，指定字符会被连续复制直到吻合设置1 的长度\n"
"  [字符*次数]\t对字符执行指定次数的复制，若次数以 0 开头则被视为八进制数\n"
"  [:alnum:]\t所有的字母和数字\n"
"  [:alpha:]\t所有的字母\n"
"  [:blank:]\t所有呈水平排列的空白字符\n"
"  [:cntrl:]\t所有的控制字符\n"
"  [:digit:]\t所有的数字\n"

#: src/tr.c:329
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]\t所有的可打印字符，不包括空格\n"
"  [:lower:]\t所有的小写字母\n"
"  [:print:]\t所有的可打印字符，包括空格\n"
"  [:punct:]\t所有的标点字符\n"
"  [:space:]\t所有呈水平或垂直排列的空白字符\n"
"  [:upper:]\t所有的大写字母\n"
"  [:xdigit:]\t所有的十六进制数\n"
"  [=字符=]\t所有和指定字符相等的字符\n"

# ## Forward to here.
#: src/tr.c:339
#, fuzzy
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses the last\n"
"specified SET, and occurs after translation or deletion.\n"
msgstr ""
"\n"
"仅在SET1 和SET2 都给出，同时没有-d 选项的时候才会进行替换。\n"
"仅在替换时才可能用到-t 选项。如果需要SET2 将被通过在末尾添加原来的末字符的方"
"式\n"
"补充到同SET1 等长。SET2 中多余的字符将被省略。只有[:lower:] 和[:upper:]\n"
"以升序展开字符；在用于替换时的SET2 中以成对表示大小写转换。-s 作用于SET1，既"
"不\n"
"替换也不删除，否则在替换或展开后使用SET2 缩减。\n"

#: src/tr.c:507
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"警告：含义不清的八进制内容 \\%c%c%c 已被视作为双字节序列 \\0%c%c, %c 处理"

#: src/tr.c:516
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr "警告：在字符串结尾使用为转义的反斜杠是一种不可移植的做法"

#: src/tr.c:666
#, fuzzy, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr "\"%s-%s\"的结束点范围序列已经过反转处理"

#: src/tr.c:812
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "在参数结构 [c*n] 中有无效的重复次数%s"

#: src/tr.c:888
#, c-format
msgid "missing character class name '[::]'"
msgstr "缺失字符种类名\"[::]\""

#: src/tr.c:891
#, c-format
msgid "missing equivalence class character '[==]'"
msgstr "缺失类型等值的字符\"[==]\""

#: src/tr.c:906
#, c-format
msgid "invalid character class %s"
msgstr "无效的字符类型%s"

#: src/tr.c:925
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s：同类操作数必须是单个字符"

#: src/tr.c:1205
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "[:upper:] 和/或[:lower:] 的结构对齐不完整"

#: src/tr.c:1309
msgid "too many characters in set"
msgstr "设置中的字符数量过多"

#: src/tr.c:1393
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr "当字符串1 长度大于字符串2时，后者不能以字符类结尾"

#: src/tr.c:1449
msgid "the [c*] repeat construct may not appear in string1"
msgstr "在字符串1 中不能出现[c*] 结构的重复次数声明"

#: src/tr.c:1459
msgid "only one [c*] repeat construct may appear in string2"
msgstr "在字符串2 中只能出现一次[c*] 结构的重复次数声明"

#: src/tr.c:1467
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "在替换操作中字符串2 里不能出现表达式[=c=]"

#: src/tr.c:1474
#, fuzzy
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""
"当进行替换操作时，字符串2 里只能出现一种字符类型，即\"upper\"和\"lower\""

#: src/tr.c:1489
msgid "when not truncating set1, string2 must be non-empty"
msgstr "当不截断设置1 时，字符串2 不能为空"

#: src/tr.c:1498
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr "当以反相模式替换字符类型时，字符串2 必须将所有字符映射到一个字域"

#: src/tr.c:1507
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "当进行替换操作时[c*] 结构的参数只能出现在字符串2 中"

#: src/tr.c:1759
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr "当同时重复删除和缩减时必须给出两组字符串。"

#: src/tr.c:1761
msgid "Two strings must be given when translating."
msgstr "当进行替换操作时必须给定两组字符串。"

#: src/tr.c:1771
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr "当进行不含缩减的删除操作时只能给定一组字符串。"

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [忽略任何命令行参数]\n"
"　或：%s 选项\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "以表示成功的状态值退出。"

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "以表示失败的状态值退出。"

#: src/truncate.c:70
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "用法：%s 选项... 文件...\n"

#: src/truncate.c:71
#, fuzzy
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the sparse extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""
"将文件缩减或扩展至指定大小。\n"
"\n"
"如果指定文件不存在则创建。\n"
"\n"
"如果指定文件超出指定大小则超出的数据将丢失。\n"
"如果指定文件小于指定大小则用0 补足。\n"
"\n"

#: src/truncate.c:83
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create\t不创建文件\n"

#: src/truncate.c:86
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr "  -o, --io-blocks\t将SIZE 视为IO 块数而不使用字节数\n"

#: src/truncate.c:89
#, fuzzy
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE bytes\n"
msgstr ""
"  -r, --reference=文件   使用此文件的大小\n"
"  -s, --size=大小\t使用此大小\n"

#: src/truncate.c:95
#, fuzzy
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""
"\n"
"指定大小也可使用以下前缀修饰：\n"
"\"+\" 增加，\"-\" 减少，\"<\" 至多，\">\" 至少，\n"
"\"/\" 小于等于原尺寸数字的指定数字的最小倍数，\"%\" 大于等于原尺寸数字的指定"
"数字的最大倍数。\n"
"译者注：当输入值为m，参考值为n 时，\n"
"\"/\" 运算的数学计算式为 m / n * n；\n"
"\"%\" 运算的数学计算式为( m + n - 1 ) / n * n\n"

#: src/truncate.c:124
#, fuzzy, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdPTR> byte blocks for file %s"
msgstr "在文件%3$s 的%1$<PRIdMAX> * %2$<PRIdMAX> 字节块中溢出"

#: src/truncate.c:145
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s 的文件大小为负数，无法使用"

#: src/truncate.c:155 src/truncate.c:348
#, c-format
msgid "cannot get the size of %s"
msgstr "无法获得%s 的大小"

#: src/truncate.c:179
#, c-format
msgid "overflow extending size of file %s"
msgstr "扩展文件%s 大小时溢出"

#: src/truncate.c:193
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "在%2$<PRIdMAX> 字节处截断%1$s 失败"

#: src/truncate.c:266
#, c-format
msgid "multiple relative modifiers specified"
msgstr "指定了多个相关修饰符"

#: src/truncate.c:275
msgid "Invalid number"
msgstr "无效的数字"

#: src/truncate.c:297
#, c-format
msgid "you must specify either %s or %s"
msgstr "您必须在 %s 或 %s 中指定一个"

#: src/truncate.c:304
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "您必须为 %2$s 中指定一个相关的 %1$s"

#: src/truncate.c:311
#, c-format
msgid "%s was specified but %s was not"
msgstr "已指定 %s 但未指定 %s"

#: src/truncate.c:368
#, c-format
msgid "cannot open %s for writing"
msgstr "无法打开 %s 以写入数据"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:40
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:82
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
msgstr ""
"用法：%s [选项] [文件]\n"
"对不完全排序的给定<文件>实行完整的列表排序。\n"

#: src/tsort.c:89 src/uptime.c:213
#, c-format
msgid "\n"
msgstr "\n"

#: src/tsort.c:475
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s：输入内容的行数为奇数"

#: src/tsort.c:521
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s：输入内容中含有循环段落："

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"显示出连接到当前标准输入的终端设备文件名。\n"
"\n"
"  -s, --silent, --quiet\t什么也不显示，只返回退出状态值\n"

#: src/tty.c:127
msgid "not a tty"
msgstr "不是一个 tty"

#: src/uname.c:125
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"输出一组系统信息。如果不跟随选项，则视为只附加 -s 选项。\n"
"\n"
"  -a, --all                以如下次序输出所有信息。其中若 -p 和\n"
"                             -i 的探测结果不可知则被省略：\n"
"  -s, --kernel-name        输出内核名称\n"
"  -n, --nodename           输出网络节点上的主机名\n"
"  -r, --kernel-release     输出内核发行号\n"

#: src/uname.c:134
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type (non-portable)\n"
"  -i, --hardware-platform  print the hardware platform (non-portable)\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     输出内核版本\n"
"  -m, --machine            输出主机的硬件架构名称\n"
"  -p, --processor          输出处理器类型（不可移植）\n"
"  -i, --hardware-platform  输出硬件平台或（不可移植）\n"
"  -o, --operating-system   输出操作系统名称\n"

#: src/uname.c:144
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"输出机器的体系结构。\n"
"\n"

#: src/uname.c:287
msgid "cannot get system name"
msgstr "无法获取系统名"

#: src/unexpand.c:82
msgid "Convert blanks in each FILE to tabs, writing to standard output.\n"
msgstr "将每个指定文件中的空白字符转换为制表符并写到标准输出。\n"

#: src/unexpand.c:89
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
msgstr ""
"  -a, --all        转换所有空格，包括但不只是起始空格\n"
"      --first-only  仅转换起始空格（覆盖-a 选项）\n"
"  -t, --tabs=N     设置制表符宽度为 N 字符而非默认的 8（启用 -a 选项）\n"

#: src/unexpand.c:306
msgid "tab stop value is too large"
msgstr "制表符限长过大"

#: src/uniq.c:166
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "用法：%s [选项]... [文件]\n"

#: src/uniq.c:170
#, fuzzy
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""
"从输入文件或者标准输入中筛选相邻的匹配行并写入到输出文件或标准输出。\n"
"\n"
"不附加任何选项时匹配行将在首次出现处被合并。\n"
"\n"

#: src/uniq.c:179
#, fuzzy
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines, one for each group\n"
msgstr ""
"  -c, --count\t\t在每行前加上表示相应行目出现次数的前缀编号\n"
"  -d, --repeated\t只输出重复的行\n"

#: src/uniq.c:183
msgid ""
"  -D                    print all duplicate lines\n"
"      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
"                                 with an empty line;\n"
"                                 METHOD={none(default),prepend,separate}\n"
msgstr ""

#: src/uniq.c:189
msgid "  -f, --skip-fields=N   avoid comparing the first N fields\n"
msgstr "  -f, --skip-fields=N   不要比较前 N 个域\n"

#: src/uniq.c:192
msgid ""
"      --group[=METHOD]  show all items, separating groups with an empty "
"line;\n"
"                          METHOD={separate(default),prepend,append,both}\n"
msgstr ""

#: src/uniq.c:196
msgid ""
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -i, --ignore-case     比较时忽略大小写差异\n"
"  -s, --skip-chars=N    不要比较起始 N 个字符\n"
"  -u, --unique          只输出不重复（内容唯一）的行\n"

#: src/uniq.c:204
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr "  -w, --check-chars=N\t对每行第N 个字符以后的内容不作对照\n"

#: src/uniq.c:209
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"若域中为先空字符(通常包括空格以及制表符)，然后非空字符，域中字符前的空字符将"
"被跳过。\n"

#: src/uniq.c:214
#, fuzzy
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
msgstr ""
"\n"
"提示：\"uniq\" 不会检查重复的行，除非它们是相邻的行。\n"
"您也许需要事先对输入排序，或使用 \"sort -u\" 而非 \"uniq\"。\n"
"另外，比较操作将服从 \"LC_COLLATE\" 环境变量所指定的规则。\n"

#: src/uniq.c:425
msgid "too many repeated lines"
msgstr "重复行过多"

#: src/uniq.c:600
msgid "invalid number of fields to skip"
msgstr "要略过的区块数量无效"

#: src/uniq.c:609
msgid "invalid number of bytes to skip"
msgstr "要略过的字节数量无效"

#: src/uniq.c:619
msgid "invalid number of bytes to compare"
msgstr "要对照的字节数量无效"

#: src/uniq.c:641
#, c-format
msgid "--group is mutually exclusive with -c/-d/-D/-u"
msgstr "--group 和 -c/-d/-D/-u 不兼容"

#: src/uniq.c:648
#, fuzzy, c-format
msgid "grouping and printing repeat counts is meaningless"
msgstr "同时输出重复的行和重复计数是没有意义的"

#: src/uniq.c:655
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "同时输出重复的行和重复计数是没有意义的"

#: src/unlink.c:45
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s 文件\n"
"　或：%s 选项\n"

#: src/unlink.c:48
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"调用 unlink 函数删除指定的文件。\n"
"\n"

#: src/uptime.c:126
msgid "couldn't get boot time"
msgstr "无法获取启动时间"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:137
msgid " %H:%M:%S  "
msgstr " %H:%M:%S  "

#: src/uptime.c:139
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:141
#, c-format
msgid "up ???? days ??:??,  "
msgstr "已启动 ???? 天 ??:??，"

#: src/uptime.c:145
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "已启动 %ld 天%2d:%02d，"

#: src/uptime.c:150
#, c-format
msgid "up  %2d:%02d,  "
msgstr "已启动 %2d:%02d，"

#: src/uptime.c:152
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu 个用户"

#: src/uptime.c:162
#, c-format
msgid ",  load average: %.2f"
msgstr "，平均负载：%.2f"

#: src/uptime.c:200
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"输出当前时间，系统启动时间，当前登录用户数以及最近1、5 和15 分钟系统运行\n"
"队列中的平均任务数。"

#: src/uptime.c:209
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr "  处于不可中断睡眠状态的程序同样影响系统平均负载。\n"

#: src/uptime.c:215
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"如果文件没有指定，则使用%s，%s 是通用的相关文件。\n"
"\n"

#: src/users.c:106
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"根据文件判断输出当前有谁正登录在系统上。\n"
"如果文件未予指定，则使用%s，%s 是通用的相关文件。\n"
"\n"

#: src/wc.c:123
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  A word is a non-zero-length sequence of\n"
"characters delimited by white space.\n"
msgstr ""
"打印对每个给定文件的新行、单词和字节计数的结果；如果指定了超过\n"
"一个文件，则还会打印一个总行数。此处的一个单词是指由空白字符分隔的\n"
"长度大于零的字符序列。\n"

#: src/wc.c:131
msgid ""
"\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"\n"
"输出每个指定文件的行数、单词计数和字节数，如果指定了\n"
"多于一个文件，继续给出所有相关数据的总计。如果没有指定\n"
"文件，或者文件为\"-\"，则从标准输入读取数据。\n"
"  -c, --bytes\t\t输出字节数统计\n"
"  -m, --chars\t\t输出字符数统计\n"
"  -l, --lines\t\t输出行数统计\n"

#: src/wc.c:139
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the maximum display width\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=文件 从指定文件读取以空字符（NUL）终止的名称；\n"
"                         如果该文件被指定为 - 则从标准输入读文件名\n"
"  -L, --max-line-length  显示最长行的长度\n"
"  -w, --words            显示单词计数\n"

#: src/who.c:213
msgid " old "
msgstr " 旧的 "

#: src/who.c:443
msgid "system boot"
msgstr "系统引导"

#: src/who.c:451 src/who.c:453
msgid "id="
msgstr "id="

#: src/who.c:466 src/who.c:471
msgid "term="
msgstr "终端="

#: src/who.c:468 src/who.c:472
msgid "exit="
msgstr "退出="

#: src/who.c:489
msgid "LOGIN"
msgstr "登录"

#: src/who.c:509
msgid "clock change"
msgstr "时钟更改"

#: src/who.c:521 src/who.c:522
msgid "run-level"
msgstr "运行级别"

#: src/who.c:525 src/who.c:526
msgid "last="
msgstr "最近="

#: src/who.c:557
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"# 用户数=%lu\n"

#: src/who.c:563
msgid "NAME"
msgstr "名称"

#: src/who.c:563
msgid "LINE"
msgstr "线路"

#: src/who.c:563
msgid "TIME"
msgstr "时间"

#: src/who.c:563
msgid "IDLE"
msgstr "空闲"

#: src/who.c:564
msgid "PID"
msgstr "进程号"

#: src/who.c:564
msgid "COMMENT"
msgstr "备注"

#: src/who.c:564
msgid "EXIT"
msgstr "退出"

#: src/who.c:644
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "用法：%s [选项]... [ 文件 | 参数1 参数2 ]\n"

#: src/who.c:645
msgid "Print information about users who are currently logged in.\n"
msgstr "显示当前已登录的用户信息。\n"

#: src/who.c:648
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all\t\t等于-b -d --login -p -r -t -T -u 选项的组合\n"
"  -b, --boot\t\t上次系统启动时间\n"
"  -d, --dead\t\t显示已死的进程\n"
"  -H, --heading\t输出头部的标题列\n"

#: src/who.c:655
msgid "  -l, --login       print system login processes\n"
msgstr "  -l，--login\t\t显示系统登录进程\n"

#: src/who.c:658
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup\t\t尝试通过 DNS 查验主机名\n"
"  -m\t\t\t只面对和标准输入有直接交互的主机和用户\n"
"  -p, --process\t显示由 init 进程衍生的活动进程\n"

#: src/who.c:663
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count\t\t列出所有已登录用户的登录名与用户数量\n"
"  -r, --runlevel\t显示当前的运行级别\n"
"  -s, --short\t\t只显示名称、线路和时间(默认)\n"

#: src/who.c:669
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg\t用+，- 或 ? 标注用户消息状态\n"
"  -u, --users\t\t列出已登录的用户\n"
"      --message\t等于-T\n"
"      --writable\t等于-T\n"

#: src/who.c:677
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""
"\n"
"如果文件未被指定，则使用%s。%s 是通用的相关文件。\n"
"如果给定了参数1和参数2，则假定同时启用了 -m 参数：常见的参数例子如\n"
"\"am i\" 或 \"mom likes\"。\n"

#: src/whoami.c:45
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"显示与当前的有效用户ID 相关联的用户名。\n"
"与id -un 相同。\n"
"\n"

#: src/whoami.c:86
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "无法找到 ID 为 %lu 的用户的名称"

#: src/yes.c:41
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"用法：%s [字符串]...\n"
"　或：%s 选项\n"

#: src/yes.c:47
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
"重复输出一行指定的字符串，或者重复输出\"y\"。\n"
"\n"

#~ msgid "%s home page: <https://www.gnu.org/software/%s/>\n"
#~ msgstr "%s 项目主页：<https://www.gnu.org/software/%s/>\n"

#~ msgid ""
#~ "CAUTION: Note that shred relies on a very important assumption:\n"
#~ "that the file system overwrites data in place.  This is the traditional\n"
#~ "way to do things, but many modern file system designs do not satisfy "
#~ "this\n"
#~ "assumption.  The following are examples of file systems on which shred "
#~ "is\n"
#~ "not effective, or is not guaranteed to be effective in all file system "
#~ "modes:\n"
#~ "\n"
#~ msgstr ""
#~ "警告：请注意使用shred 时有一个很重要的条件：\n"
#~ "文件系统会在原来的位置覆盖指定的数据。传统的文件系统符合此条件，但许多现"
#~ "代\n"
#~ "的文件系统都不符合条件。以下是会令shred 无效或不担保一定有效的文件系统的\n"
#~ "例子：\n"
#~ "\n"

#~ msgid ""
#~ "* log-structured or journaled file systems, such as those supplied with\n"
#~ "AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)\n"
#~ "\n"
#~ "* file systems that write redundant data and carry on even if some "
#~ "writes\n"
#~ "fail, such as RAID-based file systems\n"
#~ "\n"
#~ "* file systems that make snapshots, such as Network Appliance's NFS "
#~ "server\n"
#~ "\n"
#~ msgstr ""
#~ "* 有纪录结构或是日志式文件系统，如AIX 及Solaris 使用的文件系统 (以及\n"
#~ "   JFS、ReiserFS、XFS、Ext3 等)\n"
#~ "\n"
#~ "* 会重复写入数据，及即使一部份写入动作失败后仍可继续的文件系统，如使用\n"
#~ "   RAID 的文件系统\n"
#~ "\n"
#~ "* 会不时进行快照记录的文件系统，像Network Applicance 的NFS 服务器\n"
#~ "\n"

#~ msgid ""
#~ "* file systems that cache in temporary locations, such as NFS\n"
#~ "version 3 clients\n"
#~ "\n"
#~ "* compressed file systems\n"
#~ "\n"
#~ msgstr ""
#~ "* 文件系统是存放于缓存位置，比如NFS 第三版用户端\n"
#~ "\n"
#~ "* 压缩文件系统\n"
#~ "\n"

#~ msgid ""
#~ "In the case of ext3 file systems, the above disclaimer applies\n"
#~ "(and shred is thus of limited effectiveness) only in data=journal mode,\n"
#~ "which journals file data in addition to just metadata.  In both the\n"
#~ "data=ordered (default) and data=writeback modes, shred works as usual.\n"
#~ "Ext3 journaling modes can be changed by adding the data=something option\n"
#~ "to the mount options for a particular file system in the /etc/fstab "
#~ "file,\n"
#~ "as documented in the mount man page (man mount).\n"
#~ "\n"
#~ msgstr ""
#~ "在Ext3 文件系统中，以上免责声明仅适用于启用了data=journal 模式的情况，\n"
#~ "此时文件日志记录了附加的元数据 shred 的作用将受到影响。在data=ordered(默"
#~ "认)\n"
#~ "或data=writeback 模式下shred 仍然有效。\n"
#~ "Ext3 日志模式可通过向/etc/fstab 的挂载选项中添加data=something 进行设"
#~ "置，\n"
#~ "您可以查看mount 的man 页面以获得详细信息。\n"
#~ "\n"

#~ msgid ""
#~ "In addition, file system backups and remote mirrors may contain copies\n"
#~ "of the file that cannot be removed, and that will allow a shredded file\n"
#~ "to be recovered later.\n"
#~ msgstr ""
#~ "另外，文件系统备份和远程镜像可能会\n"
#~ "包含不能被删除的文件副本，这将会\n"
#~ "允许碎片文件被恢复。\n"

#~ msgid "overflow rounding up size of file %s"
#~ msgstr "处理大于等于文件%s 的指定大小的最大倍数时溢出"

#, fuzzy
#~| msgid ""
#~| "\n"
#~| "K may have a multiplier suffix:\n"
#~| "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~| "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ msgid ""
#~ "\n"
#~ "NUM may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ msgstr ""
#~ "\n"
#~ "K 后面可以跟乘号:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, 对于T, P, E, Z, Y 同样适用。\n"

#~ msgid "Usage: %s [OPTION]... [USER]\n"
#~ msgstr "用法: %s [选项]... [用户]\n"

#~ msgid "%s: option '--%s' doesn't allow an argument\n"
#~ msgstr "%s：选项\"--%s\"不允许带参数\n"

#~ msgid "%s: unrecognized option '--%s'\n"
#~ msgstr "%s：无法识别的选项\"--%s\"\n"

#~ msgid "%s: option '-W %s' doesn't allow an argument\n"
#~ msgstr "%s：选项\"-W %s\"不允许带参数\n"

#~ msgid "%s: option '-W %s' requires an argument\n"
#~ msgstr "%s：选项\"-W %s\"必需带参数\n"

#~ msgid "stdin"
#~ msgstr "标准输入"

#~ msgid "stdout"
#~ msgstr "标准输出"

#~ msgid "stderr"
#~ msgstr "标准错误"

#~ msgid "unknown stream"
#~ msgstr "未知流"

#~ msgid "failed to reopen %s with mode %s"
#~ msgstr "以%s 模式重新打开%s 失败"

#, fuzzy
#~| msgid "failed to set supplemental group(s)"
#~ msgid "failed to %s supplemental groups"
#~ msgstr "设置附加组失败"

#~ msgid "empty %s not allowed"
#~ msgstr "不允许空的%s"

#~ msgid "%s: invalid number"
#~ msgstr "%s：无效数字"

#~ msgid "  nocache   discard cached data\n"
#~ msgstr "  nocache\t丢弃缓存数据\n"

#, fuzzy
#~| msgid ""
#~| "\n"
#~| "Sending a %s signal to a running `dd' process makes it\n"
#~| "print I/O statistics to standard error and then resume copying.\n"
#~| "\n"
#~| "  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
#~| "  $ kill -%s $pid; sleep 1; kill $pid\n"
#~| "  18335302+0 records in\n"
#~| "  18335302+0 records out\n"
#~| "  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
#~| "\n"
#~| "Options are:\n"
#~| "\n"
#~ msgid ""
#~ "\n"
#~ "Sending a %s signal to a running 'dd' process makes it\n"
#~ "print I/O statistics to standard error and then resume copying.\n"
#~ "\n"
#~ "  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
#~ "  $ kill -%s $pid; sleep 1; kill $pid\n"
#~ "  18335302+0 records in\n"
#~ "  18335302+0 records out\n"
#~ "  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
#~ "\n"
#~ "Options are:\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "对运行中的\"dd\"进程发送一个%s 信号会使得\n"
#~ "I/O 的统计信息被打印到标准错误设备然后恢复复制操作。\n"
#~ "\n"
#~ "  $ dd if=/dev/zero of=/dev/null& pid=$!\n"
#~ "  $ kill -%s $pid; sleep 1; kill $pid\n"
#~ "  18335302+0 records in\n"
#~ "  18335302+0 records out\n"
#~ "  9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s\n"
#~ "\n"
#~ "可用选项有：\n"
#~ "\n"

#~ msgid "Infinity B"
#~ msgstr "无穷量 B"

#~ msgid ", %g s, %s/s\n"
#~ msgstr "，%g 秒，%s/秒\n"

#~ msgid "syntax error"
#~ msgstr "语法错误"

#~ msgid "%s: %s is so large that it is not representable"
#~ msgstr "%s：%s 过大以至于无法表示"

#~ msgid "number of lines"
#~ msgstr "参数数目错误"

#~ msgid "number of bytes"
#~ msgstr "字节数"

#~ msgid "error initializing month strings"
#~ msgstr "初始化月份字符串出错"

#, fuzzy
#~| msgid ""
#~| "      --time-style=STYLE     with -l, show times using style STYLE:\n"
#~| "                             full-iso, long-iso, iso, locale, +FORMAT.\n"
#~| "                             FORMAT is interpreted like `date'; if "
#~| "FORMAT is\n"
#~| "                             FORMAT1<newline>FORMAT2, FORMAT1 applies "
#~| "to\n"
#~| "                             non-recent files and FORMAT2 to recent "
#~| "files;\n"
#~| "                             if STYLE is prefixed with `posix-', STYLE\n"
#~| "                             takes effect only outside the POSIX locale\n"
#~ msgid ""
#~ "      --time-style=STYLE     with -l, show times using style STYLE:\n"
#~ "                               full-iso, long-iso, iso, locale, or "
#~ "+FORMAT;\n"
#~ "                               FORMAT is interpreted like in 'date'; if "
#~ "FORMAT\n"
#~ "                               is FORMAT1<newline>FORMAT2, then FORMAT1 "
#~ "applies\n"
#~ "                               to non-recent files and FORMAT2 to recent "
#~ "files;\n"
#~ "                               if STYLE is prefixed with 'posix-', STYLE\n"
#~ "                               takes effect only outside the POSIX "
#~ "locale\n"
#~ msgstr ""
#~ "      --time-style=STYLE\t和-l 同时使用时根据STYLE 代表的格式显示时间：\n"
#~ "\t\t\t\tfull-iso、iso、locale、posix-iso、+FORMAT。\n"
#~ "\t\t\t\tFORMAT 即是\"date\"所用的时间格式；如果FORMAT\n"
#~ "\t\t\t\t是FORMAT1<换行>FORMAT2，FORMAT1 适用于较旧\n"
#~ "\t\t\t\t的文件而FORMAT2 适用于较新的文件；如果STYLE\n"
#~ "\t\t\t\t以\"posix-\"开头，则STYLE 仅在POSIX 语系之外\n"
#~ "\t\t\t\t生效。\n"
#~ "  -t\t\t\t\t根据修改时间排序\n"
#~ "  -T, --tabsize=宽度\t指定制表符(Tab)的宽度，而非8 个字符\n"

#~ msgid "failed to set the copy of stderr to close on exec"
#~ msgstr "执行时关闭标准错误失败"

#~ msgid "%s: invalid number to ignore"
#~ msgstr "%s：无效的忽略数"

#~ msgid ""
#~ "\n"
#~ "-t is implied if PAGE_LENGTH <= 10.  With no FILE, or when FILE is -, "
#~ "read\n"
#~ "standard input.\n"
#~ msgstr ""
#~ "\n"
#~ "如果页长<=10 则使用-t 选项。如果FILE 没有定义，\n"
#~ "或者FILE 是\"-\"，则从标准输入读入。\n"

#, fuzzy
#~| msgid ""
#~| "\n"
#~| "With no FILE, or when FILE is -, read standard input.\n"
#~ msgid ""
#~ "\n"
#~ "With no FILE, or when FILE is -, read standard input.  Default is '-"
#~ "F /'.\n"
#~ msgstr ""
#~ "\n"
#~ "如果没有指定文件，或者文件为\"-\"，则从标准输入读取。\n"

#~ msgid "%s: invalid number of bytes"
#~ msgstr "%s：无效的字节数"

#~ msgid "%s: invalid number of lines"
#~ msgstr "%s：无效的行数"

#~ msgid ""
#~ " * lnext CHAR    CHAR will enter the next character quoted\n"
#~ "   quit CHAR     CHAR will send a quit signal\n"
#~ " * rprnt CHAR    CHAR will redraw the current line\n"
#~ "   start CHAR    CHAR will restart the output after stopping it\n"
#~ msgstr ""
#~ " * lnext 字符\t用于输入下一个引用文字的字符\n"
#~ "   quit 字符\t用于发送退出信号的字符\n"
#~ " * rprnt 字符\t用于重绘当前行的字符\n"
#~ "   start 字符\t在停止后重新开启输出的字符\n"

#, fuzzy
#~| msgid ""
#~| "\n"
#~| "Control settings:\n"
#~| "   [-]clocal     disable modem control signals\n"
#~| "   [-]cread      allow input to be received\n"
#~| " * [-]crtscts    enable RTS/CTS handshaking\n"
#~| "   csN           set character size to N bits, N in [5..8]\n"
#~ msgid ""
#~ "\n"
#~ "Control settings:\n"
#~ "   [-]clocal     disable modem control signals\n"
#~ "   [-]cread      allow input to be received\n"
#~ " * [-]crtscts    enable RTS/CTS handshaking\n"
#~ " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
#~ "   csN           set character size to N bits, N in [5..8]\n"
#~ msgstr ""
#~ "\n"
#~ "控制设置：\n"
#~ "   [-]clocal\t禁用调制解调器控制信号\n"
#~ "   [-]cread\t允许接收输入\n"
#~ " * [-]crtscts\t启用RTS/CTS 握手\n"
#~ "   csN\t\t设置字符大小为N 位，N 的范围为5 到8\n"

#~ msgid ""
#~ "\n"
#~ "Output settings:\n"
#~ " * bsN           backspace delay style, N in [0..1]\n"
#~ " * crN           carriage return delay style, N in [0..3]\n"
#~ " * ffN           form feed delay style, N in [0..1]\n"
#~ " * nlN           newline delay style, N in [0..1]\n"
#~ msgstr ""
#~ "\n"
#~ "输出设置：\n"
#~ " * bsN\t\t退格延迟的风格，N 的值为0 至1\n"
#~ " * crN\t\t回车延迟的风格，N 的值为0 至3\n"
#~ " * ffN\t\t换页延迟的风格，N 的值为0 至1\n"
#~ " * nlN\t\t换行延迟的风格，N 的值为0 至1\n"

#, fuzzy
#~| msgid ""
#~| " * [-]ocrnl      translate carriage return to newline\n"
#~| " * [-]ofdel      use delete characters for fill instead of null "
#~| "characters\n"
#~| " * [-]ofill      use fill (padding) characters instead of timing for "
#~| "delays\n"
#~| " * [-]olcuc      translate lowercase characters to uppercase\n"
#~| " * [-]onlcr      translate newline to carriage return-newline\n"
#~| " * [-]onlret     newline performs a carriage return\n"
#~ msgid ""
#~ " * [-]ocrnl      translate carriage return to newline\n"
#~ " * [-]ofdel      use delete characters for fill instead of NUL "
#~ "characters\n"
#~ " * [-]ofill      use fill (padding) characters instead of timing for "
#~ "delays\n"
#~ " * [-]olcuc      translate lowercase characters to uppercase\n"
#~ " * [-]onlcr      translate newline to carriage return-newline\n"
#~ " * [-]onlret     newline performs a carriage return\n"
#~ msgstr ""
#~ " * [-]ocrnl\t将回车转换为换行符\n"
#~ " * [-]ofdel\t使用删除字符代替空字符作填充\n"
#~ " * [-]ofill\t延迟时使用字符填充代替定时器同步\n"
#~ " * [-]olcuc\t转换小写字母为大写\n"
#~ " * [-]onlcr\t将换行符转换为回车\n"
#~ " * [-]onlret\t使得换行符的行为表现和回车相同\n"

#~ msgid ""
#~ " * [-]onocr      do not print carriage returns in the first column\n"
#~ "   [-]opost      postprocess output\n"
#~ " * tabN          horizontal tab delay style, N in [0..3]\n"
#~ " * tabs          same as tab0\n"
#~ " * -tabs         same as tab3\n"
#~ " * vtN           vertical tab delay style, N in [0..1]\n"
#~ msgstr ""
#~ " * [-]onocr\t不在第一列输出回车\n"
#~ "   [-]opost\t后续进程输出\n"
#~ " * tabN\t水平制表符延迟的风格，N 的值为0 至3\n"
#~ " * tabs\t等于tab0\n"
#~ " * -tabs\t等于tab3\n"
#~ " * vtN\t\t垂直制表符延迟的风格，N 的值为0 至1\n"

#, fuzzy
#~| msgid ""
#~| " * [-]ctlecho    echo control characters in hat notation (`^c')\n"
#~| "   [-]echo       echo input characters\n"
#~| " * [-]echoctl    same as [-]ctlecho\n"
#~| "   [-]echoe      same as [-]crterase\n"
#~| "   [-]echok      echo a newline after a kill character\n"
#~ msgid ""
#~ " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
#~ "   [-]echo       echo input characters\n"
#~ " * [-]echoctl    same as [-]ctlecho\n"
#~ "   [-]echoe      same as [-]crterase\n"
#~ "   [-]echok      echo a newline after a kill character\n"
#~ msgstr ""
#~ " * [-]ctlecho\t在头字符中输出控制符号(\"^c\")\n"
#~ "   [-]echo\t回显输入字符\n"
#~ " * [-]echoctl\t等于[-]ctlecho\n"
#~ "   [-]echoe    等于[-]crterase\n"
#~ "   [-]echok\t在每清除一个字符后输出一次换行\n"

#, fuzzy
#~| msgid ""
#~| " * [-]echoke     same as [-]crtkill\n"
#~| "   [-]echonl     echo newline even if not echoing other characters\n"
#~| " * [-]echoprt    echo erased characters backward, between `\\' and '/'\n"
#~| "   [-]icanon     enable erase, kill, werase, and rprnt special "
#~| "characters\n"
#~| "   [-]iexten     enable non-POSIX special characters\n"
#~ msgid ""
#~ " * [-]echoke     same as [-]crtkill\n"
#~ "   [-]echonl     echo newline even if not echoing other characters\n"
#~ " * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
#~ "   [-]icanon     enable erase, kill, werase, and rprnt special "
#~ "characters\n"
#~ "   [-]iexten     enable non-POSIX special characters\n"
#~ msgstr ""
#~ " * [-]echoke\t等于[-]crtkill 意义相同\n"
#~ "   [-]echonl\t即使没有回显任何其它字符也输出换行\n"
#~ " * [-]echoprt\t在\"\\\"和\"/\"之间向后显示擦除的字符\n"
#~ "   [-]icanon\t启用erase、kill、werase 和rprnt 等特殊字符\n"
#~ "   [-]iexten\t允许POSIX 标准以外的特殊字符\n"

#~ msgid ""
#~ "   dec           same as echoe echoctl echoke -ixany intr ^c erase 0177\n"
#~ "                 kill ^u\n"
#~ " * [-]decctlq    same as [-]ixany\n"
#~ "   ek            erase and kill characters to their default values\n"
#~ "   evenp         same as parenb -parodd cs7\n"
#~ msgstr ""
#~ "   dec\t\t等于echoe echoctl echoke -ixany intr ^c erase 0177 kill ^u\n"
#~ " * [-]decctlq\t等于[-]ixany\n"
#~ "   ek\t\t清除所有字符，将它们回溯为默认值\n"
#~ "   evenp\t等于parenb -parodd cs7\n"

#~ msgid ""
#~ "   -evenp        same as -parenb cs8\n"
#~ " * [-]lcase      same as xcase iuclc olcuc\n"
#~ "   litout        same as -parenb -istrip -opost cs8\n"
#~ "   -litout       same as parenb istrip opost cs7\n"
#~ "   nl            same as -icrnl -onlcr\n"
#~ "   -nl           same as icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"
#~ msgstr ""
#~ "   -evenp\t等于-parenb cs8\n"
#~ " * [-]lcase\t等于xcase iuclc olcuc\n"
#~ "   litout\t等于-parenb -istrip -opost cs8\n"
#~ "   -litout\t等于parenb istrip opost cs7\n"
#~ "   nl\t\t等于-icrnl -onlcr\n"
#~ "   -nl\t\t等于icrnl -inlcr -igncr onlcr -ocrnl -onlret\n"

#~ msgid ""
#~ "Force changed blocks to disk, update the super block.\n"
#~ "\n"
#~ msgstr ""
#~ "强迫将已更改的数据写入磁盘，并更新超级块。\n"
#~ "\n"

#~ msgid "ignoring all arguments"
#~ msgstr "忽略任何参数"

#~ msgid "For complete documentation, run: info coreutils '%s invocation'\n"
#~ msgstr "要获取完整文档，请运行：info coreutils '%s invocation'\n"

#, fuzzy
#~| msgid ""
#~| "\n"
#~| "If the first character of K (the number of bytes or lines) is a `+',\n"
#~| "print beginning with the Kth item from the start of each file, "
#~| "otherwise,\n"
#~| "print the last K items in the file.  K may have a multiplier suffix:\n"
#~| "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~| "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~| "\n"
#~ msgid ""
#~ "\n"
#~ "If the first character of K (the number of bytes or lines) is a '+',\n"
#~ "print beginning with the Kth item from the start of each file, "
#~ "otherwise,\n"
#~ "print the last K items in the file.  K may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ "\n"
#~ msgstr ""
#~ "\n"
#~ "如果字节数或行数K 的第一个字符是\"+\"，输出从文件开始第K 个项目，否则输出"
#~ "文件\n"
#~ "最后K 个项目。K 可以使用一下几种单位之一：\n"
#~ "b 512，kB 1000，K 1024，MB 1000*1000，M 1024*1024,\n"
#~ "GB 1000*1000*1000，G 1024*1024*1024，以及T，P，E，Z，Y。\n"
#~ "\n"

#, fuzzy
#~| msgid "%s has been replaced with a remote file. giving up on this name"
#~ msgid "%s has been replaced with a symbolic link. giving up on this name"
#~ msgstr "%s 已被替换为一个远程文件，放弃跟踪"

#~ msgid "%s has been replaced with a remote file. giving up on this name"
#~ msgstr "%s 已被替换为一个远程文件，放弃跟踪"

#~ msgid "error monitoring inotify event"
#~ msgstr "监视inotify 事件出错"

#~ msgid "number in %s is too large"
#~ msgstr "%s 中的数字过大"

#~ msgid "%s: invalid number of seconds"
#~ msgstr "%s：无效的秒数"

#~ msgid "%s: cannot find name for user ID %lu\n"
#~ msgstr "%s：无法找到用户ID 为%lu 的用户名\n"

#~ msgid ""
#~ "\n"
#~ "Examples:\n"
#~ "  %s /usr/bin/sort       Output \"sort\".\n"
#~ "  %s include/stdio.h .h  Output \"stdio\".\n"
#~ msgstr ""
#~ "\n"
#~ "示例：\n"
#~ "  %s /usr/bin/sort       输出\"sort\"。\n"
#~ "  %s include/stdio.h .h  输出\"stdio\"。\n"

#~ msgid ""
#~ "Change the group of each FILE to GROUP.\n"
#~ "With --reference, change the group of each FILE to that of RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "将每个指定文件的所属组设置为指定值。\n"
#~ "如果使用 --reference，则将每个文件的所属组设置为与指定参考文件相同。\n"
#~ "\n"
#~ "  -c, --changes\t\t\t类似 --verbose，但只在有更改时才显示结果\n"
#~ "      --dereference\t\t影响符号链接所指示的对象，而非符号链接本身(默认"
#~ "值)\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's group rather than specifying a\n"
#~ "                         GROUP value\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet\t\t去除大部份错误信息\n"
#~ "      --reference=RFILE\t\t使用参考文件的所属组，而非指定值\n"
#~ "  -R, --recursive\t\t递归处理所有的文件及子目录\n"
#~ "  -v, --verbose\t\t\t为处理的所有文件显示诊断信息\n"
#~ "\n"

#~ msgid ""
#~ "Change the mode of each FILE to MODE.\n"
#~ "\n"
#~ "  -c, --changes           like verbose but report only when a change is "
#~ "made\n"
#~ msgstr ""
#~ "将每个文件的模式更改为指定值。\n"
#~ "\n"
#~ "  -c, --changes\t\t类似 --verbose，但只在有更改时才显示结果\n"

#~ msgid ""
#~ "      --no-preserve-root  do not treat `/' specially (the default)\n"
#~ "      --preserve-root     fail to operate recursively on `/'\n"
#~ msgstr ""
#~ "      --no-preserve-root\t不特殊对待根目录(默认)\n"
#~ "      --preserve-root\t\t禁止对根目录进行递归操作\n"

#~ msgid ""
#~ "  -f, --silent, --quiet   suppress most error messages\n"
#~ "  -v, --verbose           output a diagnostic for every file processed\n"
#~ "      --reference=RFILE   use RFILE's mode instead of MODE values\n"
#~ "  -R, --recursive         change files and directories recursively\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet\t去除大部份的错误信息\n"
#~ "  -v, --verbose\t\t为处理的所有文件显示诊断信息\n"
#~ "      --reference=参考文件\t使用指定参考文件的模式，而非自行指定权限模式\n"
#~ "  -R, --recursive\t\t以递归方式更改所有的文件及子目录\n"

#~ msgid ""
#~ "Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
#~ "With --reference, change the owner and group of each FILE to those of "
#~ "RFILE.\n"
#~ "\n"
#~ "  -c, --changes          like verbose but report only when a change is "
#~ "made\n"
#~ "      --dereference      affect the referent of each symbolic link (this "
#~ "is\n"
#~ "                         the default), rather than the symbolic link "
#~ "itself\n"
#~ msgstr ""
#~ "更改每个文件的所有者和/或所属组。\n"
#~ "当使用 --referebce 参数时，将文件的所有者和所属组更改为与指定参考文件相"
#~ "同。\n"
#~ "\n"
#~ "  -c, --changes\t\t\t类似 verbose，但只在有更改时才显示结果\n"
#~ "      --dereference\t\t受影响的是符号链接所指示的对象，而非符号链接本身\n"

#~ msgid ""
#~ "  -f, --silent, --quiet  suppress most error messages\n"
#~ "      --reference=RFILE  use RFILE's owner and group rather than\n"
#~ "                         specifying OWNER:GROUP values\n"
#~ "  -R, --recursive        operate on files and directories recursively\n"
#~ "  -v, --verbose          output a diagnostic for every file processed\n"
#~ "\n"
#~ msgstr ""
#~ "  -f, --silent, --quiet\t去除大部份的错误信息\n"
#~ "      --reference=参考文件\t使用参考文件的所属组，而非指定值\n"
#~ "  -R, --recursive\t\t递归处理所有的文件及子目录\n"
#~ "  -v, --verbose\t\t\t为处理的所有文件显示诊断信息\n"
#~ "\n"

#~ msgid "failed to set additional groups"
#~ msgstr "设置附加组失败"

#~ msgid "reading %s"
#~ msgstr "正在读入%s"

#~ msgid "writing %s"
#~ msgstr "正在写入%s"

#~ msgid "failed to get file system create context"
#~ msgstr "获取文件系统创建环境失败"

#~ msgid "closing %s"
#~ msgstr "正在关闭 %s"

#~ msgid "cannot create link %s"
#~ msgstr "无法创建链接%s"

#~ msgid "accessing %s"
#~ msgstr "正在访问%s"

#~ msgid ""
#~ "Display the current time in the given FORMAT, or set the system date.\n"
#~ "\n"
#~ "  -d, --date=STRING         display time described by STRING, not `now'\n"
#~ "  -f, --file=DATEFILE       like --date once for each line of DATEFILE\n"
#~ msgstr ""
#~ "以给定的格式显示当前时间，或是设置系统日期。\n"
#~ "\n"
#~ "  -d,--date=字符串\t\t显示指定字符串所描述的时间，而非当前时间\n"
#~ "  -f,--file=日期文件\t\t类似--date，从日期文件中按行读入时间描述\n"

#~ msgid "opening %s"
#~ msgstr "正在打开%s"

#~ msgid ""
#~ "Usage: %s NAME\n"
#~ "  or:  %s OPTION\n"
#~ msgstr ""
#~ "用法：%s 名称\n"
#~ "　或：%s 选项\n"

#~ msgid ""
#~ "  -x, --one-file-system    skip directories on different file systems\n"
#~ "  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
#~ "      --exclude=PATTERN    exclude files that match PATTERN\n"
#~ "  -d, --max-depth=N     print the total for a directory (or file, with --"
#~ "all)\n"
#~ "                          only if it is N or fewer levels below the "
#~ "command\n"
#~ "                          line argument;  --max-depth=0 is the same as\n"
#~ "                          --summarize\n"
#~ msgstr ""
#~ "  -x, --one-file-system\t\t跳过处于不同文件系统之上的目录\n"
#~ "  -X, --exclude-from=文件\t排除与指定文件中描述的模式相符的文件\n"
#~ "      --exclude=PATTERN\t\t排除与PATTERN 中描述的模式相符的文件\n"
#~ "      --max-depth=N\t显示目录总计(与--all 一起使用计算文件)\n"
#~ "\t\t\t当N 为指定数值时计算深度为N；\n"
#~ "\t\t\t--max-depth=0 等于--summarize\n"

#~ msgid "using arbitrary-precision arithmetic"
#~ msgstr "使用任意精度运算"

#~ msgid "using single-precision arithmetic"
#~ msgstr "使用单精度运算"

#~ msgid "%s: cannot lseek back to original position"
#~ msgstr "%s：lseek 无法回溯到初始位置"

#~ msgid "cannot reposition file pointer for %s"
#~ msgstr "无法复位%s 的文件指针"

#~ msgid "Usage: %s [OPTION]... [USERNAME]\n"
#~ msgstr "用法：%s [选项]... [用户名]\n"

#~ msgid ""
#~ "WARNING: --preserve_context is deprecated; use --preserve-context instead"
#~ msgstr "警告：不推荐使用--preserve_context，请使用--preserve-context"

#~ msgid ""
#~ "      --preserve-context  preserve SELinux security context\n"
#~ "  -Z, --context=CONTEXT  set SELinux security context of files and "
#~ "directories\n"
#~ msgstr ""
#~ "      --preserve-context\t保持SELinux 的安全环境\n"
#~ "  -Z, --context=CONTEXT\t\t设置文件和目录的SELinux 安全环境\n"

#~ msgid ""
#~ "  -Z, --context=CTX  set the SELinux security context of each NAME to "
#~ "CTX\n"
#~ msgstr ""
#~ "  -Z, --context=CTX  \t将每个创建的目录的SELinux 安全环境设置为CTX\n"

#~ msgid ""
#~ "  -Z, --context=CTX  set the SELinux security context of NAME to CTX\n"
#~ msgstr "  -Z, --context=CTX \t将对应名称文件的SELinux 安全环境设置为CTX\n"

#~ msgid "failed to redirect stderr to /dev/null"
#~ msgstr "重定向标准错误到/dev/null 失败"

#~ msgid ""
#~ "WARNING: --page-increment is deprecated; use --line-increment instead"
#~ msgstr "警告：不推荐使用--page-increment，请使用--line-increment"

#~ msgid "All arguments to long options are mandatory for short options.\n"
#~ msgstr "长选项必须用的参数在使用短选项时也是必须的。\n"

#~ msgid ""
#~ "  -A, --address-radix=RADIX   decide how file offsets are printed\n"
#~ "  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
#~ msgstr ""
#~ "  -A, --address-radix=初始偏移\t设置要显示的文件的初始偏移量\n"
#~ "  -j, --skip-bytes=字节数\t略过指定字节数的输入内容\n"

#~ msgid ""
#~ "\n"
#~ "RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
#~ "BYTES is hexadecimal with 0x or 0X prefix, and may have a multiplier "
#~ "suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ "Adding a z suffix to any type displays printable characters at the end of "
#~ "each\n"
#~ "output line.\n"
#~ msgstr ""
#~ "\n"
#~ "当 RADIX 为\"d\"时代表十进制，为\"o\"时代表八进制，为\"x\"时代表十六进"
#~ "制，\n"
#~ "\"n\"则代表无。\n"
#~ "BYTES 是以0x 或0X 为前缀的十六进制数，可能有以下几种后缀：\n"
#~ "b 512，kB 1000，K 1024，MB 1000*1000，M 1024*1024，\n"
#~ "GB 1000*1000*1000，G 1024*1024*1024，对于T，P，E，Z，Y 同样适用。\n"
#~ "为任何类型添加\"z\"后缀都将在每个输出行的行尾显示可显示字符\n"

#~ msgid ""
#~ "Option --string without a number implies 3; option --width without a "
#~ "number\n"
#~ "implies 32.  By default, od uses -A o -t oS -w16.\n"
#~ msgstr ""
#~ "不带数字的--string 选项代表3；不带数字的--width 选项代表32。\n"
#~ "默认情况下od 使用 -A o -t oS -w16 参数。\n"

#~ msgid ""
#~ "\n"
#~ "With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
#~ msgstr ""
#~ "\n"
#~ "如果不指定文件，或者文件为 \"-\"，程序将从标准输入读取数据。默认时隐含\n"
#~ "\"-F /\"选项。\n"

#~ msgid "Usage: %s [OPTION]... FILE\n"
#~ msgstr "用法：%s [选项]... 文件\n"

#~ msgid "cannot remove directory: %s"
#~ msgstr "无法删除目录：%s"

#~ msgid ""
#~ "Usage: %s [SHORT-OPTION]... USER COMMAND [ARGUMENT]...\n"
#~ "  or:  %s LONG-OPTION\n"
#~ msgstr ""
#~ "用法：%s [短选项]... 用户 命令 [参数]...\n"
#~ "　或：%s 长选项\n"

#~ msgid ""
#~ "Drop any supplemental groups, assume the user-ID and group-ID of the "
#~ "specified\n"
#~ "USER (numeric ID or user name), and run COMMAND with any specified "
#~ "ARGUMENTs.\n"
#~ "Exit with status 111 if unable to assume the required user and group ID.\n"
#~ "Otherwise, exit with the exit status of COMMAND.\n"
#~ "This program is useful only when run by root (user ID zero).\n"
#~ "\n"
#~ msgstr ""
#~ "使用指定的用户(数字ID 或者用户名) 替代原有用户ID 和组ID 运行连同参数的指定"
#~ "命令\n"
#~ "如果无法指定请求的用户和组ID 则以状态号111 退出，否则以所执行命令的终止状"
#~ "态号退出。\n"
#~ "此程序通常仅在使用root 运行时有用 (root 的用户ID 为0)。\n"

#~ msgid ""
#~ "  -g GID[,GID1...]  also set the primary group-ID to the numeric GID, "
#~ "and\n"
#~ "                    (if specified) supplemental group IDs to GID1, ...\n"
#~ msgstr ""
#~ "  -g GID[,GID1...]\t将主组ID 设置为指定的数字GID，如果指定了GID1，\n"
#~ "\t\t\t\t则同时添加这些附加组ID，...\n"

#~ msgid "unknown user-ID: %s"
#~ msgstr "未知的用户ID：%s"

#~ msgid "to use user-ID %s you need to use -g too"
#~ msgstr "您应当将-g 与用户ID %s 一起使用"

#~ msgid "cannot set group-ID to %lu"
#~ msgstr "无法设置组ID 为%lu"

#~ msgid "cannot set user-ID to %lu"
#~ msgstr "无法设置用户ID 为%lu"

#~ msgid "dup2 failed"
#~ msgstr "复制已打开文件描述符失败(dup2)"

#~ msgid "couldn't execute %s"
#~ msgstr "无法执行%s"

#~ msgid "couldn't execute %s -d"
#~ msgstr "无法执行%s -d"

#~ msgid "Password:"
#~ msgstr "密码："

#~ msgid "getpass: cannot open /dev/tty"
#~ msgstr "getpass：无法打开 /dev/tty"

#~ msgid "cannot set groups"
#~ msgstr "无法设置组"

#~ msgid "cannot set group id"
#~ msgstr "无法设置组ID"

#~ msgid "Usage: %s [OPTION]... [-] [USER [ARG]...]\n"
#~ msgstr "用法：%s [选项]... [-] [用户 [参数]... ]\n"

#~ msgid ""
#~ "Change the effective user id and group id to that of USER.\n"
#~ "\n"
#~ "  -, -l, --login               make the shell a login shell\n"
#~ "  -c, --command=COMMAND        pass a single COMMAND to the shell with -"
#~ "c\n"
#~ "  -f, --fast                   pass -f to the shell (for csh or tcsh)\n"
#~ "  -m, --preserve-environment   do not reset environment variables\n"
#~ "  -p                           same as -m\n"
#~ "  -s, --shell=SHELL            run SHELL if /etc/shells allows it\n"
#~ msgstr ""
#~ "更改有效用户ID 和组ID 为指定用户。\n"
#~ "\n"
#~ "  -, -l, --login\t\t使该shell 成为登录shell\n"
#~ "  -c, --command=命令\t\t向shell 传递单一命令\n"
#~ "  -f, --fast                   针对csh 或tcsh 传递-f\n"
#~ "  -m, --preserve-environment\t不重设环境变量\n"
#~ "  -p\t\t\t\t等于-m\n"
#~ "  -s, --shell=SHELL\t\t如果/etc/shells allows 则运行指定的SHELL\n"

#~ msgid ""
#~ "\n"
#~ "A mere - implies -l.   If USER not given, assume root.\n"
#~ msgstr ""
#~ "\n"
#~ "单独的\"-\"选项隐含了-l。如果不指定用户，则假设其为root。\n"

#~ msgid "user %s does not exist"
#~ msgstr "用户%s 不存在"

#~ msgid "incorrect password"
#~ msgstr "密码不正确"

#~ msgid "using restricted shell %s"
#~ msgstr "正在使用受限的shell %s"

#~ msgid "warning: cannot change directory to %s"
#~ msgstr "警告：无法切换到目录%s"

#~ msgid ""
#~ "\n"
#~ "SIZE may be (or may be an integer optionally followed by) one of "
#~ "following:\n"
#~ "KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, "
#~ "Y.\n"
#~ msgstr ""
#~ "\n"
#~ "SIZE 可以是一个可选的整数，后面跟着以下单位中的一个：\n"
#~ "KB 1000，K 1024，MB 1000*1000，M 1024*1024，还有 G、T、P、E、Z、Y。\n"

#~ msgid ""
#~ "\n"
#~ "Report %s bugs to %s\n"
#~ msgstr ""
#~ "\n"
#~ "请向%2$s 报告%1$s 的错误\n"

#~ msgid "warning: --retry is useful mainly when following by name"
#~ msgstr "警告：--retry 参数需要在后面附加名称后使用"

#~ msgid ""
#~ "  -D, --all-repeated[=delimit-method]  print all duplicate lines\n"
#~ "                        delimit-method={none(default),prepend,separate}\n"
#~ "                        Delimiting is done with blank lines\n"
#~ "  -f, --skip-fields=N   avoid comparing the first N fields\n"
#~ "  -i, --ignore-case     ignore differences in case when comparing\n"
#~ "  -s, --skip-chars=N    avoid comparing the first N characters\n"
#~ "  -u, --unique          only print unique lines\n"
#~ "  -z, --zero-terminated  end lines with 0 byte, not newline\n"
#~ msgstr ""
#~ "  -D, --all-repeated[=delimit-method\t显示所有重复的行\n"
#~ "\t\t\tdelimit-method={none(default),prepend,separate}\n"
#~ "\t\t\t以空行为界限\n"
#~ "  -f, --skip-fields=N\t比较时跳过前N 列\n"
#~ "  -i, --ignore-case\t在比较的时候不区分大小写\n"
#~ "  -s, --skip-chars=N\t比较时跳过前N 个字符\n"
#~ "  -u, --unique\t\t只显示唯一的行\n"
#~ "  -z, --zero-terminated\t使用'\\0'作为行结束符，而不是新换行\n"

#~ msgid "truncating %s"
#~ msgstr "正在截断%s"

#~ msgid "invalid number of lines: 0"
#~ msgstr "无效的行数：0"

#~ msgid "invalid format precision"
#~ msgstr "无效的格式精确度"

#~ msgid "%s"
#~ msgstr "%s"

#~ msgid "creating symbolic link %s"
#~ msgstr "创建符号链接 %s"

#~ msgid "creating symbolic link %s -> %s"
#~ msgstr "创建符号链接%s -> %s"

#~ msgid "creating hard link %s"
#~ msgstr "创建硬链接%s"

#~ msgid "creating hard link %s => %s"
#~ msgstr "创建硬链接%s => %s"

#~ msgid "extra operand %s\n"
#~ msgstr "额外的操作数 %s\n"

#~ msgid "both SI and IEC prefixes present on units"
#~ msgstr "单位中既有 SI 单位又有 IEC 单位"

#~ msgid ""
#~ "the --context (-Z) option is obsolete and will be removed\n"
#~ "in a future release"
#~ msgstr "--context (-Z)选项已废弃，将在未来的发行中删除"

#~ msgid "warning: the --%s option is obsolete; use --reference"
#~ msgstr "警告：--%s 选项已过时，请使用--reference"

#~ msgid ""
#~ "\n"
#~ "Note that the -r and -s options are mutually exclusive.\n"
#~ msgstr ""
#~ "\n"
#~ "请注意-r 和-s 是互斥的选项。\n"

#~ msgid ""
#~ "  -w, --wrap=COLS       Wrap encoded lines after COLS character (default "
#~ "76).\n"
#~ "                        Use 0 to disable line wrapping.\n"
#~ "\n"
#~ "  -d, --decode          Decode data.\n"
#~ "  -i, --ignore-garbage  When decoding, ignore non-alphabet characters.\n"
#~ "\n"
#~ msgstr ""
#~ "  -w, --wrap=COLS\t限制编码后每行的长度为COLS(默认为76个字符)。\n"
#~ "\t\t\t如果COLS为0，表示无此限制。\n"
#~ "\n"
#~ "  -d, --decode\t\t解码。\n"
#~ "  -i, --ignore-garbage\t在解码的时候忽略非字母表(a-zA-Z)的字符。\n"
#~ "\n"

#~ msgid ""
#~ "Usage: %s [OPTION] NUMBER[SUFFIX] COMMAND [ARG]...\n"
#~ "  or:  %s [OPTION]\n"
#~ msgstr ""
#~ "用法：%s [选项] 数字[后缀] 命令 [参数]...\n"
#~ "　或：%s [选项]\n"

#~ msgid "%s: illegal option -- %c\n"
#~ msgstr "%s：非法选项 -- %c\n"

#~ msgid ""
#~ "      --help            Display this help and exit.\n"
#~ "      --version         Output version information and exit.\n"
#~ msgstr ""
#~ "      --help            显示此帮助并退出。\n"
#~ "      --version         输出版本信息并退出\n"

#~ msgid ""
#~ "With --follow (-f), tail defaults to following the file descriptor, "
#~ "which\n"
#~ "means that even if a tail'ed file is renamed, tail will continue to "
#~ "track\n"
#~ "its end.  "
#~ msgstr ""
#~ "当同--follow (-f)一起使用时，tail 默认以文件描述内容为观察。这意味着\n"
#~ "即使被指定的文件已被改名，tail 仍会继续追踪其尾部内容。"

#~ msgid "invalid argument: %s"
#~ msgstr "无效的参数：%s"

#~ msgid "Report %s bugs to <%s>.\n"
#~ msgstr "请向<%s> 报告%s 的错误。\n"

#~ msgid "%s home page: <http://www.gnu.org/software/%s/>.\n"
#~ msgstr "%s 主页：<http://www.gnu.org/software/%s/>。\n"

#~ msgid "General help using GNU software: <http://www.gnu.org/gethelp/>.\n"
#~ msgstr "使用GNU 软件的一般帮助：<http://www.gnu.org/gethelp/>。\n"

#~ msgid "the --megabytes option is deprecated; use -m instead"
#~ msgstr "警告：--megabytes 选项已经过时，请使用-m。"

#~ msgid ""
#~ "\n"
#~ "If -e is in effect, the following sequences are recognized:\n"
#~ "\n"
#~ "  \\0NNN   the character whose ASCII code is NNN (octal)\n"
#~ "  \\\\     backslash\n"
#~ "  \\a     alert (BEL)\n"
#~ "  \\b     backspace\n"
#~ msgstr ""
#~ "\n"
#~ "如果 -e 选项生效，以下特殊序列可以被识别：\n"
#~ "\n"
#~ "  \\0NNN\tASCII 码为NNN 的字符(八进制)\n"
#~ "  \\\\\t反斜杠\n"
#~ "  \\a\t终端响铃\n"
#~ "  \\b\t退格\n"

#~ msgid "  -d, --directory  create a directory, not a file\n"
#~ msgstr "  -d, --directory  \t创建一个目录而非文件\n"

#~ msgid ""
#~ "  -q, --quiet      suppress diagnostics about file/dir-creation failure\n"
#~ msgstr "  -q， --quiet \t\t隐藏创建文件或目录失败时的诊断信息\n"

#~ msgid ""
#~ "  -u, --dry-run    do not create anything; merely print a name (unsafe)\n"
#~ msgstr "  -u, --dry-run \t不创建任务; 只显示一个名称(不安全)\n"

#~ msgid "  -p DIR           use DIR as a prefix; implies -t [deprecated]\n"
#~ msgstr "  -p DIR \t\t用DIR 作为前缀；隐含-t [不推荐]\n"

#~ msgid ""
#~ "  \\a      alert (BEL)\n"
#~ "  \\b      backspace\n"
#~ "  \\c      produce no further output\n"
#~ "  \\f      form feed\n"
#~ msgstr ""
#~ "  \\a\t\t终端响铃\n"
#~ "  \\b\t\t退格\n"
#~ "  \\c\t\t不产生成更多输出\n"
#~ "  \\f\t\t换页\n"

#~ msgid ""
#~ "  \\n      new line\n"
#~ "  \\r      carriage return\n"
#~ "  \\t      horizontal tab\n"
#~ "  \\v      vertical tab\n"
#~ msgstr ""
#~ "  \\n\t\t换行\n"
#~ "  \\r\t\t回车\n"
#~ "  \\t\t\t水平制表符\n"
#~ "  \\v\t\t垂直制表符\n"

#~ msgid "path truncated when looking for %s"
#~ msgstr "查找%s 时已截断路径"

#~ msgid "%s: warning: making a hard link to a symbolic link is not portable"
#~ msgstr "%s：警告：将硬链接连至符号链接是不通用的功能"

#~ msgid ""
#~ "\n"
#~ "By default, color is not used to distinguish types of files.  That is\n"
#~ "equivalent to using --color=none.  Using the --color option without the\n"
#~ "optional WHEN argument is equivalent to using --color=always.  With\n"
#~ "--color=auto, color codes are output only if standard output is "
#~ "connected\n"
#~ "to a terminal (tty).  The environment variable LS_COLORS can influence "
#~ "the\n"
#~ "colors, and can be set easily by the dircolors command.\n"
#~ msgstr ""
#~ "\n"
#~ "默认情况下不使用色彩来区别文件，此方式等于使用了 --color=none 选项。若使"
#~ "用\n"
#~ "--color 选项但不指定 WHEN 参数则等于--color=always。当使用 --color=auto "
#~ "时，\n"
#~ "只当输出至终端(tty)时才会显示色彩。\n"

#~ msgid "FATAL: failed to close directory %s"
#~ msgstr "致命错误：关闭目录%s 失败"

#~ msgid "FATAL: cannot open .. from %s"
#~ msgstr "致命错误：无法从%s 打开 .."

#~ msgid "FATAL: cannot ensure %s (returned to via ..) is safe"
#~ msgstr "致命错误：不能确定%s (已使用 .. 返回)是安全的"

#~ msgid "FATAL: directory %s changed dev/ino"
#~ msgstr "致命错误：目录%s 的dev/ino 发生了变动"

#~ msgid "FATAL: cannot enter directory %s"
#~ msgstr "致命错误：无法进入目录%s"

#~ msgid "FATAL: just-changed-to directory %s changed dev/ino"
#~ msgstr "致命错误：刚刚进入的目录%s 的dev/ino 发生了变动"

#~ msgid "FATAL: cannot return to .. from %s"
#~ msgstr "致命错误：不能回到%s 的上级目录(..)"

#~ msgid "cannot remove root directory %s"
#~ msgstr "无法删除根目录%s"

#~ msgid "cannot remove relative-named %s"
#~ msgstr "不能移除相对命名的%s"

#~ msgid "cannot restore current working directory"
#~ msgstr "无法回到当前工作目录"

#~ msgid ""
#~ "\n"
#~ "SIZE may have a multiplier suffix:\n"
#~ "b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
#~ "GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
#~ msgstr ""
#~ "\n"
#~ "指定的大小可以使用以下单位：\n"
#~ "xM=M，c=1，w=2，b=512，kB=1000，K=1024，MB=1000000，M=1048576，\n"
#~ "GB=1000000000，G=1073741824，T、P、E、Z、Y 依此类推。\n"

#~ msgid ""
#~ "Discard all but one of successive identical lines from INPUT (or\n"
#~ "standard input), writing to OUTPUT (or standard output).\n"
#~ "\n"
#~ msgstr ""
#~ "只保留<输入> (或标准输入) 中接连的相同行目中的一个节段，并写到\n"
#~ "<输出> (或标准输出)。\n"
#~ "\n"

#~ msgid ""
#~ "  -p                           same as --preserve=mode,ownership,"
#~ "timestamps\n"
#~ "      --preserve[=ATTR_LIST]   preserve the specified attributes "
#~ "(default:\n"
#~ "                                 mode,ownership,timestamps), if possible\n"
#~ "                                 additional attributes: context, links, "
#~ "all\n"
#~ msgstr ""
#~ "  -p                           等于--preserve=mode,ownership,timestamps\n"
#~ "      --preserve[=ATTR_LIST]   若可能，保留指定的文件属性\n"
#~ "                                 (默认值为：mode,ownership,timestamps)\n"
#~ "                                 额外的属性有：links、all\n"

#~ msgid "invalid output flag: %s"
#~ msgstr "无效的输出标志：%s"

#~ msgid ""
#~ "      --backup[=CONTROL]  make a backup of each existing destination "
#~ "file\n"
#~ "  -b                  like --backup but does not accept an argument\n"
#~ "  -c                  (ignored)\n"
#~ "  -d, --directory     treat all arguments as directory names; create all\n"
#~ "                        components of the specified directories\n"
#~ msgstr ""
#~ "      --backup[=CONTROL] 为每个已存在的目标文件进行备份\n"
#~ "  -b                  类似 --backup，但不接受任何参数\n"
#~ "  -c                  (此选项不作处理)\n"
#~ "  -d, --directory     所有参数都作为目录处理；而且会创建指定目录的所有主目"
#~ "录\n"

#~ msgid ""
#~ "  -P, --no-dereference         never follow symbolic links in SOURCE\n"
#~ msgstr "  -P, --no-dereference         从不跟随符号链接\n"

#~ msgid "File operands cannot be combined with --print-database (-p)."
#~ msgstr "文件操作数无法与 --print-database (-p) 组合使用。"

#~ msgid "Usage: %s [OPTION]... [STRING]...\n"
#~ msgstr "用法：%s [选项]... [字符串]...\n"

#~ msgid ""
#~ "  -a, --all             include dummy file systems\n"
#~ "  -B, --block-size=SIZE  use SIZE-byte blocks\n"
#~ "  -h, --human-readable  print sizes in human readable format (e.g., 1K "
#~ "234M 2G)\n"
#~ "  -H, --si              likewise, but use powers of 1000 not 1024\n"
#~ msgstr ""
#~ "  -a, --all             包括大小为 0 个块的文件系统\n"
#~ "  -B, --block-size=大小 块以指定<大小>的字节为单位\n"
#~ "  -h, --human-readable  以容易理解的格式输出文件系统大小 (例如 1K 234M "
#~ "2G)\n"
#~ "  -H, --si              类似 -h，但取 1000 的次方而不是 1024\n"

#~ msgid ""
#~ "      --files0-from=F   summarize disk usage of the NUL-terminated file\n"
#~ "                          names specified in file F\n"
#~ "  -H                    like --si, but also evokes a warning; will soon\n"
#~ "                          change to be equivalent to --dereference-args (-"
#~ "D)\n"
#~ "  -h, --human-readable  print sizes in human readable format (e.g., 1K "
#~ "234M 2G)\n"
#~ "      --si              like -h, but use powers of 1000 not 1024\n"
#~ msgstr ""
#~ "      -h, --human-readable  以容易理解的格式输出文件大小 (例如 1K 234M "
#~ "2G)\n"
#~ "  -H, --si              类似 -h，但取 1000 的次方而不是 1024\n"
#~ "  -k                    即--block-size=1K\n"
#~ "  -l, --count-links     连硬链接的大小也计算在内\n"

#~ msgid "Usage: %s [OPTION] FILE...\n"
#~ msgstr "用法：%s [选项] 文件...\n"

#~ msgid "???? days ??:??,  "
#~ msgstr "???? 天 ??:??，  "

#~ msgid "invalid input flag: %s"
#~ msgstr "无效的输入标志：%s"

#~ msgid ""
#~ "  -r, --reverse              reverse order while sorting\n"
#~ "  -R, --recursive            list subdirectories recursively\n"
#~ "  -s, --size                 print the size of each file, in blocks\n"
#~ msgstr ""
#~ "  -r, --reverse              逆序排序\n"
#~ "  -R, --recursive            递归列出所有子目录\n"
#~ "  -s, --size                 和 -l 同时使用时以块为单位列出每个文件的大"
#~ "小\n"

#~ msgid ""
#~ "  -f, --force                  if an existing destination file cannot be\n"
#~ "                                 opened, remove it and try again\n"
#~ "  -i, --interactive            prompt before overwrite\n"
#~ "  -H                           follow command-line symbolic links in "
#~ "SOURCE\n"
#~ msgstr ""
#~ "  -f, --force                  如果无法打开已存在的文件，会删除该文件并"
#~ "再\n"
#~ "                                 尝试打开\n"
#~ "  -i, --interactive            覆盖文件前需要确认\n"
#~ "  -H                           使用命令列中的符号链接指示的真正目的地\n"

#~ msgid "Usage: %s [OPTION] DIRECTORY...\n"
#~ msgstr "用法：%s [选项] 目录...\n"

#~ msgid ""
#~ "  -p, --preserve-timestamps   apply access/modification times of SOURCE "
#~ "files\n"
#~ "                        to corresponding destination files\n"
#~ "  -s, --strip         strip symbol tables\n"
#~ "  -S, --suffix=SUFFIX  override the usual backup suffix\n"
#~ "  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
#~ "DIRECTORY\n"
#~ "  -T, --no-target-directory  treat DEST as a normal file\n"
#~ "  -v, --verbose       print the name of each directory as it is created\n"
#~ msgstr ""
#~ "  -p, --preserve-timestamps   以<源>文件的访问/修改时间作为相应的目的\n"
#~ "                      地文件的时间属性\n"
#~ "  -s, --strip         用 strip 命令删除 symbol table，只适用于第一及第二"
#~ "种\n"
#~ "                      使用格式\n"
#~ "  -S, --suffix=后缀   自行指定备份文件的<后缀>\n"
#~ "  -v, --verbose       处理每个文件/目录时输出名称\n"

#~ msgid "invalid format string: %s"
#~ msgstr "无效的格式字符串：%s"

#~ msgid "cannot create temporary file"
#~ msgstr "无法创建临时文件"

#~ msgid "changing security context of %s"
#~ msgstr "更改 %s 的权限"

#~ msgid "Cannot combine --target-directory and --no-target-directory"
#~ msgstr "无法组合使用 --target-directory 和 --no-target-directory"

#~ msgid "cannot run strip"
#~ msgstr "无法执行 strip 命令"

#~ msgid ""
#~ "  -x, --one-file-system  skip directories on different file systems\n"
#~ "  -X FILE, --exclude-from=FILE  Exclude files that match any pattern in "
#~ "FILE.\n"
#~ "      --exclude=PATTERN  Exclude files that match PATTERN.\n"
#~ "      --max-depth=N     print the total for a directory (or file, with --"
#~ "all)\n"
#~ "                          only if it is N or fewer levels below the "
#~ "command\n"
#~ "                          line argument;  --max-depth=0 is the same as\n"
#~ "                          --summarize\n"
#~ msgstr ""
#~ "  -x, --one-file-system  略过属于其他文件系统的目录\n"
#~ "  -X 文件, --exclude-from=文件  由<文件>读取应排除的文件的样式\n"
#~ "      --exclude=PAT      排除符合指定<样式>的文件\n"
#~ "      --max-depth=N      只显示参数指定的目录 N 层或以内的子目录的总用量\n"
#~ "                         (若使用 --all 选项，也会显示文件的占用量)；\n"
#~ "                         --max-depth=0 的效果等于--summarize\n"

#~ msgid "%ld day"
#~ msgid_plural "%ld days"
#~ msgstr[0] "%ld 天"

#~ msgid ""
#~ "  -u                         with -lt: sort by, and show, access time\n"
#~ "                               with -l: show access time and sort by "
#~ "name\n"
#~ "                               otherwise: sort by access time\n"
#~ "  -U                         do not sort; list entries in directory "
#~ "order\n"
#~ "  -v                         sort by version\n"
#~ msgstr ""
#~ "  -u                         配合 -lt：显示访问时间而且依访问时间排序\n"
#~ "                               配合 -l：显示访问时间但根据名称排序\n"
#~ "                               否则：根据访问时间排序\n"
#~ "  -U                         不进行排序；依文件系统原有的次序列出项目\n"
#~ "  -v                         根据版本进行排序\n"

#~ msgid "cannot create temporary file %s"
#~ msgstr "无法创建临时文件%s"

#~ msgid "Usage: %s [OPTION]... [ FILE ]\n"
#~ msgstr "用法：%s [选项]... [文件]\n"

#~ msgid "Usage: %s [OPTIONS] FILE [...]\n"
#~ msgstr "用法：%s [选项] 文件 [...]\n"
