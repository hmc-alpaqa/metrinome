# Bulgarian translation of GNU coreutis po-file.
# Copyright (C) 2003, 2004, 2005, 2006, 2018, 2019, 2020 Free Software Foundation, Inc.
# This file is distributed under the same license as the coreutils package.
# Anton Zinoviev <zinoviev@debian.org>, 2003, 2004, 2005, 2006.
# Alexander Shopov <ash@kambanaria.org>, 2018, 2019, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: coreutils 8.31.90\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2020-03-05 13:28+0000\n"
"PO-Revision-Date: 2020-02-29 11:48+0100\n"
"Last-Translator: Alexander Shopov <ash@kambanaria.org>\n"
"Language-Team: Bulgarian <dict@ludost.net>\n"
"Language: bg\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: lib/argmatch.c:132
#, c-format
msgid "invalid argument %s for %s"
msgstr "аргументът „%s“ на опцията „%s“ е неправилен"

#: lib/argmatch.c:133
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "аргументът „%s“ на опцията „%s“ не е еднозначен"

#: lib/argmatch.c:152 lib/argmatch.h:223
msgid "Valid arguments are:"
msgstr "Възможните аргументи са:"

#: lib/closein.c:100
msgid "error closing file"
msgstr "грешка при затваряне на файл"

#: lib/closeout.c:122 src/basenc.c:945 src/basenc.c:957 src/basenc.c:963
#: src/basenc.c:1006 src/basenc.c:1071 src/cat.c:187 src/cat.c:203
#: src/cat.c:287 src/cksum.c:245 src/expand.c:150 src/expand.c:175
#: src/factor.c:2387 src/mktemp.c:339 src/od.c:970 src/paste.c:163
#: src/seq.c:295 src/shuf.c:595 src/split.c:936 src/split.c:1190
#: src/split.c:1195 src/tail.c:1291 src/tail.c:1445 src/tail.c:2507
#: src/tr.c:1587 src/tr.c:1813 src/tr.c:1905 src/unexpand.c:234
#: src/unexpand.c:250
#, c-format
msgid "write error"
msgstr "грешка при запис"

#: lib/copy-acl.c:54 src/copy.c:1427 src/copy.c:2945
#, c-format
msgid "preserving permissions for %s"
msgstr "запазване на правата за „%s“"

#: lib/error.c:195
msgid "Unknown system error"
msgstr "Неизвестна системна грешка"

#: lib/file-type.c:40
msgid "regular empty file"
msgstr "празен, обикновен файл"

#: lib/file-type.c:40
msgid "regular file"
msgstr "обикновен файл"

#: lib/file-type.c:43
msgid "directory"
msgstr "директория"

#: lib/file-type.c:46
msgid "symbolic link"
msgstr "символна връзка"

#: lib/file-type.c:52
msgid "message queue"
msgstr "опашка за съобщения"

#: lib/file-type.c:55
msgid "semaphore"
msgstr "семафор"

#: lib/file-type.c:58
msgid "shared memory object"
msgstr "споделен обект в паметта"

#: lib/file-type.c:61
msgid "typed memory object"
msgstr "типов обект в паметта"

#: lib/file-type.c:66
msgid "block special file"
msgstr "блоков специален файл"

#: lib/file-type.c:69
msgid "character special file"
msgstr "знаков специален сайт"

#: lib/file-type.c:72
msgid "contiguous data"
msgstr "последователни данни"

#: lib/file-type.c:75
msgid "fifo"
msgstr "програмен канал"

#: lib/file-type.c:78
msgid "door"
msgstr "порта"

#: lib/file-type.c:81
msgid "multiplexed block special file"
msgstr "мултиплексиран блоков специален файл"

#: lib/file-type.c:84
msgid "multiplexed character special file"
msgstr "мултиплексиран знаков специален файл"

#: lib/file-type.c:87
msgid "multiplexed file"
msgstr "мултиплексиран файл"

#: lib/file-type.c:90
msgid "named file"
msgstr "именован файл"

#: lib/file-type.c:93
msgid "network special file"
msgstr "мрежов специален файл"

#: lib/file-type.c:96
msgid "migrated file with data"
msgstr "мигриран файл с данни"

#: lib/file-type.c:99
msgid "migrated file without data"
msgstr "мигриран файл без данни"

#: lib/file-type.c:102
msgid "port"
msgstr "порт"

#: lib/file-type.c:105
msgid "socket"
msgstr "гнездо"

#: lib/file-type.c:108
msgid "whiteout"
msgstr "припокриващо изтриване"

#: lib/file-type.c:110
msgid "weird file"
msgstr "странен файл"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "Този вид адреси за името на хоста не се поддържат"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "Временен проблем при намиране IP-адреса на хост"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "Неправилна стойност за „ai_flags“"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "Окончателен неуспех при намиране IP-адреса на хост"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "посочването на вид адреси („ai_family“) не се поддържа"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "Неуспешно заделяне на памет"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "Няма IP-адрес с посоченото име на хост"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "Името или услугата са непознати"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr ""
"Името на услугата не се поддържа за използвания вид гнездо („ai_socktype“)"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "посочването на вид гнездо („ai_socktype“) не се поддържа"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "Системна грешка"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "Буферът за аргументите е твърде малък"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "Заявката е в процес на изпълнение"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "Заявката е отменена"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "Заявката не е отменена"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "Изпълнени са всички заявки"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "Прекъснат със сигнал"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "Неправилно кодиран низ на аргумент"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "Неизвестна грешка"

#: lib/getopt.c:278
#, c-format
msgid "%s: option '%s%s' is ambiguous\n"
msgstr "%s: опцията „%s%s“ не е еднозначна\n"

#: lib/getopt.c:284
#, c-format
msgid "%s: option '%s%s' is ambiguous; possibilities:"
msgstr "%s: опцията „%s%s“ не е еднозначна.  Възможности:"

#: lib/getopt.c:319
#, c-format
msgid "%s: unrecognized option '%s%s'\n"
msgstr "%s: непозната опция „%s%s“\n"

#: lib/getopt.c:345
#, c-format
msgid "%s: option '%s%s' doesn't allow an argument\n"
msgstr "%s: опцията „%s%s“ се използва без аргументи\n"

#: lib/getopt.c:360
#, c-format
msgid "%s: option '%s%s' requires an argument\n"
msgstr "%s: опцията „%s%s“ изисква аргумент\n"

#: lib/getopt.c:621
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s: неправилна опция — „%c“\n"

#: lib/getopt.c:636 lib/getopt.c:682
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s: опцията изисква аргумент — „%c“\n"

#: lib/mkdir-p.c:162 src/copy.c:1927 src/copy.c:1999 src/copy.c:2571
#: src/copy.c:2932 src/find-mount-point.c:84 src/install.c:702
#: src/realpath.c:146 src/stat.c:1440 src/truncate.c:327
#, c-format
msgid "cannot stat %s"
msgstr "не може да се получи информация със „stat“ за „%s“"

#: lib/mkdir-p.c:190 src/install.c:512
#, c-format
msgid "cannot change permissions of %s"
msgstr "правата за достъп до „%s“ не може да се сменят"

#: lib/mkdir-p.c:200 src/copy.c:2560 src/install.c:740 src/install.c:753
#, c-format
msgid "cannot create directory %s"
msgstr "директорията „%s“ не може да се създаде"

#: lib/obstack.c:338 lib/obstack.c:340 lib/xalloc-die.c:34 src/csplit.c:233
#: src/tac.c:442
#, c-format
msgid "memory exhausted"
msgstr "паметта е изчерпана"

#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "не може да се запише коя е текущата работна директория"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "не може да се върне към първоначалната работна директория"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:362
msgid "`"
msgstr "„"

#: lib/quotearg.c:363
msgid "'"
msgstr "“"

#: lib/randread.c:128
#, c-format
msgid "%s: end of file"
msgstr "%s: край на файла"

#: lib/randread.c:128 src/du.c:1074 src/md5sum.c:803 src/od.c:954 src/tac.c:251
#: src/tac.c:357 src/tac.c:515 src/tac.c:596 src/wc.c:824
#, c-format
msgid "%s: read error"
msgstr "%s: грешка при четене"

#: lib/regcomp.c:135
msgid "Success"
msgstr "Успех"

#: lib/regcomp.c:138
msgid "No match"
msgstr "Няма съвпадения"

#: lib/regcomp.c:141
msgid "Invalid regular expression"
msgstr "Неправилен регулярен израз"

#: lib/regcomp.c:144
msgid "Invalid collation character"
msgstr "Неправилен знак за подредба"

#: lib/regcomp.c:147
msgid "Invalid character class name"
msgstr "Неправилно име на клас знаци"

#: lib/regcomp.c:150
msgid "Trailing backslash"
msgstr "Самотна „\\“ накрая"

#: lib/regcomp.c:153
msgid "Invalid back reference"
msgstr "Неправилна препратка към съвпадение"

#: lib/regcomp.c:156
msgid "Unmatched [, [^, [:, [., or [="
msgstr "„[“, „[^“, „[:“, „[.“ или „[=“ без еш"

#: lib/regcomp.c:159
msgid "Unmatched ( or \\("
msgstr "„(“ или „\\(“ без еш"

#: lib/regcomp.c:162
msgid "Unmatched \\{"
msgstr "„\\{“ без еш"

#: lib/regcomp.c:165
msgid "Invalid content of \\{\\}"
msgstr "Неправилно съдържание в „\\{\\}“"

#: lib/regcomp.c:168
msgid "Invalid range end"
msgstr "Неправилен край на диапазон"

#: lib/regcomp.c:171
msgid "Memory exhausted"
msgstr "Паметта свърши"

#: lib/regcomp.c:174
msgid "Invalid preceding regular expression"
msgstr "Предхождащият регулярен израз е неправилен"

#: lib/regcomp.c:177
msgid "Premature end of regular expression"
msgstr "Ранен край на регулярен израз"

#: lib/regcomp.c:180
msgid "Regular expression too big"
msgstr "Регулярният израз е прекалено голям"

#: lib/regcomp.c:183
msgid "Unmatched ) or \\)"
msgstr "„)“ или „\\)“ без еш"

#: lib/regcomp.c:676
msgid "No previous regular expression"
msgstr "Няма предхождащ регулярен израз"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "опасно е да се работи рекурсивно върху %s"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "опасно е да се работи рекурсивно върху %s, т.е. върху %s"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr "ползвайте „--no-preserve-root“, за да отмените тази предпазна мярка"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:150
msgid "^[yY]"
msgstr "^[yYдДщЩ]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:163
msgid "^[nN]"
msgstr "^[nNнНхХ]"

#: lib/set-acl.c:46 src/copy.c:2583 src/cp.c:514
#, c-format
msgid "setting permissions for %s"
msgstr "задаване на права на „%s“"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "Прекъсване на връзката"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "Прекъсване"

#: lib/siglist.h:37
msgid "Quit"
msgstr "Спиране"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "Неправилна инструкция"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "Прекъсване за трасиране"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "Преустановяване"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "Изключение от плаваща запетая"

#: lib/siglist.h:52
msgid "Killed"
msgstr "Убит"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "Грешка в шината"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "Грешка в разделянето"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "Прекъснат програмен канал"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "Аларма"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "Прекратен"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "Спешно вх./изх. състояние"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "Спрян (сигнал)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "Спрян"

#: lib/siglist.h:79
msgid "Continued"
msgstr "Продължен"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "Преустановен дъщерен процес"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "Спиране (вход от tty)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "Спиране (изход към tty)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "Възможен вх./изх."

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "Надвишаване на процесорното време"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "Надвишаване на размера на файл"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "Изтекъл виртуален таймер"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "Изтекъл профилиращ таймер"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "Преоразмерен прозорец"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "Потребителски сигнал 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "Потребителски сигнал 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "Емулирана инструкция"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "Грешно системно извикване"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "Грешка в разделянето"

#: lib/siglist.h:126
msgid "Information request"
msgstr "Заявка за информация"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "Проблем в захранването"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "Загубен ресурс"

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "Сигнал за реално време %d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "Непознат сигнал %d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "функцията „iconv“  е неизползваема"

#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "функцията „iconv“ е недостъпна"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "знак извън диапазона"

#: lib/unicodeio.c:181
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "„U+%04X“ не може да се конвертира в локалното кодиране"

#: lib/unicodeio.c:183
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "„U+%04X“ не може да се конвертира в локалното кодиране: %s"

#: lib/userspec.c:106
msgid "invalid user"
msgstr "несъществуващ потребител"

#: lib/userspec.c:107
msgid "invalid group"
msgstr "несъществуваща група"

#: lib/userspec.c:108
msgid "invalid spec"
msgstr "неправилна спецификация"

#: lib/verror.c:73
#, c-format
msgid "unable to display error message"
msgstr "съобщението за грешка не може да се изведе"

#: lib/version-etc.c:73
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "Пакетирано от %s (%s)\n"

#: lib/version-etc.c:76
#, c-format
msgid "Packaged by %s\n"
msgstr "Пакетирано от %s\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:83
msgid "(C)"
msgstr "©"

#. TRANSLATORS: The %s placeholder is the web address of the GPL license.
#: lib/version-etc.c:88
#, c-format
msgid ""
"License GPLv3+: GNU GPL version 3 or later <%s>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
msgstr ""
"Лиценз — Общ публичен лиценз на GNU (GNU GPL), както е публикуван от "
"Фондацията\n"
"за свободен софтуер — версия 3 на лиценза или (по ваше решение) по-късна "
"версия.\n"
"<%s>\n"
"Тази програма е свободен софтуер. Можете да я разпространявате и/или "
"променяте.\n"
"Тя се разпространява БЕЗ НИКАКВИ ГАРАНЦИИ доколкото е позволено от закона.\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:105
#, c-format
msgid "Written by %s.\n"
msgstr "Създадено от %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:109
#, c-format
msgid "Written by %s and %s.\n"
msgstr "Създадено от %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:113
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "Създадено от %s, %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:120
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Създадено от %s, %s, %s\n"
"и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:127
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:134
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:142
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:150
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s, %s\n"
"и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:159
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s и %s.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:170
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"Създадено от %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s и др.\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:249
#, c-format
msgid "Report bugs to: %s\n"
msgstr ""
"Докладвайте грешки в програмата на адрес: %s\n"
"Докладвайте грешки в превода на адрес: <dict@ludost.net>\n"

#: lib/version-etc.c:251
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "Докладвайте грешки в „%s“ на адрес: %s\n"

#: lib/version-etc.c:255 lib/version-etc.c:257
#, c-format
msgid "%s home page: <%s>\n"
msgstr "Уеб страница на „%s“: <%s>\n"

#: lib/version-etc.c:260
#, c-format
msgid "General help using GNU software: <%s>\n"
msgstr "Обща помощ за програмите на GNU: <%s>\n"

#: lib/xbinary-io.c:37
#, c-format
msgid "failed to set file descriptor text/binary mode"
msgstr "неуспешно задаване на вид на файла като текстов/двоичен"

#: lib/xmemcoll.c:39 src/expr.c:1026
#, c-format
msgid "string comparison failed"
msgstr "неуспешно сравнение на низове"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "Използвайте „LC_ALL='C'“, за да заобиколите този проблем."

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "Сравняваните низове бяха %s и %s."

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "невъзможно форматиране на изхода"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "неправилен аргумент „%3$s“ за опцията „%1$s%2$s“"

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "неправилен суфикс в аргумента „%3$s“ за опцията „%1$s%2$s“"

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "прекалено дълъг аргумент „%3$s“ за опцията „%1$s%2$s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:38 src/chmod.c:39 src/chown.c:37 src/comm.c:39
#: src/cp.c:48 src/csplit.c:45 src/cut.c:46 src/date.c:40 src/dd.c:45
#: src/df.c:49 src/dirname.c:32 src/du.c:55 src/env.c:39 src/expand.c:49
#: src/fold.c:36 src/groups.c:36 src/head.c:47 src/id.c:42 src/install.c:51
#: src/ln.c:52 src/ls.c:137 src/mkdir.c:39 src/mkfifo.c:36 src/mknod.c:37
#: src/mv.c:43 src/nice.c:40 src/nl.c:42 src/paste.c:53 src/pathchk.c:32
#: src/pinky.c:38 src/printenv.c:44 src/printf.c:68 src/rm.c:41 src/rmdir.c:37
#: src/stty.c:68 src/sum.c:39 src/tac.c:58 src/tail.c:77 src/tee.c:38
#: src/touch.c:45 src/tty.c:44 src/uname.c:61 src/unexpand.c:50 src/uniq.c:41
#: src/uptime.c:46 src/users.c:36 src/wc.c:51 src/who.c:51 src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"Употреба: %s ИМЕ [РАЗШИРЕНИЕ]\n"
"     или: %s ОПЦИЯ… ИМЕ…\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""
"Отстраняване на началните директории от ИМЕто и отпечатване.\n"
"Ако е посочено, се изтрива и РАЗШИРЕНИЕто в края.\n"

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n"
"  -z, --zero           end each output line with NUL, not newline\n"
msgstr ""
"  -a, --multiple       поддръжка на множество аргументи, които да са ИМЕна\n"
"  -s, --suffix=СУФИКС  премахване на такъв краен СУФИКС, включва опцията „-"
"a“\n"
"  -z, --zero           завършване на редовете с нулев байт, а не знак за нов "
"ред\n"

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""
"\n"
"Примери:\n"
"  %s /usr/bin/sort          → „sort“\n"
"  %s include/stdio.h .h     → „stdio“\n"
"  %s -s .h include/stdio.h  → „stdio“\n"
"  %s -a any/str1 any/str2   → „str1“, следвано от „str2“\n"

#: src/basename.c:170 src/chcon.c:537 src/chgrp.c:279 src/chmod.c:529
#: src/chown.c:280 src/chroot.c:279 src/comm.c:481 src/csplit.c:1402
#: src/dirname.c:116 src/expr.c:454 src/join.c:1159 src/link.c:76
#: src/mkdir.c:252 src/mkfifo.c:130 src/mknod.c:171 src/nohup.c:107
#: src/pathchk.c:147 src/printf.c:693 src/readlink.c:145 src/realpath.c:237
#: src/rm.c:338 src/rmdir.c:223 src/seq.c:633 src/sleep.c:116 src/stat.c:1885
#: src/stdbuf.c:371 src/tr.c:1753 src/unlink.c:74
#, c-format
msgid "missing operand"
msgstr "липсващ операнд"

#: src/basename.c:176 src/basenc.c:1225 src/comm.c:489 src/cp.c:621
#: src/date.c:471 src/dircolors.c:449 src/du.c:1019 src/hostid.c:72
#: src/hostname.c:111 src/install.c:985 src/join.c:969 src/link.c:84
#: src/ln.c:593 src/logname.c:70 src/mknod.c:182 src/mv.c:451 src/nproc.c:115
#: src/od.c:1871 src/ptx.c:2082 src/seq.c:639 src/shuf.c:491 src/sort.c:4596
#: src/split.c:1554 src/tr.c:1768 src/tsort.c:559 src/tty.c:113 src/uname.c:252
#: src/uniq.c:520 src/uniq.c:537 src/unlink.c:80 src/uptime.c:252
#: src/users.c:145 src/wc.c:758 src/who.c:831 src/whoami.c:78
#, c-format
msgid "extra operand %s"
msgstr "излишен операнд: „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:37 src/basenc.c:40
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:38 src/env.c:40 src/numfmt.c:43
msgid "Assaf Gordon"
msgstr "Assaf Gordon"

#: src/basenc.c:101 src/dircolors.c:99 src/uptime.c:199 src/users.c:105
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ФАЙЛ]\n"

#: src/basenc.c:106
msgid "basenc encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Кодиране/декодиране на входа от ФАЙЛ или стандартния вход към стандартния "
"изход\n"

#: src/basenc.c:110
#, c-format
msgid "Base%d encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"Кодиране/декодиране при основа %d на входа от ФАЙЛ или стандартния вход към "
"стандартния изход\n"

#: src/basenc.c:118
msgid "      --base64          same as 'base64' program (RFC4648 section 4)\n"
msgstr ""
"      --base64          същото като програмата „base64“ (RFC4648, раздел 4)\n"

#: src/basenc.c:121
msgid "      --base64url       file- and url-safe base64 (RFC4648 section 5)\n"
msgstr ""
"      --base64url       вариант на base64 като за имена на файлове и URL-и\n"
"                        (RFC4648, раздел 5)\n"

#: src/basenc.c:124
msgid "      --base32          same as 'base32' program (RFC4648 section 6)\n"
msgstr ""
"      --base32          същото като програмата „base32“ (RFC4648, раздел 6)\n"

#: src/basenc.c:127
msgid ""
"      --base32hex       extended hex alphabet base32 (RFC4648 section 7)\n"
msgstr ""
"      --base32hex       base32 с разширена шестнадесетична азбука\n"
"                        (RFC4648, раздел 7)\n"

#: src/basenc.c:130
msgid "      --base16          hex encoding (RFC4648 section 8)\n"
msgstr "      --base16          шестнадесетично кодиране (RFC4648, раздел 8)\n"

#: src/basenc.c:133
msgid ""
"      --base2msbf       bit string with most significant bit (msb) first\n"
msgstr "      --base2msbf       побитов низ със старши бит отпред\n"

#: src/basenc.c:136
msgid ""
"      --base2lsbf       bit string with least significant bit (lsb) first\n"
msgstr "      --base2lsbf       побитов низ със старши бит отзад\n"

#: src/basenc.c:140
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
"\n"
msgstr ""
"  -d, --decode          декодиране на данни\n"
"  -i, --ignore-garbage  прескачане на знаците извън 0-9, A-Z, a-z\n"
"  -w, --wrap=ЗНАЦИ      пренасяне на редовете на всеки толкова ЗНАЦИ "
"(стандартно\n"
"                        76).  С 0 пренасянето се изключва\n"
"\n"

#: src/basenc.c:148
msgid ""
"      --z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n"
"                        when encoding, input length must be a multiple of "
"4;\n"
"                        when decoding, input length must be a multiple of 5\n"
msgstr ""
"      --z85             кодиране, подобно на ascii85 (ZeroMQ спец.: 32/"
"Z85);\n"
"                          ⁃ при кодиране дължината на входа трябва да е\n"
"                            кратна на 4\n"
"                          ⁃ при декодиране дължината на входа трябва да е\n"
"                            кратна на 5\n"

#: src/basenc.c:157
msgid ""
"\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"При декодирането се приемат и нови редове към знаците от азбуката.\n"
"За да се продължи работата дори и при получаване на неправилни входни\n"
"данни, ползвайте опцията „--ignore-garbage“.\n"

#: src/basenc.c:164
#, c-format
msgid ""
"\n"
"The data are encoded as described for the %s alphabet in RFC 4648.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"Данните се кодират с азбука „%s“, както това е описано в RFC 4648.\n"
"При декодирането се приемат и нови редове към знаците от азбуката „%s“.\n"
"За да се продължи работата дори и при получаване на неправилни входни\n"
"данни, ползвайте опцията „--ignore-garbage“.\n"

#: src/basenc.c:619
msgid "invalid input (length must be multiple of 4 characters)"
msgstr "грешни входни данни (дължината им трябва да е кратна на 4)"

#: src/basenc.c:1009 src/basenc.c:1055 src/csplit.c:277 src/csplit.c:1468
#: src/join.c:465 src/shuf.c:233 src/shuf.c:279 src/shuf.c:559
#: src/tac-pipe.c:76 src/tee.c:263 src/tr.c:1611
#, c-format
msgid "read error"
msgstr "грешка при четене"

#: src/basenc.c:1074
msgid "invalid input"
msgstr "грешни входни данни"

#: src/basenc.c:1121
msgid "invalid wrap size"
msgstr "неправилен брой знаци, след които да се пренася"

#: src/basenc.c:1218
#, c-format
msgid "missing encoding type"
msgstr "видът кодиране липсва"

#: src/basenc.c:1256 src/cat.c:764
msgid "closing standard input"
msgstr "затваряне на стандартния вход"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:48 src/cp.c:47 src/df.c:48 src/du.c:54 src/factor.c:129
#: src/split.c:49
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:49 src/comm.c:38 src/ls.c:136 src/rm.c:42 src/split.c:50
#: src/tee.c:37 src/uniq.c:40
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:88 src/df.c:1511 src/expand.c:69 src/fold.c:66 src/head.c:110
#: src/ls.c:5342 src/nl.c:176 src/paste.c:436 src/pr.c:2737 src/rm.c:133
#: src/sum.c:59 src/tac.c:132 src/tail.c:265 src/tee.c:87 src/unexpand.c:78
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ФАЙЛ]…\n"

#: src/cat.c:92
msgid "Concatenate FILE(s) to standard output.\n"
msgstr "Последователно извеждане на ФАЙЛовете на стандартния изход\n"

#: src/cat.c:98
msgid ""
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"\n"
"  -A, --show-all           еквивалентно на „-vET“\n"
"  -b, --number-nonblank    номериране на непразните редове на изхода, с\n"
"                           предимство пред „-n“\n"
"  -e                       еквивалентно на „-vE“\n"
"  -E, --show-ends          извеждане на „$“ в края на всеки ред\n"
"  -n, --number             номериране на изведените редове\n"
"  -s, --squeeze-blank      съкращаване на всяка последователност от "
"множество\n"
"                           празни редове в един\n"

#: src/cat.c:107
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       еквивалентно на „-vT“\n"
"  -T, --show-tabs          изобразяване на табулациите като „^I“\n"
"  -u                       (пренебрегва се)\n"
"  -v, --show-nonprinting   вариант с „^“ и „M-“, освен за нов ред и "
"табулация\n"

#: src/cat.c:115
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"Примери:\n"
"  %s f - g  Извеждане на съдържанието на „f“, на полученото от стандартния\n"
"            изход и после на съдържанието на „g“\n"
"  %s        Копиране на стандартния вход на стандартния изход.\n"

#: src/cat.c:327
#, c-format
msgid "cannot do ioctl on %s"
msgstr "не може да се изпълни „ioctl“ за „%s“"

#: src/cat.c:638 src/dd.c:2492 src/sort.c:405 src/tail.c:2444 src/tee.c:207
#: src/yes.c:128
#, c-format
msgid "standard output"
msgstr "стандартен изход"

#: src/cat.c:699
#, c-format
msgid "%s: input file is output file"
msgstr "%s: входният файл е изходен файл"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/runcon.c:57
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:38 src/chgrp.c:39 src/chmod.c:40 src/chown.c:38 src/cp.c:49
#: src/cut.c:47 src/dirname.c:33 src/du.c:57 src/head.c:48 src/hostid.c:32
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:44 src/nohup.c:34 src/od.c:40
#: src/pathchk.c:33 src/pwd.c:32 src/rm.c:43 src/sleep.c:34 src/sync.c:33
#: src/tail.c:79 src/tr.c:38 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:101 src/runcon.c:202 src/runcon.c:233
#, c-format
msgid "failed to create security context: %s"
msgstr "контекстът за сигурност „%s“ не може да се създаде"

#: src/chcon.c:113
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "контекстът за сигурност на „%s“ не може да се зададе на „%s“"

#: src/chcon.c:157 src/chcon.c:548 src/copy.c:958 src/runcon.c:216
#: src/stat.c:833
#, c-format
msgid "failed to get security context of %s"
msgstr "неуспешно получаване на контекста за сигурност на „%s“"

#: src/chcon.c:167
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "на файла без етикети „%s“ не може да се приложи частичен контекст"

#: src/chcon.c:191
#, c-format
msgid "failed to change context of %s to %s"
msgstr "неуспешна смяна на контекста на „%s“ да е „%s“"

#: src/chcon.c:256 src/chmod.c:218 src/chown-core.c:324 src/copy.c:759
#: src/du.c:533 src/ls.c:3436
#, c-format
msgid "cannot access %s"
msgstr "няма достъп до „%s“"

#: src/chcon.c:267 src/chmod.c:231 src/chown-core.c:337 src/du.c:513
#, c-format
msgid "cannot read directory %s"
msgstr "директорията „%s“ не може да се чете"

#: src/chcon.c:294
#, c-format
msgid "changing security context of %s\n"
msgstr "смяна на контекста за сигурност на „%s“\n"

#: src/chcon.c:328 src/chmod.c:349 src/chown-core.c:538 src/remove.c:601
#: src/selinux.c:323
#, c-format
msgid "fts_read failed"
msgstr "неуспешно изпълнение на „fts_read“"

#: src/chcon.c:339 src/chmod.c:360 src/chown-core.c:550 src/du.c:714
#: src/remove.c:615 src/selinux.c:334
#, c-format
msgid "fts_close failed"
msgstr "неуспешно изпълнение на „fts_close“"

#: src/chcon.c:353
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… КОНТЕКСТ ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… [-u ПОТРЕБИТЕЛ] [-r РОЛЯ] [-l ДИАПАЗОН] [-t ВИД] "
"ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chcon.c:359
msgid ""
"Change the SELinux security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""
"Задаване на този КОНТЕКСТ на SELinux за сигурност на всеки ФАЙЛ.  С опцията\n"
"„--reference“ се използва контекстът за сигурност от ФАЙЛа_ЕТАЛОН.\n"

#: src/chcon.c:366 src/chgrp.c:125 src/chown.c:95
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"      --dereference      работа с обекта, сочен от символната връзка, а не\n"
"                         с нея (стандартно)\n"
"  -h, --no-dereference   работа със самата символна връзка, а не със "
"сочения\n"
"                         от нея обект\n"

#: src/chcon.c:371
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""
"  -u, --user=ПОТРЕБИТЕЛ  задаване на този ПОТРЕБИТЕЛ в целевия контекст\n"
"  -r, --role=РОЛЯ        задаване на тази РОЛЯ в целевия контекст\n"
"  -t, --type=ВИД         задаване на този ВИД в целевия контекст\n"
"  -l, --range=ДИАПАЗОН   задаване на този ДИАПАЗОН в целевия контекст\n"

#: src/chcon.c:377 src/chgrp.c:134 src/chmod.c:390 src/chown.c:111
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""
"      --no-preserve-root без специално третиране на „/“ (стандартно)\n"
"      --preserve-root    без рекурсивна работа в „/“\n"

#: src/chcon.c:381
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""
"      --reference=ФАЙЛ_ЕТАЛОН\n"
"                         използване на контекста от този ФАЙЛ_ЕТАЛОН вместо\n"
"                         изрично задаване\n"

#: src/chcon.c:385 src/chgrp.c:142 src/chown.c:119
msgid "  -R, --recursive        operate on files and directories recursively\n"
msgstr "  -R, --recursive        рекурсивна работа с директориите\n"

#: src/chcon.c:388
msgid "  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -v, --verbose          извеждане на съобщение след всеки обработен файл\n"

#: src/chcon.c:391 src/chgrp.c:145 src/chown.c:122
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"\n"
"Следните опции влияят на обхождането на йерархията, когато е посочена\n"
"и опция „-R“.  При посочване на повече от една от опциите „-H“, „-L“, „-P“\n"
"се взема предвид последната.\n"
"  -H                     ако аргумент от командния ред е символна връзка "
"към\n"
"                         директория, да се обходи и тя\n"
"  -L                     да се обхожда всяка директория, сочена от срещната\n"
"                         символна връзка\n"
"  -P                     без обхождане на символните връзки (стандартно)\n"

#: src/chcon.c:518 src/chgrp.c:266 src/chown.c:267
msgid "-R --dereference requires either -H or -L"
msgstr "„-R --dereference“ изисква „-H“ или „-L“"

#: src/chcon.c:524
msgid "-R -h requires -P"
msgstr "„-R -h“ изисква „-P“"

#: src/chcon.c:539 src/chgrp.c:281 src/chmod.c:531 src/chown.c:282
#: src/comm.c:483 src/csplit.c:1404 src/join.c:1161 src/link.c:78
#: src/mknod.c:173 src/tr.c:1756
#, c-format
msgid "missing operand after %s"
msgstr "липсващ операнд след „%s“"

#: src/chcon.c:563 src/runcon.c:250
#, c-format
msgid "invalid context: %s"
msgstr "неправилен контекст: „%s“"

#: src/chcon.c:569
#, c-format
msgid "conflicting security context specifiers given"
msgstr "зададените контексти за сигурност са несъвместими"

#: src/chcon.c:578 src/chgrp.c:289 src/chgrp.c:307 src/chmod.c:539
#: src/chmod.c:558 src/chown.c:290 src/chown.c:319 src/cp.c:422 src/cp.c:489
#: src/mv.c:99 src/pwd.c:276 src/rm.c:348 src/touch.c:348
#, c-format
msgid "failed to get attributes of %s"
msgstr "атрибутите на „%s“ не могат да се получат"

#: src/chgrp.c:93
#, c-format
msgid "invalid group: %s"
msgstr "неправилна група: „%s“"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… ГРУПА ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Задаване на тази ГРУПА на всеки от ФАЙЛовете.\n"
"При използване на опцията „--reference“ групата на всеки ФАЙЛ се привежда "
"към\n"
"същата както на ФАЙЛа_ЕТАЛОН.\n"

#: src/chgrp.c:120 src/chmod.c:385 src/chown.c:90
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -c, --changes          като „--verbose“, но само при промяна на групата\n"
"  -f, --silent, --quiet  без повечето съобщения за грешка\n"
"  -v, --verbose          диагностично съобщение при всеки обработен файл\n"

#: src/chgrp.c:130 src/chown.c:100
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"                         (само при системи, позволяващи промяна на\n"
"                         собствеността на символна връзка)\n"

#: src/chgrp.c:138
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""
"      --reference=ФАЙЛ_ЕТАЛОН\n"
"                         използване на ГРУПАта от ФАЙЛа_ЕТАЛОН, вместо\n"
"                         изричното ѝ задаване\n"

#: src/chgrp.c:160
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"Примери:\n"
"  %s staff /u      задаване на групата на „/u“ да е „staff“.\n"
"  %s -hR staff /u  задаване на групата на „/u“ и файловете в нея да е "
"„staff“.\n"

#: src/chmod.c:127
#, c-format
msgid "getting new attributes of %s"
msgstr "получават се новите атрибути на „%s“"

#: src/chmod.c:151 src/chown-core.c:146
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "нито символната връзка „%s“, нито соченият файл бяха променени\n"

#: src/chmod.c:165
#, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "режимът за достъп до „%s“ е променен от %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:168
#, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr ""
"неуспешна промяна на режима за достъп до „%s“ от %04lo (%s) на %04lo (%s)\n"

#: src/chmod.c:171
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "режимът за достъп до „%s“ е запазен да е %04lo (%s)\n"

#: src/chmod.c:238
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "неуспешна работа със символна връзка, която не сочи наникъде: „%s“"

#: src/chmod.c:278
#, c-format
msgid "changing permissions of %s"
msgstr "променят се правата за достъп до „%s“"

#: src/chmod.c:314
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%s: новият режим за достъп е %s, а не %s"

#: src/chmod.c:374
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… РЕЖИМ[,РЕЖИМ]… ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… ОСМИЧЕН_РЕЖИМ ФАЙЛ…\n"
"     или: %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chmod.c:380
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"Задаване на този РЕЖИМ на достъп на всеки от ФАЙЛовете.\n"
"При използване на опцията „--reference“ режимът на всеки ФАЙЛ се привежда "
"към\n"
"същия както на ФАЙЛа_ЕТАЛОН.\n"

#: src/chmod.c:394
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr ""
"      --reference=ФАЙЛ_ЕТАЛОН\n"
"                         използване на РЕЖИМа на достъп от ФАЙЛа_ЕТАЛОН, "
"вместо\n"
"                         изричното му задаване\n"

#: src/chmod.c:397
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr ""
"-R, --recursive               рекурсивна смяна на режима на достъп на "
"файловете\n"
"                              и директориите\n"

#: src/chmod.c:402
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"Всеки РЕЖИМ е от вида „[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+“.\n"

#: src/chmod.c:516
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "опциите за режим и опцията „--reference“ са несъвместими"

#: src/chmod.c:547
#, c-format
msgid "invalid mode: %s"
msgstr "неправилен режим за достъп %s"

#: src/chown-core.c:157
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "собственикът на „%s“ е сменен от „%s“ на „%s“\n"

#: src/chown-core.c:158
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "групата на „%s“ е сменена от „%s“ на „%s“\n"

#: src/chown-core.c:159
#, c-format
msgid "no change to ownership of %s\n"
msgstr "без промяна на собственика на %s\n"

#: src/chown-core.c:164
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "неуспешна смяна на собственика на „%s“ от „%s“ на „%s“\n"

#: src/chown-core.c:165
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "неуспешна смяна на групата на „%s“ от „%s“ на „%s“\n"

# смяна или промяна
#: src/chown-core.c:166 src/chown-core.c:172
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "неуспешна промяна на собственик на „%s“\n"

#: src/chown-core.c:170
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "неуспешна промяна на собственик на „%s“ на „%s“\n"

#: src/chown-core.c:171
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "неуспешна промяна на групата на „%s“ на „%s“\n"

#: src/chown-core.c:179
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "собственикът на „%s“ остана „%s“\n"

#: src/chown-core.c:180
#, c-format
msgid "group of %s retained as %s\n"
msgstr "групата на „%s“ остана „%s“\n"

#: src/chown-core.c:181
#, c-format
msgid "ownership of %s retained\n"
msgstr "собственикът на „%s“ остана непроменен\n"

#: src/chown-core.c:378
#, c-format
msgid "cannot dereference %s"
msgstr "символната връзка „%s“ не може да бъде последвана"

#: src/chown-core.c:466
#, c-format
msgid "changing ownership of %s"
msgstr "собственикът на „%s“ се променя"

#: src/chown-core.c:467
#, c-format
msgid "changing group of %s"
msgstr "групата на „%s“ се променя"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [СОБСТВЕНИК][:[ГРУПА]] ФАЙЛ…\n"
"    или:  %s [ОПЦИЯ]… --reference=ФАЙЛ_ЕТАЛОН ФАЙЛ…\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""
"Задаване на този СОБСТВЕНИК (и евентуално ГРУПА) на всеки от ФАЙЛовете.  "
"При\n"
"използване на опцията „--reference“ собственикът (и евентуално групата) на\n"
"всеки ФАЙЛ се привежда към същите както на ФАЙЛа_ЕТАЛОН.\n"
"\n"

#: src/chown.c:104
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=ТЕКУЩ_СОБСТВЕНИК:ТЕКУЩА_ГРУПА\n"
"                         собственикът и/или групата на всеки файл се "
"променя,\n"
"                         само ако текущият му собственик и/или група "
"отговарят\n"
"                         на посочените.  Всяко от двете може да се изпусне, "
"при\n"
"                         което съответствие с пропуснатия атрибут не е "
"нужно.\n"

#: src/chown.c:115
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
"      --reference=ФАЙЛ_ЕТАЛОН\n"
"                         използване на СОБСТВЕНИКа:ГРУПАта от ФАЙЛа_ЕТАЛОН,\n"
"                         вместо изричното им задаване\n"

#: src/chown.c:137
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"Ако СОБСТВЕНИК не е посочен, той остава непроменен.  Ако ГРУПА не е "
"посочена,\n"
"тя остава непроменена, освен ако след СОБСТВЕНИКа има „:“ — тогава групата "
"се\n"
"задава на тази, с която новият собственик стандартно влиза в системата.\n"
"СОБСТВЕНИКът и ГРУПАта могат да бъдат указани както с номера, така и с "
"имена.\n"

#: src/chown.c:143
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"Примери:\n"
"  %s root /u       собственикът на „/u“ да е „root“.\n"
"  %s root:staff /u подобно, но и групата да е „staff“.\n"
"  %s -hR root /u   собственикът на „/u“ и файловете в „/u“ да е „root“.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:39
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:139 src/install.c:608
#, c-format
msgid "invalid group %s"
msgstr "неправилна група „%s“"

#: src/chroot.c:154
#, c-format
msgid "invalid group list %s"
msgstr "неправилен списък с групи „%s“"

#: src/chroot.c:187
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… КОРЕНОВА_ДИРЕКТОРИЯ [КОМАНДА [АРГУМЕНТ…]]\n"
"     или: %s ОПЦИЯ\n"

#: src/chroot.c:192
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr "Изпълняване на КОМАНДАта с тази КОРЕНОВА_ДИРЕКТОРИЯ.\n"

#: src/chroot.c:197
msgid "  --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""
"  --groups=ГРУПА_1[,…]   задаване на допълнителни ГРУПА_1, ГРУПА_2 и т.н.\n"

#: src/chroot.c:200
msgid "  --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
msgstr ""
"  --userspec=ПОТРЕБИТЕЛ:ГРУПА\n"
"                         задаване на ПОТРЕБИТЕЛя и ГРУПАта, които да се "
"ползват\n"
"                         (чрез име или идентификатор)\n"

#: src/chroot.c:203
#, c-format
msgid "  --skip-chdir           do not change working directory to %s\n"
msgstr "  --skip-chdir           без смяна на директорията към „%s“\n"

#: src/chroot.c:209
msgid ""
"\n"
"If no command is given, run '\"$SHELL\" -i' (default: '/bin/sh -i').\n"
msgstr ""
"\n"
"Ако не е посочена команда, се изпълнява „\"${SHELL}\" -i“ (стандартно: „/bin/"
"sh -i“)\n"

#: src/chroot.c:288
#, c-format
msgid "option --skip-chdir only permitted if NEWROOT is old %s"
msgstr ""
"опцията „--skip-chdir“ е позволена, само ако новата КОРЕНОВА_ДИРЕКТОРИЯ е "
"предишната директория „%s“"

#: src/chroot.c:331
#, c-format
msgid "cannot change root directory to %s"
msgstr "кореновата директория не може да се смени на „%s“"

#: src/chroot.c:335
msgid "cannot chdir to root directory"
msgstr "с „chdir“ не може да се влиза в кореновата директория"

#: src/chroot.c:377
#, c-format
msgid "no group specified for unknown uid: %d"
msgstr "не е указана група за непознатия идентификатор на потребител: %d"

#: src/chroot.c:402
msgid "failed to get supplemental groups"
msgstr "допълнителните групи не могат да бъдат получени"

#: src/chroot.c:414
msgid "failed to set supplemental groups"
msgstr "допълнителните групи не могат да бъдат зададени"

#: src/chroot.c:420
msgid "failed to set group-ID"
msgstr "идентификаторът на група не може да бъде зададен"

#: src/chroot.c:423
msgid "failed to set user-ID"
msgstr "идентификаторът на потребител не може да бъде зададен"

#: src/chroot.c:429 src/nohup.c:222 src/stdbuf.c:392 src/timeout.c:519
#, c-format
msgid "failed to run command %s"
msgstr "командата „%s“ не може да бъде изпълнена"

#. This is a proper name. See the gettext manual, section Names.
#: src/cksum.c:40
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#: src/cksum.c:210
#, c-format
msgid "%s: file too long"
msgstr "%s: файлът е твърде дълъг"

#: src/cksum.c:257
#, c-format
msgid ""
"Usage: %s [FILE]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Употреба: %s [ФАЙЛ]…\n"
"     или: %s [ОПЦИЯ]\n"

#: src/cksum.c:262
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
msgstr ""
"Извеждане на контролната сума и броя байтове на всеки ФАЙЛ.\n"
"\n"

#: src/comm.c:112 src/join.c:192
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ_1 ФАЙЛ_2\n"

#: src/comm.c:116
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "Поредово сравняване на подредените файлове ФАЙЛ_1 и ФАЙЛ_2.\n"

#: src/comm.c:119 src/join.c:201
msgid ""
"\n"
"When FILE1 or FILE2 (not both) is -, read standard input.\n"
msgstr ""
"\n"
"Ако за ФАЙЛ_1 или ФАЙЛ_2 (но не и двете) е използвано „-“, се чете от "
"стандартния вход.\n"

#: src/comm.c:123
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"Без опции се извежда информация в триколонен формат.  Първият стълб съдържа\n"
"редовете, които са само във ФАЙЛ_1.  Вторият стълб съдържа редовете, които\n"
"са само във ФАЙЛ_2.  Третият стълб съдържа редовете, общи и за двата файла.\n"

#: src/comm.c:129
msgid ""
"\n"
"  -1              suppress column 1 (lines unique to FILE1)\n"
"  -2              suppress column 2 (lines unique to FILE2)\n"
"  -3              suppress column 3 (lines that appear in both files)\n"
msgstr ""
"\n"
"  -1              без извеждане на редовете, които са само във ФАЙЛ_1\n"
"  -2              без извеждане на редовете, които са само във ФАЙЛ_2\n"
"  -3              без извеждане на редовете, които се появяват и в двата "
"файла\n"

#: src/comm.c:135
msgid ""
"\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"  --check-order     проверка за правилна подредба на входните редове, дори "
"и\n"
"                    всички да са били успешно напаснати\n"
"  --nocheck-order   без проверка за правилна подредба на входните редове\n"

#: src/comm.c:141
msgid "  --output-delimiter=STR  separate columns with STR\n"
msgstr "  --output-delimiter=НИЗ  разделяне на колоните с този НИЗ\n"

#: src/comm.c:144
msgid "  --total           output a summary\n"
msgstr "  --total           извеждане на обобщение\n"

#: src/comm.c:147 src/cut.c:178 src/head.c:134 src/numfmt.c:945 src/paste.c:452
#: src/tail.c:312
msgid "  -z, --zero-terminated    line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     завършване на редовете с нулев байт вместо с нов "
"ред\n"

#: src/comm.c:152
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"ПРЕДУПРЕЖДЕНИЕ: сравненията зачитат настройката на локала „LC_COLLATE“.\n"

#: src/comm.c:156
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"Примери:\n"
"  %s -12 ФАЙЛ_1 ФАЙЛ_2  извеждане само на съответстващите редове в двата "
"файла\n"
"  %s  -3 ФАЙЛ_1 ФАЙЛ_2  извеждане само на редовете, които не си "
"съответстват\n"

#: src/comm.c:238
#, c-format
msgid "file %d is not in sorted order"
msgstr "ФАЙЛ_%d не е подреден"

#: src/comm.c:402 src/du.c:1137 src/ls.c:3067 src/wc.c:885
msgid "total"
msgstr "общо"

#: src/comm.c:458
msgid "multiple output delimiters specified"
msgstr "указани са множество разделители на изхода"

#: src/comm.c:496 src/join.c:1195
msgid "input is not in sorted order"
msgstr "входът не е подреден"

#: src/copy.c:230 src/copy.c:499
#, c-format
msgid "cannot lseek %s"
msgstr "не може да се препозиционира с „lseek“ в „%s“"

#: src/copy.c:240 src/copy.c:605
#, c-format
msgid "error deallocating %s"
msgstr "грешка при връщане на заделената памет за „%s“"

#: src/copy.c:278 src/dd.c:1928 src/dd.c:2264 src/du.c:1134 src/head.c:157
#: src/head.c:308 src/head.c:390 src/head.c:586 src/head.c:668 src/head.c:737
#: src/head.c:787 src/head.c:810 src/tail.c:464 src/tail.c:557 src/tail.c:606
#: src/tail.c:699 src/tail.c:827 src/tail.c:875 src/tail.c:912 src/tail.c:2037
#: src/tail.c:2070 src/uniq.c:461
#, c-format
msgid "error reading %s"
msgstr "грешка при четене на „%s“"

#: src/copy.c:311 src/dd.c:2327 src/dd.c:2389 src/head.c:185 src/tail.c:438
#, c-format
msgid "error writing %s"
msgstr "грешка при записа на „%s“"

#: src/copy.c:340
#, c-format
msgid "overflow reading %s"
msgstr "препълване при четене на „%s“"

#: src/copy.c:453
#, c-format
msgid "%s: failed to get extents info"
msgstr "%s: неуспешно получаване на информацията за обхватите"

#: src/copy.c:525
#, c-format
msgid "%s: write failed"
msgstr "%s: неуспешен запис"

#: src/copy.c:598 src/copy.c:1342
#, c-format
msgid "failed to extend %s"
msgstr "неуспешно разширяване на „%s“"

#: src/copy.c:840
#, c-format
msgid "clearing permissions for %s"
msgstr "задаване на правата за достъп до „%s“"

#: src/copy.c:875 src/copy.c:2791 src/cp.c:318
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "собствеността на „%s“ не можа да се запази"

#: src/copy.c:901
#, c-format
msgid "failed to lookup file %s"
msgstr "файлът „%s“ не може да се търси"

#: src/copy.c:906
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "авторството на „%s“ не можа да се запази"

#: src/copy.c:943 src/cp.c:1205 src/install.c:961 src/mkdir.c:269
#: src/mkfifo.c:144 src/mknod.c:200
#, c-format
msgid "failed to set default file creation context to %s"
msgstr ""
"неуспешно задаване на стандартния контекст за създаването на файла да е „%s“"

#: src/copy.c:973
#, c-format
msgid "failed to set default file creation context for %s"
msgstr ""
"неуспешно задаване на стандартния контекст за създаването на файла „%s“"

#: src/copy.c:999
#, c-format
msgid "failed to set the security context of %s"
msgstr "неуспешно задаване на контекста за сигурност на „%s“"

#: src/copy.c:1072 src/csplit.c:655 src/du.c:1026 src/fmt.c:439 src/head.c:889
#: src/split.c:1570 src/tail.c:2011 src/wc.c:770
#, c-format
msgid "cannot open %s for reading"
msgstr "„%s“ не може да се отвори за четене"

#: src/copy.c:1078 src/copy.c:1231 src/dd.c:1853 src/dd.c:2401 src/dd.c:2536
#: src/head.c:848 src/tail.c:1851 src/tail.c:1914 src/truncate.c:114
#, c-format
msgid "cannot fstat %s"
msgstr "не може да се получи информация с „fstat“ за „%s“"

#: src/copy.c:1088
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "файлът „%s“ се пропуска, тъй като бе заместен по време на копирането"

#: src/copy.c:1128 src/copy.c:2221 src/remove.c:263 src/remove.c:280
#: src/remove.c:406 src/remove.c:432
#, c-format
msgid "cannot remove %s"
msgstr "„%s“ не може да се изтрие"

#: src/copy.c:1133 src/copy.c:1830 src/copy.c:2226 src/remove.c:376
#, c-format
msgid "removed %s\n"
msgstr "„%s“ е изтрит\n"

#: src/copy.c:1185
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "без опит за запис през символната връзка „%s“, защото не сочи наникъде"

#: src/copy.c:1223
#, c-format
msgid "cannot create regular file %s"
msgstr "не може да се създаде обикновен файл „%s“"

#: src/copy.c:1244
#, c-format
msgid "failed to clone %s from %s"
msgstr "„%s“ не може да се клонира от „%s“"

#: src/copy.c:1357 src/copy.c:2866
#, c-format
msgid "preserving times for %s"
msgstr "времената за „%s“ се запазват"

#: src/copy.c:1437 src/copy.c:1443 src/head.c:897 src/sync.c:164
#: src/touch.c:173 src/truncate.c:381
#, c-format
msgid "failed to close %s"
msgstr "неуспешно затваряне на „%s“"

#: src/copy.c:1719
#, c-format
msgid "%s: replace %s, overriding mode %04lo (%s)? "
msgstr ""
"%s: да се замести ли „%s“ (пренебрегване на правата за достъп: %04lo, „%s“)?"

#: src/copy.c:1720
#, c-format
msgid "%s: unwritable %s (mode %04lo, %s); try anyway? "
msgstr ""
"%s: не може да се пише в „%s“ (правата за достъп са: %04lo, „%s“).  Да се "
"направи ли опит? "

#: src/copy.c:1727
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: да се замести ли „%s“? "

#: src/copy.c:1797
#, c-format
msgid " (backup: %s)"
msgstr " (резервно копие: „%s“)"

#: src/copy.c:1807
msgid "failed to restore the default file creation context"
msgstr "неуспешно възстановяване на стандартния контекст при създаване"

#: src/copy.c:1825
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "не може да се направи твърда връзка „%s“ към „%s“"

#: src/copy.c:1936
#, c-format
msgid "-r not specified; omitting directory %s"
msgstr "опцията „-r“ липсва, директорията „%s“ се прескача"

#: src/copy.c:1937
#, c-format
msgid "omitting directory %s"
msgstr "директорията „%s“ се прескача"

#: src/copy.c:1960
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "ПРЕДУПРЕЖДЕНИЕ: изходния файл „%s“ е посочен повече от един път"

#: src/copy.c:2015 src/ln.c:275
#, c-format
msgid "%s and %s are the same file"
msgstr "„%s“ и „%s“ са един и същ файл"

#: src/copy.c:2105
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "„%s“ не е директория и не може да се замести с директорията „%s“"

#: src/copy.c:2123 src/ln.c:246
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "току що създаденият „%s“ няма да бъде заместен с „%s“"

#: src/copy.c:2141
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "директорията „%s“ не може да се замести с файл, който не е директория"

#: src/copy.c:2155
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr ""
"директория не може да се премести върху файл, който не е директория: „%s“ → "
"„%s“"

#: src/copy.c:2182
#, c-format
msgid "backing up %s might destroy source;  %s not moved"
msgstr ""
"резервното копиране на „%s“ може да унищожи източника — без преместване на "
"„%s“"

#: src/copy.c:2183
#, c-format
msgid "backing up %s might destroy source;  %s not copied"
msgstr ""
"резервното копиране на „%s“ може да унищожи източника — без копиране на „%s“"

#: src/copy.c:2205 src/ln.c:305
#, c-format
msgid "cannot backup %s"
msgstr "не може да се направи резервно копие на „%s“"

#: src/copy.c:2260
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "„%s“ няма да се копира през току що създадената символна връзка „%s“"

#: src/copy.c:2340
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "директорията „%s“ не може да се копира в себе си „%s“"

#: src/copy.c:2348
#, c-format
msgid "warning: source directory %s specified more than once"
msgstr "ПРЕДУПРЕЖДЕНИЕ: изходната директория „%s“ е указана повече от веднъж"

#: src/copy.c:2374
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "няма да се направи твърда връзка „%s“ към директорията „%s“"

#: src/copy.c:2398
#, c-format
msgid "renamed "
msgstr "преименуван"

#: src/copy.c:2436
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "„%s“ не може да се премести в поддиректорията си „%s“"

#: src/copy.c:2479
#, c-format
msgid "cannot move %s to %s"
msgstr "„%s“ не може да се премести в „%s“"

#: src/copy.c:2495
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr ""
"преместването между устройства не успя (от „%s“ в „%s“).  Целевият файл не "
"можа да се изтрие"

#: src/copy.c:2503
#, c-format
msgid "copied "
msgstr "копиран "

#: src/copy.c:2540
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "цикличната символна връзка „%s“ не може да се копира"

#: src/copy.c:2602
#, c-format
msgid "created directory %s\n"
msgstr "създадена е директория „%s“\n"

#: src/copy.c:2665
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr ""
"%s: относителни символни връзки може да се правят само в текущата директория"

#: src/copy.c:2675
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "символната връзка „%s“ към „%s“ не може да се създаде"

#: src/copy.c:2729 src/mkfifo.c:170
#, c-format
msgid "cannot create fifo %s"
msgstr "именуваният канал „%s“ не може да се създаде"

#: src/copy.c:2738
#, c-format
msgid "cannot create special file %s"
msgstr "специалният файл „%s“ не може да се създаде"

#: src/copy.c:2749 src/ls.c:3648 src/stat.c:1477
#, c-format
msgid "cannot read symbolic link %s"
msgstr "символната връзка „%s“ не може да се прочете"

#: src/copy.c:2775
#, c-format
msgid "cannot create symbolic link %s"
msgstr "символната връзка „%s“ не може да се създаде"

#: src/copy.c:2807
#, c-format
msgid "%s has unknown file type"
msgstr "„%s“ е непознат вид файл"

#: src/copy.c:2972 src/ln.c:393
#, c-format
msgid "cannot un-backup %s"
msgstr "не може да се възстанови от резервно копие „%s“"

#: src/copy.c:2976
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "„%s“ →  „%s“ (от резервно копие)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/coreutils.c:48
msgid "Alex Deymo"
msgstr "Alex Deymo"

#: src/coreutils.c:65
#, c-format
msgid "Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"
msgstr "Употреба: %s --coreutils-prog=ПРОГРАМА [ПАРАМЕТЪР]… \n"

#: src/coreutils.c:68
msgid ""
"Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n"
"\n"
msgstr ""
"Изпълнение на вградената ПРОГРАМА със зададените ПАРАМЕТри.\n"
"\n"

#: src/coreutils.c:86
#, c-format
msgid ""
"\n"
"Use: '%s --coreutils-prog=PROGRAM_NAME --help' for individual program help.\n"
msgstr ""
"\n"
"Употреба: „%s --coreutils-prog=ПРОГРАМА --help“ за помощта към ПРОГРАМАта.\n"

#: src/coreutils.c:178 src/coreutils.c:203
#, c-format
msgid "unknown program %s"
msgstr "непозната програма „%s“"

#: src/cp.c:148 src/mv.c:292
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-T] ИЗТОЧНИК ЦЕЛ\n"
"     или: %s [ОПЦИЯ]… ИЗТОЧНИК… ДИРЕКТОРИЯ\n"
"     или: %s [ОПЦИЯ]… -t ДИРЕКТОРИЯ ИЗТОЧНИК…\n"

#: src/cp.c:154
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr "Копиране на ИЗТОЧНИКа в ЦЕЛта или много ИЗТОЧНИ(ци) в ДИРЕКТОРИЯта.\n"

#: src/cp.c:160
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive                същото като „-dR --preserve=all“\n"
"      --attributes-only        без копиране на данните, а само на "
"атрибутите\n"
"      --backup[=МЕТОД]         резервно копие на съществуващите целеви "
"файлове\n"
"  -b                           като „--backup“, но не приема аргументи\n"
"      --copy-contents          копиране на съдържанието на специалните "
"файлове\n"
"                               при рекурсивна работа\n"
"  -d                           същото като „--no-dereference --"
"preserve=link“\n"

#: src/cp.c:169
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  съществуващите целеви файлове, които не може "
"да\n"
"                               се отворят, се изтриват и се опитва наново.\n"
"                               Тази опция се прескача, ако е ползвана  „-n“\n"
"  -i, --interactive            питане преди заместване\n"
"  -H                           следване на символните връзка от ИЗТОЧНИКа "
"на\n"
"                               командния ред\n"

#: src/cp.c:178
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   създаване на твърди връзки вместо копиране\n"
"  -L, --dereference            символните връзки в ИЗТОЧНИКа да се следват\n"

#: src/cp.c:182
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber             без презаписване на съществуващ файл (отменя\n"
"                               предшестваща опция „-i“)\n"
"  -P, --no-dereference         без следване на символните връзки в "
"ИЗТОЧНИКа\n"

#: src/cp.c:187
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p                           като „--preserve=mode,ownership,timestamps“\n"
"      --preserve[=АТРИБУТ[,…]] запазване на посочените АТРИБУТи "
"(стандартно:\n"
"                               „mode,ownership,timestamps“), а при "
"възможност и\n"
"                               следните допълнителни атрибути: „Context“,\n"
"                               „Links“, „xattr“, „all“\n"

#: src/cp.c:195
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --no-preserve=АТРИБУТ[,…]\n"
"                               без запазване на посочените АТРИБУТи\n"
"      --parents                използване на пълното име на файла под\n"
"                               ДИРЕКТОРИЯта\n"

#: src/cp.c:199
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive          рекурсивно копиране на директориите\n"
"      --reflink[=КОГА]         управление на клонирането/копирането при "
"запис.\n"
"                               Вж. по-долу\n"
"      --remove-destination     изтриване на всеки съществуващ целеви файл, "
"преди\n"
"                               да се опитва отваряне (сравнете с „--force“)\n"

#: src/cp.c:205
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=КОГА            управление на създаването на рехави файлове\n"
"      --strip-trailing-slashes изчистване на крайните „/“ от всеки ИЗТОЧНИК\n"

#: src/cp.c:210
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link         символни връзки вместо копиране\n"
"  -S, --suffix=СУФИКС         ползване на този СУФИКС за резервни копия\n"
"  -t, --target-directory=ДИР  в коя ДИРектория да се копира\n"
"  -T, --no-target-directory   работа с ЦЕЛта като с нормален файл\n"

#: src/cp.c:216
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 копиране, само ако ИЗТОЧНИКът е по-нов от\n"
"                               целевия файл или ако целевият файл липсва\n"
"  -v, --verbose                съобщаване какво се прави\n"
"  -x, --one-file-system        оставане в текущата файлова система\n"

#: src/cp.c:223
msgid ""
"  -Z                           set SELinux security context of destination\n"
"                                 file to default type\n"
"      --context[=CTX]          like -Z, or if CTX is specified then set the\n"
"                                 SELinux or SMACK security context to CTX\n"
msgstr ""
"  -Z                           задаване на стандартен контекст за сигурност "
"на\n"
"                               SELinux на целевия файл\n"
"      --context[=КОНТЕКСТ]     като „-Z“, а ако присъства КОНТЕКСТ, той се\n"
"                               задава вместо стандартния за SELinux или "
"SMACK\n"

#: src/cp.c:231
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
msgstr ""
"\n"
"Стандартно с груба евристика се разпознават кои файлове-ИЗТОЧНИци са "
"рехави.\n"
"Тогава и целевите файлове също се правят такива — все едно е дадена опцията\n"
"„-sparse=auto“.  При „--sparse=always“ целевите файлове се създават рехави,\n"
"винаги когато файловете-ИЗТОЧНИци съдържат достатъчно дълга "
"последователност\n"
"от нулеви байтове.  Ползвайте „--sparse=never“, за да избегнете създаването\n"
"на рехави файлове.\n"
"\n"

#: src/cp.c:239
msgid ""
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
"Use --reflink=never to ensure a standard copy is performed.\n"
msgstr ""
"\n"
"Опцията „--reflink[=always]“ указва евтино копиране — блоковете се копират,\n"
"само ако са променени.  Ако това не е възможно, копирането е неуспешно.\n"
"При „--reflink=auto“ първо се опитва евтино копиране, а след това — "
"нормално.\n"
"При „--reflink=never“ винаги се извършва нормално копиране.\n"

#: src/cp.c:247
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"По изключение — ако са зададени опции „--force“ и „--backup“, а ИЗТОЧНИКът "
"и\n"
"ЦЕЛта са едно и също име на съществуващ обикновен файл, ce прави резервно "
"копие\n"
"на ИЗТОЧНИКа.\n"

#: src/cp.c:306
#, c-format
msgid "failed to preserve times for %s"
msgstr "времената на „%s“ не можаха да се запазят"

#: src/cp.c:337
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "правата за достъп до „%s“ не можаха да се запазят"

#: src/cp.c:473
#, c-format
msgid "cannot make directory %s"
msgstr "директорията „%s“ не може да се създаде"

#: src/cp.c:522 src/cp.c:553
#, c-format
msgid "%s exists but is not a directory"
msgstr "„%s“ съществува, но не е директория"

#: src/cp.c:585 src/cp.c:1087 src/install.c:407 src/install.c:942 src/ln.c:204
#: src/ln.c:231 src/ln.c:536 src/mv.c:160 src/mv.c:393
#, c-format
msgid "failed to access %s"
msgstr "неуспешен достъп до „%s“"

#: src/cp.c:606 src/install.c:970 src/ln.c:567 src/mv.c:436 src/shred.c:1251
#: src/touch.c:430 src/truncate.c:318
#, c-format
msgid "missing file operand"
msgstr "липсващ файлов операнд"

#: src/cp.c:608 src/install.c:972 src/ln.c:590 src/mv.c:438
#, c-format
msgid "missing destination file operand after %s"
msgstr "липсващ операнд за целеви файл след „%s“"

#: src/cp.c:617 src/install.c:981 src/mv.c:447
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr ""
"опциите „--target-directory“/„-t“ и „--no-target-directory“/„-T“ са "
"несъвместими"

#: src/cp.c:635 src/cp.c:1090 src/install.c:409 src/install.c:945
#: src/install.c:994 src/ln.c:539 src/mv.c:396 src/mv.c:468
#, c-format
msgid "target %s is not a directory"
msgstr "целта „%s“ не е директория"

#: src/cp.c:745
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "опцията „--parents“ изисква целта да е директория"

#: src/cp.c:1082 src/install.c:882 src/ln.c:531 src/mv.c:388
msgid "multiple target directories specified"
msgstr "посочени са много целеви директории"

#: src/cp.c:1124 src/install.c:918
#, c-format
msgid "warning: ignoring --context; it requires an SELinux-enabled kernel"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--context“ се прескача, защото изисква ядро с "
"поддръжка на SELinux"

#: src/cp.c:1145
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "не може едновременно да се правят твърди и символни връзки"

#: src/cp.c:1155 src/mv.c:478
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "опциите „--backup“ и „--no-clobber“ са несъвместими"

#: src/cp.c:1161
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "опцията „--reflink“ изисква опцията „--sparse=auto“"

#: src/cp.c:1166 src/install.c:950 src/ln.c:637 src/mv.c:483
msgid "backup type"
msgstr "вид на резервните копия"

#: src/cp.c:1190 src/install.c:957
msgid "cannot set target context and preserve it"
msgstr "целевият контекст не може да бъде зададен и запазен"

#: src/cp.c:1194
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr ""
"контекстът за сигурност не може да бъде запазен, защото изисква ядро с "
"поддръжка на SELinux"

#: src/cp.c:1210
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr ""
"разширените атрибути не могат да бъдат запазени, защото командата „cp“ е "
"компилирана без поддръжката им"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:44 src/dd.c:46
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:545
msgid "input disappeared"
msgstr "входът изчезна"

#: src/csplit.c:676 src/csplit.c:688
#, c-format
msgid "%s: line number out of range"
msgstr "%s: номерът на ред е извън диапазона"

#: src/csplit.c:718
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s: %s: номерът на ред е извън диапазона"

#: src/csplit.c:721 src/csplit.c:777
#, c-format
msgid " on repetition %s\n"
msgstr " при повтаряне %s\n"

#: src/csplit.c:771
#, c-format
msgid "%s: %s: match not found"
msgstr "%s: %s: не е открито съответствие"

#: src/csplit.c:838 src/csplit.c:878 src/nl.c:357 src/tac.c:286
#, c-format
msgid "error in regular expression search"
msgstr "грешка при търсене чрез регулярен израз"

#: src/csplit.c:1007 src/csplit.c:1054
#, c-format
msgid "write error for %s"
msgstr "грешка при запис за %s"

#: src/csplit.c:1089
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s: след разделител се очаква цяло число"

#: src/csplit.c:1106
#, c-format
msgid "%s: '}' is required in repeat count"
msgstr "%s: „}“ е задължителен при указването на повторения"

#: src/csplit.c:1117
#, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr "%s}: между „{“ и „}“ е необходимо цяло число"

#: src/csplit.c:1144
#, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr "%s: липсва затварящ разделител „%c“"

#: src/csplit.c:1161
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: неправилен регулярен израз: %s"

#: src/csplit.c:1193
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: неправилен образец"

#: src/csplit.c:1196
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: номерът на ред трябва да бъде положителен"

#: src/csplit.c:1201
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "номерът на ред %s е по-малък от предходния номер: %s"

#: src/csplit.c:1207
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "ПРЕДУПРЕЖДЕНИЕ: номерът на ред %s съвпада с предходния номер на ред"

#: src/csplit.c:1285
msgid "missing conversion specifier in suffix"
msgstr "в суфикса липсва означител за преобразуване"

#: src/csplit.c:1290
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "неправилен означител за преобразуване в суфикса: %c"

#: src/csplit.c:1293
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "неправилен означител за преобразуване в суфикса: \\%.3o"

#: src/csplit.c:1298
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "неправилни флагове в означител за преобразуване: %%%c%c"

#: src/csplit.c:1315
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "твърде много означители за преобразуване %% в суфикса"

#: src/csplit.c:1329
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "липсва означител %% за преобразуване в суфикса"

#: src/csplit.c:1375 src/dd.c:1563 src/nproc.c:105 src/tail.c:2164
msgid "invalid number"
msgstr "грешно число"

#: src/csplit.c:1482
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ ШАБЛОН…\n"

#: src/csplit.c:1486
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""
"Извеждане на частите на ФАЙЛ, разделени според ШАБЛОНите и запис във "
"файлове\n"
"„xx01“, „xx02“, ….  Дължината им в байтове се извежда на стандартния изход.\n"

#: src/csplit.c:1490
msgid ""
"\n"
"Read standard input if FILE is -\n"
msgstr ""
"\n"
"Ако ФАЙЛът е „-“, се чете от стандартния вход.\n"

#: src/csplit.c:1497
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=ФОРМАТ ползване на ФОРМАТ на „sprintf“ вместо %02d\n"
"  -f, --prefix=ПРЕФИКС       ползване на ПРЕФИКС вместо „xx“\n"
"  -k, --keep-files           без изтриване на създадените файлове при "
"грешка\n"

#: src/csplit.c:1502
msgid "      --suppress-matched     suppress the lines matching PATTERN\n"
msgstr ""
"      --suppress-matched     без извеждане на редовете, напасващи с ШАБЛОНа\n"

#: src/csplit.c:1505
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=ЦИФРИ         ползване на посочения брой цифри вместо 2\n"
"  -s, --quiet, --silent      без извеждане на размерите на генерираните "
"файлове\n"
"  -z, --elide-empty-files    изтриване на генерираните празни файлове\n"

#: src/csplit.c:1512
msgid ""
"\n"
"Each PATTERN may be:\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required '+' or '-' followed by a positive integer.\n"
msgstr ""
"\n"
"Всеки от ШАБЛОНите може да е:\n"
"  ЦЯЛО_ЧИСЛО         копиране до посочения ред без включването му\n"
"  /РЕГУЛЯРЕН_ИЗРАЗ/[ОТМЕСТВАНЕ]\n"
"                     копиране до съответстващия ред без включването му\n"
"  /РЕГУЛЯРЕН_ИЗРАЗ/[ОТМЕСТВАНЕ]\n"
"                     пропускане до съответстващия ред без включването му\n"
"  {ЦЯЛО_ЧИСЛО}       повтаряне на предходния ШАБЛОН посочения брой пъти\n"
"  {*}                повтаряне на предходния ШАБЛОН максимален брой пъти\n"
"\n"
"ОТМЕСТВАНЕто е положително число, задължително предхождано от „+“ или „-“.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:45 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:147
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "Употреба: %s ОПЦИЯ… ФАЙЛ…\n"

#: src/cut.c:151
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr ""
"Извеждане на избраните части от редовете на всеки ФАЙЛ на стандартния "
"изход.\n"
"\n"

#: src/cut.c:158
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=СПИСЪК      извеждане само на тези байтове\n"
"  -c, --characters=СПИСЪК извеждане само на тези знаци\n"
"  -d, --delimiter=РАЗДЕЛ  РАЗДЕЛ вместо табулация като разделител между "
"полетата\n"

#: src/cut.c:163
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=СПИСЪК     извеждане само на полетата от СПИСЪКа.  Отпечатват "
"се\n"
"                          и редовете, които не съдържат разделители, освен  "
"ако\n"
"                          е зададена и опцията „-s“.\n"
"  -n                      (пренебрегва се)\n"

#: src/cut.c:169
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr ""
"      --complement        извеждане на всичко освен указаните байтове,\n"
"                          знаци или полета.\n"

#: src/cut.c:173
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    без извеждане на редове без разделители\n"
"      --output-delimiter=НИЗ\n"
"                          използване на посочения НИЗ като разделител на "
"изхода,\n"
"                          стандартно се ползва входният разделител\n"

#: src/cut.c:183
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"Опциите „-b“, „-c“ и „-f“ са взаимно несъвместими.  Всеки СПИСЪК се състои\n"
"от един или повече диапазони, разделени със „,“.  Указаната част от входа\n"
"се извежда в реда на изчитането точно веднъж.\n"

#: src/cut.c:189
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
msgstr ""
"Диапазоните могат да са:\n"
"\n"
"  N     N-тият байт, знак или поле, броейки от 1\n"
"  N-    от N-тия байт, знак или поле (включително) до края на реда\n"
"  N-M   от N-тия до M-тия байт, знак или поле (включително)\n"
"  -N    от началото на реда до N-тия байт, знак или поле (включително)\n"

#: src/cut.c:511 src/cut.c:519
msgid "only one type of list may be specified"
msgstr "трябва да се посочи само един вид списък"

#: src/cut.c:528 src/numfmt.c:1521
msgid "the delimiter must be a single character"
msgstr "разделителят трябва да се състои от един знак"

#: src/cut.c:567
msgid "you must specify a list of bytes, characters, or fields"
msgstr "трябва да посочите списък байтове, знаци или полета"

#: src/cut.c:570
msgid "an input delimiter may be specified only when operating on fields"
msgstr "входен разделител може да се посочва, само ако се работи с полета"

#: src/cut.c:574
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"неизвеждането на редове, несъдържащи разделител, има смисъл,\n"
"само ако се работи с полета"

#: src/date.c:130
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [+ФОРМАТ]\n"
"     или: %s [-u|--utc|--universal] [ММДДччмм[[ГГ]ГГ][.сс]]\n"

#: src/date.c:135
msgid "Display the current time in the given FORMAT, or set the system date.\n"
msgstr ""
"Извеждане на текущата дата и време в дадения ФОРМАТ или задаване на "
"системните дата и време.\n"

#: src/date.c:141
msgid ""
"  -d, --date=STRING          display time described by STRING, not 'now'\n"
msgstr ""
"  -d, --date=НИЗ             извеждане на посоченото с НИЗа време, а не на\n"
"                             текущия момент\n"

#: src/date.c:144
msgid ""
"      --debug                annotate the parsed date,\n"
"                              and warn about questionable usage to stderr\n"
msgstr ""
"      --debug                обяснение на анализа на датата и "
"предупреждаване\n"
"                             за възможни проблеми на стандартния изход\n"

#: src/date.c:148
msgid ""
"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\n"
msgstr ""
"  -f, --file=ФАЙЛ_С_ДАТИ     като „--date“, но се изпълнява по веднъж за "
"всеки\n"
"                             ред от ФАЙЛа_С_ДАТИ\n"

#: src/date.c:151
msgid ""
"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n"
"                               FMT='date' for date only (the default),\n"
"                               'hours', 'minutes', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14T02:34:56-06:00\n"
msgstr ""
"  -I[ТОЧНОСТ], --iso-8601[=ТОЧНОСТ]\n"
"                             извеждане на датата/времето във формат ISO "
"8601.\n"
"                             ТОЧНОСТта може да е „date“ само за датата\n"
"                             (стандартно), „hours“ (часове), „minutes“\n"
"                             (минути), „seconds“ (секунди) или „ns“\n"
"                             (наносекунди) за извеждане на датата и времето "
"до\n"
"                             зададената точност.\n"
"                             Напр.: „2006-08-14T02:34:56-06:00“\n"

#: src/date.c:158
msgid ""
"  -R, --rfc-email            output date and time in RFC 5322 format.\n"
"                               Example: Mon, 14 Aug 2006 02:34:56 -0600\n"
msgstr ""
"  -R, --rfc-email            извеждане на датата и времето във формат RFC "
"5322.\n"
"                             Напр. „Mon, 14 Aug 2006 02:34:56 -0600“\n"

#: src/date.c:162
msgid ""
"      --rfc-3339=FMT         output date/time in RFC 3339 format.\n"
"                               FMT='date', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14 02:34:56-06:00\n"
msgstr ""
"      --rfc-3339=ТОЧНОСТ     извеждане на датата/времето във формат RFC "
"3339.\n"
"                             ТОЧНОСТта може да е „date“ само за датата\n"
"                             (стандартно), „seconds“ (секунди) или „ns“\n"
"                             (наносекунди) за извеждане на датата и времето "
"до\n"
"                             зададената точност.\n"
"                             Напр. „2006-08-14 02:34:56-06:00“\n"

#: src/date.c:168
msgid ""
"  -r, --reference=FILE       display the last modification time of FILE\n"
msgstr ""
"  -r, --reference=ФАЙЛ       извеждане на времето на промяна на ФАЙЛа\n"

#: src/date.c:171
msgid ""
"  -s, --set=STRING           set time described by STRING\n"
"  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n"
msgstr ""
"  -s, --set=НИЗ              задаване на момента време описан в НИЗа\n"
"  -u, --utc, --universal     извеждане или задаване на време в UTC\n"

#: src/date.c:177
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"ФОРМАТът управлява изхода.  Разпознават се следните низове във ФОРМА̀Та:\n"
"\n"
"  %%   знакът „%“\n"
"  %a   съкратено наименование на деня от седмицата според локала (пн, вт, "
"ср, …)\n"

#: src/date.c:184
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A   ден от седмицата според локала, променлива дължина (напр. понеделник, "
"…)\n"
"  %b   съкратено име на месеца според локала (яну, фев, мар, …)\n"
"  %B   име на месеца според локала, променлива дължина (напр. януари, …)\n"
"  %c   дата и час според локала (напр. „сб ное  4 12:02:33 EЕТ 1989“)\n"

#: src/date.c:190
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C   век, т.е. като „%Y“, но без последните две цифри (напр. 21)\n"
"  %d   ден от месеца (напр. 01)\n"
"  %D   дата — същото като „%m/%d/%y“\n"
"  %e   ден от месеца, допълнен с интервал — същото като „%_d“ (напр. „ 1“)\n"

#: src/date.c:196
msgid ""
"  %F   full date; like %+4Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   пълна дата — същото като „%+4Y-%m-%d“\n"
"  %g   последни две цифри на годината, съдържаща седмица с ISO № (вж. „%G“)\n"
"  %G   година, съдържаща седмица с ISO № (вж. „%V“, обикновено се "
"комбинира)\n"

#: src/date.c:201
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   същото като „%b“\n"
"  %H   час (00-23)\n"
"  %I   час (01-12)\n"
"  %j   поредeн ден в годината (001-366)\n"

#: src/date.c:207
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   час, допълнен с интервал (0-23) — същото като %_H (напр. „ 0“)\n"
"  %l   час, допълнен с интервал (1-12) — същото като %_I (напр. „ 1“)\n"
"  %m   месец (01-12)\n"
"  %M   минута (00-59)\n"

#: src/date.c:213
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %q   quarter of year (1..4)\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since 1970-01-01 00:00:00 UTC\n"
msgstr ""
"  %n   нов ред\n"
"  %N   наносекунди (000000000-999999999)\n"
"  %p   указател „AM“ или „PM“ с главни букви според локала\n"
"  %P   като „%p“, но с малки букви\n"
"  %q   тримесечие (1-4)\n"
"  %r   12-часово време според локала (напр. 11,11,04)\n"
"  %R   24-часово време, същото като %H:%M\n"
"  %s   секундите изминали от 1 януари 1970, 00:00:00 UTC\n"

#: src/date.c:223
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S   секунди (00-60); до 60, за да се обхване и коригираща секунда\n"
"  %t   хоризонтална табулация\n"
"  %T   24-часово време, същото като „%H:%M:%S“\n"
"  %u   ден от седмицата (1-7), 1 е понеделник\n"

#: src/date.c:229
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   номер на седмицата в годината, неделя е пръв ден от седмицата "
"(00-53)\n"
"  %V   номер на седмицата в годината, понеделник е пръв ден от седмицата "
"(01-53)\n"
"  %w   ден от седмицата (0-6), 0 е неделя\n"
"  %W   номер на седмицата в годината, понеделник е пръв ден от седмицата "
"(00-53)\n"

#: src/date.c:235
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x   дата според локала (напр. 31.12.99)\n"
"  %X   време според локала (напр. 23,13,48)\n"
"  %y   последни две цифри от годината (00-99)\n"
"  %Y   година\n"

#: src/date.c:241
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z     часови пояс като число (напр. -0400)\n"
"  %:z    часови пояс като час:минути (напр. -04:00)\n"
"  %::z   часови пояс като час:минути:секунди (напр. -04:00:00)\n"
"  %:::z  едно от горните само до необходимата точност (напр. -04, +05:30)\n"
"  %Z     съкращение на часовия пояс (напр. „EEST“ за времето в България)\n"
"\n"
"Стандартно „date“ допълва числовите полета с „0“.\n"

#: src/date.c:250
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  +  pad with zeros, and put '+' before future years with >4 digits\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"Следните флагове може да следват „%“:\n"
"\n"
"  ⁃ „-“   без допълване\n"
"  ⁃ „_“   допълване с интервали\n"
"  ⁃ „0“   допълване с нули\n"
"  ⁃ „^“   главни букви при възможност\n"
"  ⁃ „#“   малки букви при възможност\n"

#: src/date.c:260
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"Всеки флаг може да се следва от десетично число, което указва широчината на\n"
"полето, както и някой от следните модификатори:\n"
"\n"
"  ⁃ „E“ за алтернативното представяне според локала, ако го има\n"
"  ⁃ „O“ за алтернативните числови знаци според локала, ако ги има\n"

#: src/date.c:267
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""
"\n"
"Примери:\n"
"Преобразуване на секундите от епохата (1970-01-01 UTC) в дата\n"
"  $ date --date='@2147483647'\n"
"\n"
"Извеждане на времето в България (може да откриете часовия пояс с\n"
"командата „tzselect“(1))\n"
"  $ TZ='Europe/EET' gdate\n"
"\n"
"Извеждане на локалното време за 9ч. преди обед, следващия петък на\n"
"западното крайбрежие на САЩ:\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"

#: src/date.c:301 src/dd.c:2475 src/head.c:881 src/md5sum.c:672
#: src/md5sum.c:1107 src/od.c:915 src/od.c:1984 src/pr.c:1149 src/pr.c:1348
#: src/pr.c:1471 src/stty.c:1368 src/tac.c:574 src/tail.c:387 src/tee.c:174
#: src/tr.c:1911 src/tsort.c:535 src/wc.c:223
msgid "standard input"
msgstr "стандартен вход"

#: src/date.c:330 src/date.c:558
#, c-format
msgid "invalid date %s"
msgstr "неправилна дата %s"

#: src/date.c:444 src/date.c:478
msgid "multiple output formats specified"
msgstr "посочени са много формати за изхода"

#: src/date.c:456
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "посочените опции за дати за отпечатване са взаимно изключващи се"

#: src/date.c:463
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr ""
"не може едновременно да се използват опции за отпечатване и настройка на "
"времето"

#: src/date.c:484
#, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""
"липсва начален знак „+“ за аргумента „%s“.\n"
"При използване на опция за посочване на дата/дати всеки задължителен\n"
"аргумент трябва да бъде форматиращ низ, започващ с „+“."

#: src/date.c:566
#, c-format
msgid "cannot set date"
msgstr "датата не може да се настрои"

#: src/date.c:600 src/du.c:389
#, c-format
msgid "time %s is out of range"
msgstr "времето „%s“ е извън допустимия диапазон"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:44 src/factor.c:128 src/rm.c:40 src/tail.c:76 src/touch.c:42
#: src/wc.c:50
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:558
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба:  %s [ОПЕРАНД]…\n"
"     или:  %s ОПЦИЯ\n"

#: src/dd.c:563
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time (default: "
"512);\n"
"                  overrides ibs and obs\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"Копиране, преобразуване и форматиране на файл според посочените операнди.\n"
"\n"
"  bs=БАЙТОВЕ      четене и запис на парчета от по максимум толкова БАЙТОВЕ\n"
"                  (стандартно: 512)\n"
"  cbs=БАЙТОВЕ     преобразуване на парчета от по толкова БАЙТОВЕ\n"
"  conv=КЛЮЧ_ДУМИ  преобразуване на файла съгласно КЛЮЧовите_ДУМИ\n"
"  count=БРОЙ      копиране на този БРОЙ входни блока\n"
"  ibs=БАЙТОВЕ     четене на парчета от по максимум толкова БАЙТОВЕ\n"
"                  (стандартно: 512)\n"

#: src/dd.c:573
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          skip N obs-sized blocks at start of output\n"
"  skip=N          skip N ibs-sized blocks at start of input\n"
"  status=LEVEL    The LEVEL of information to print to stderr;\n"
"                  'none' suppresses everything but error messages,\n"
"                  'noxfer' suppresses the final transfer statistics,\n"
"                  'progress' shows periodic transfer statistics\n"
msgstr ""
"  if=ФАЙЛ         четене от този ФАЙЛ вместо от стандартния вход\n"
"  iflag=ФЛАГ,…    четене според посочените ФЛАГове\n"
"  obs=БАЙТОВЕ     запис на парчета от по толкова БАЙТОВЕ\n"
"  of=ФАЙЛ         запис в този ФАЙЛ, вместо на стандартния изход\n"
"  oflag=ФЛАГ,…    запис според посочените ФЛАГове\n"
"  seek=БРОЙ       пропускане на този БРОЙ изходни блока, всеки с размер obs\n"
"  skip=БРОЙ       пропускане на този БРОЙ входни блока, всеки с размер ibs\n"
"  status=НИВО     НИВОто на информативност на изведената информация на\n"
"                  стандартната грешка:\n"
"                    ⁃ „none“: само грешки\n"
"                    ⁃ „noxfer“: без крайната статистика\n"
"                    ⁃ „progress“: периодична статистика на трансфера\n"

#: src/dd.c:586
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n"
"GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"Стойностите приемат следните суфикси-множители:\n"
"c≡1, w≡2, b≡512, kB≡1000, K≡1024, MB≡1000*1000, M≡1024*1024, xM≡M\n"
"GB≡1000*1000*1000, G≡1024*1024*1024 и т.н. за „T“, „P“, „E“, „Z“ и „Y“.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"
"\n"
"КЛЮЧовите_ДУМИ са някои от:\n"

#: src/dd.c:596
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write all-NUL output blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii     от EBCDIC към ASCII\n"
"  ebcdic    от ASCII към EBCDIC\n"
"  ibm       от ASCII към алтернативен EBCDIC\n"
"  block     запълване на блоковете, завършващи с нов ред, с интервали\n"
"            до размер cbs\n"
"  unblock   замяна на крайните интервали във всеки блок с размер cbs\n"
"            с нови редове\n"
"  lcase     смяна на главните букви с малки\n"
"  ucase     смяна на малките букви с главни\n"
"  sparse    опит за препозициониране вместо извеждане на нулеви байтове\n"
"  swab      размяна на всяка двойка входни байтове\n"
"  sync      запълване на всеки входен блок с нулеви байтове до размера\n"
"            на входния блок.  В комбинация с „block“ или „unblock“ се\n"
"            запълва с интервали\n"

#: src/dd.c:609
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl      да не действа, ако изходният файл вече съществува\n"
"  nocreat   без създаване на изходния файл\n"
"  notrunc   без отсичане на изходния файл\n"
"  noerror   продължаване дори при възникване на грешка\n"
"  fdatasync физически запис на изходните данни още преди пълното "
"приключване\n"
"  fsync     подобно, но освен това записва и метаданните\n"

#: src/dd.c:617
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"ФЛАГовете могат да са:\n"
"\n"
"  append    режим на добавяне (флаг само за изхода, препоръчва се заедно с\n"
"            „conv=notrunc“)\n"

#: src/dd.c:624
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio      паралелни вх./изх. операции за данните\n"

#: src/dd.c:626
msgid "  direct    use direct I/O for data\n"
msgstr "  direct    директни вх./изх. операции за данните\n"

#: src/dd.c:628
msgid "  directory  fail unless a directory\n"
msgstr "  directory  изискване на работа с директории\n"

#: src/dd.c:630
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     синхронизирани вх./изх. операции за данните\n"

#: src/dd.c:632
msgid "  sync      likewise, but also for metadata\n"
msgstr ""
"  sync      синхронизирани вх./изх. операции и за данните, и за метаданните\n"

#: src/dd.c:633
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr ""
"  fullblock  натрупване на цели блокове на входа (флаг само за входа)\n"

#: src/dd.c:636
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock  вх./изх. операции без блокиране\n"

#: src/dd.c:638
msgid "  noatime   do not update access time\n"
msgstr "  noatime   без промяна на времето за достъп\n"

#: src/dd.c:641
msgid "  nocache   Request to drop cache.  See also oflag=sync\n"
msgstr "  nocache   опит за пропускане на кеша.  Вж. и „oflag=sync“\n"

#: src/dd.c:645
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty    без задаване на управляващ терминал от файл\n"

#: src/dd.c:648
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  без следване на символните връзки\n"

#: src/dd.c:650
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks   отказ за работа при множество твърди връзки\n"

#: src/dd.c:652
msgid "  binary    use binary I/O for data\n"
msgstr "  binary    двоични вх./изх. операции за данните\n"

#: src/dd.c:654
msgid "  text      use text I/O for data\n"
msgstr "  text      текстови вх./изх. операции за данните\n"

#: src/dd.c:656
msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
msgstr ""
"  count_bytes  „count=N“ се третира като брой на байтовете (флаг само за "
"входа)\n"

#: src/dd.c:659
msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
msgstr ""
"  skip_bytes  „skip=N“ се третира като брой на байтовете (флаг само за "
"входа)\n"

#: src/dd.c:662
msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
msgstr ""
"  seek_bytes  „seek=N“ се третира като брой на байтовете (флаг само за "
"входа)\n"

#: src/dd.c:666
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"Изпращането на сигнал „%s“ към процес на „dd“ води до\n"
"извеждане на вх./изх. статистика на стандартната грешка,\n"
"след което копирането продължава.\n"
"\n"
"Възможните опции са::\n"
"\n"

#: src/dd.c:702
#, c-format
msgid "memory exhausted by input buffer of size %<PRIuMAX> bytes (%s)"
msgstr "паметта е изчерпана от входен буфер с размер %<PRIuMAX> байта (%s)"

#: src/dd.c:730
#, c-format
msgid "memory exhausted by output buffer of size %<PRIuMAX> bytes (%s)"
msgstr "паметта е изчерпана от изходен буфер с размер %<PRIuMAX> байта (%s)<"

#: src/dd.c:798 src/du.c:401
msgid "Infinity"
msgstr "Безброй"

#: src/dd.c:817
#, c-format
msgid "%<PRIuMAX> byte copied, %s, %s"
msgid_plural "%<PRIuMAX> bytes copied, %s, %s"
msgstr[0] "изкопиран е %<PRIuMAX> байт, %s, %s"
msgstr[1] "изкопирани са %<PRIuMAX> байта %s, %s"

#: src/dd.c:823
#, c-format
msgid "%<PRIuMAX> bytes (%s) copied, %s, %s"
msgstr "изкопирани са %<PRIuMAX> байта (%s), %s, %s"

#: src/dd.c:826
#, c-format
msgid "%<PRIuMAX> bytes (%s, %s) copied, %s, %s"
msgstr "изкопирани са %<PRIuMAX> байта (%s, %s), %s, %s"

#: src/dd.c:858
#, c-format
msgid ""
"%<PRIuMAX>+%<PRIuMAX> records in\n"
"%<PRIuMAX>+%<PRIuMAX> records out\n"
msgstr ""
"%<PRIuMAX>+%<PRIuMAX> прочетени блока\n"
"%<PRIuMAX>+%<PRIuMAX> записани блока\n"

#: src/dd.c:864
#, c-format
msgid "%<PRIuMAX> truncated record\n"
msgid_plural "%<PRIuMAX> truncated records\n"
msgstr[0] "%<PRIuMAX> отсечен запис\n"
msgstr[1] "%<PRIuMAX> отсечени записи\n"

#: src/dd.c:966
#, c-format
msgid "closing input file %s"
msgstr "затваряне на входния файл „%s“"

#: src/dd.c:973
#, c-format
msgid "closing output file %s"
msgstr "затваряне на изходния файл „%s“"

#: src/dd.c:1207
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "неуспешно изключване на „O_DIRECT“: %s"

#: src/dd.c:1282 src/dd.c:2202
#, c-format
msgid "writing to %s"
msgstr "запис в „%s“"

#: src/dd.c:1452
#, c-format
msgid "warning: %s is a zero multiplier; use %s if that is intended"
msgstr "ПРЕДУПРЕЖДЕНИЕ: „%s“ е нулев суфикс-множител.  Изрично ползвайте „%s“"

#: src/dd.c:1490 src/dd.c:1551
#, c-format
msgid "unrecognized operand %s"
msgstr "непознат операнд: %s"

#: src/dd.c:1502
msgid "invalid conversion"
msgstr "неправилно преобразуване"

#: src/dd.c:1505 src/dd.c:1594
msgid "invalid input flag"
msgstr "неправилен флаг за входа"

#: src/dd.c:1508 src/dd.c:1588 src/dd.c:1600
msgid "invalid output flag"
msgstr "неправилен флаг за изхода"

#: src/dd.c:1511
msgid "invalid status level"
msgstr "неправилно ниво за състояние"

#: src/dd.c:1646
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "опциите „ascii“, „ebcdic“, „ibm“ са несъвместими една с друга"

#: src/dd.c:1648
msgid "cannot combine block and unblock"
msgstr "опциите „block“ и „unblock“ са несъвместими една с друга"

#: src/dd.c:1650
msgid "cannot combine lcase and ucase"
msgstr "опциите „lcase“ и „ucase“ са несъвместими една с друга"

#: src/dd.c:1652
msgid "cannot combine excl and nocreat"
msgstr "опциите „excl“ и „nocreat“ са несъвместими една с друга"

#: src/dd.c:1655
msgid "cannot combine direct and nocache"
msgstr "опциите „direct“ и „nocache“ са несъвместими една с друга"

#: src/dd.c:1812
#, c-format
msgid ""
"warning: working around lseek kernel bug for file (%s)\n"
"  of mt_type=0x%0lx -- see <sys/mtio.h> for the list of types"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: заобикаляне на проблема в ядрото с позициониране за файла "
"„%s“,\n"
"който е от вид „mt_type=0x%0lx“.  За списък с възможните видове прегледайте\n"
"„<sys/mtio.h>“"

#: src/dd.c:1900
#, c-format
msgid "%s: cannot skip"
msgstr "%s: неуспешно прескачане"

#: src/dd.c:1902 src/dd.c:1933 src/dd.c:1994
#, c-format
msgid "%s: cannot seek"
msgstr "%s: неуспешно позициониране"

#: src/dd.c:1974
#, c-format
msgid "offset overflow while reading file %s"
msgstr "препълване на отместването при четене на файла %s"

#: src/dd.c:1986
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "ПРЕДУПРЕЖДЕНИЕ: неправилно отместване във файла след неуспешно четене"

#: src/dd.c:1990
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "грешката в ядрото, в крайна сметка, не може да се компенсира"

#: src/dd.c:2129
#, c-format
msgid "setting flags for %s"
msgstr "задаване на флагове за „%s“"

#: src/dd.c:2183
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s: неуспешно пропускане до зададеното отместване"

#: src/dd.c:2412
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr "неуспешно отсичане до %<PRIdMAX> байта в изходния файл „%s“"

#: src/dd.c:2425
#, c-format
msgid "fdatasync failed for %s"
msgstr "неуспешно изпълнение на „fdatasync“ върху %s"

#: src/dd.c:2433
#, c-format
msgid "fsync failed for %s"
msgstr "неуспешно изпълнение на „fsync“ върху „%s“"

#: src/dd.c:2481 src/dd.c:2511 src/nohup.c:157 src/nohup.c:159
#, c-format
msgid "failed to open %s"
msgstr "„%s“ не може да се отвори"

#: src/dd.c:2521
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIuMAX> (%lu-byte) "
"blocks"
msgstr ""
"твърде голямо отместване: не може да се отсече до дължината на seek="
"%<PRIuMAX> (%lu-byte) блокове"

#: src/dd.c:2542
#, c-format
msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
msgstr "неуспешно отсичане до %<PRIuMAX> байта в изходния файл %s"

#: src/dd.c:2559 src/dd.c:2565
#, c-format
msgid "failed to discard cache for: %s"
msgstr "неуспешно отхвърляне на кеша „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:50 src/du.c:56 src/expr.c:153 src/kill.c:34 src/pathchk.c:31
#: src/shuf.c:41 src/sleep.c:35 src/sort.c:68
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:182
msgid "Filesystem"
msgstr "Файлова с-ма"

#: src/df.c:185
msgid "Type"
msgstr "Вид"

#: src/df.c:188 src/df.c:602
msgid "blocks"
msgstr "блокове"

#: src/df.c:191
msgid "Used"
msgstr "Заети"

#: src/df.c:194
msgid "Available"
msgstr "Свободни"

#: src/df.c:197
msgid "Use%"
msgstr "Изп%"

#: src/df.c:200
msgid "Inodes"
msgstr "I-възли"

#: src/df.c:203
msgid "IUsed"
msgstr "I-заети"

#: src/df.c:206
msgid "IFree"
msgstr "I-свбдн"

#: src/df.c:209
msgid "IUse%"
msgstr "Изп%"

#: src/df.c:212
msgid "Mounted on"
msgstr "Монтирана на"

#: src/df.c:215
msgid "File"
msgstr "Файл"

#: src/df.c:442
#, c-format
msgid "option --output: field %s unknown"
msgstr "опция „--output“: непознато поле „%s“"

#: src/df.c:449
#, c-format
msgid "option --output: field %s used more than once"
msgstr "опция „--output“: повтарящо се поле „%s“"

#: src/df.c:470 src/df.c:509
msgid "Size"
msgstr "Размер"

#: src/df.c:474 src/df.c:511
msgid "Avail"
msgstr "Свобод"

#: src/df.c:534
msgid "Capacity"
msgstr "Обем"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:605 src/df.c:614
#, c-format
msgid "%s-%s"
msgstr "%s-%s"

#: src/df.c:1343
#, c-format
msgid "cannot access %s: over-mounted by another device"
msgstr "няма достъп до „%s“: върху директорията е монтирано друго устройство"

#: src/df.c:1512
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr ""
"Извеждане на информация за файловата система, съдържаща всеки от ФАЙЛовете\n"
"или за всички файлови системи (стандартно).\n"
"\n"

#. TRANSLATORS: The thousands and decimal separators are best
#. adjusted to an appropriate default for your locale.
#: src/df.c:1521
msgid ""
"  -a, --all             include pseudo, duplicate, inaccessible file "
"systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n"
"  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n"
msgstr ""
"  -a, --all             извеждане и на псевдо-, повтарящи се и недостъпни\n"
"                        файлови системи\n"
"  -B, --block-size=РАЗМЕР\n"
"                        извеждане на единици с такъв РАЗМЕР, напр. с „-BM“\n"
"                        единиците са по 1024×1024 байта.  Вж. раздела за\n"
"                        РАЗМЕР по-долу\n"
"  -h, --human-readable  основи кратни на 1024 (напр.: 1023M)\n"
"  -H, --si              основи кратни на 1000 (напр.: 1.1G)\n"

#: src/df.c:1529
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes          информация за използваните i-възли, а не блокове\n"
"  -k                    като „--block-size=1K“\n"
"  -l, --local           информация само за локалните файлови системи\n"
"      --no-sync         без „sync“ преди получаване на информацията "
"(стандартно)\n"

#: src/df.c:1536
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
msgstr ""
"      --output[=СПИСЪК_С_ПОЛЕТА]\n"
"                        извеждане на информацията от този СПИСЪК_С_ПОЛЕТА\n"
"                        или цялата информация, ако такъв не е даден\n"
"  -P, --portability     извеждане във формат POSIX\n"
"      --sync            изпълнение на командата „sync“ преди получаване\n"
"                        на информацията\n"

#: src/df.c:1542
msgid ""
"      --total           elide all entries insignificant to available space,\n"
"                          and produce a grand total\n"
msgstr ""
"      --total           само информация за наличното пространство и "
"добавяне\n"
"                        на общ сбор\n"

#: src/df.c:1546
msgid ""
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -t, --type=ВИД        извеждане на информация само за този ВИД файлови "
"системи\n"
"  -T, --print-type      извеждане на вида на файловата система\n"
"  -x, --exclude-type=ВИД\n"
"                        без извеждане на информация за този ВИД файлови "
"системи\n"
"  -v                    (пренебрегва се)\n"

#: src/df.c:1556
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n"
msgstr ""
"\n"
"СПИСЪКът_С_ПОЛЕТА задава колоните с информация за извеждане.  Разделяйте\n"
"полетата със запетаи.  Приемат се следните полета: „source“ (източник на\n"
"монтираната файлова система, обикновено е устройство), „fstype“ (вид "
"файлова\n"
"система), „itotal“ (общ брой на i-възлите), „iused“ (брой използвани i-"
"възли),\n"
"„iavail“ (брой налични i-възли), „ipcent“ (≡100*iused/itotal), „size“ (общ "
"брой\n"
"на блоковете), „used“ (брой използвани блокове), „avail“ (брой налични "
"блокове),\n"
"„pcent“ (≡100*used/size), „file“ (файлове) and „target“ (точката на "
"монтиране).\n"

#: src/df.c:1593
#, c-format
msgid "options %s and %s are mutually exclusive"
msgstr "опциите „%s“ и „%s“ са несъвместими"

#: src/df.c:1743
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "файловите системи от вида „%s“ са хем избрани, хем изключени"

#: src/df.c:1802
msgid "Warning: "
msgstr "Предупреждение: "

#: src/df.c:1804 src/stat.c:944
msgid "cannot read table of mounted file systems"
msgstr "таблицата с монтираните файлови системи не може да бъде прочетена"

#: src/df.c:1841
msgid "no file systems processed"
msgstr "нито една файлова система не бе обработена"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:37
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:100
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
msgstr ""
"Извеждане на команди за присвояване стойност на променливата LS_COLORS.\n"
"\n"
"Опции за форма̀та на изхода:\n"
"  -b, --sh, --bourne-shell    код за обвивка на Бурн\n"
"  -c, --csh, --c-shell        код за обвивка C\n"
"  -p, --print-database        стойности по подразбиране\n"

#: src/dircolors.c:110
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""
"\n"
"Ако е указан ФАЙЛ, той определя цветовете за различните файлови разширения.\n"
"В противен случай се използва вградена база от данни.\n"
"За подробности относно форма̀та на ФАЙЛа, изпълнете „dircolors --print-"
"database“.\n"

#: src/dircolors.c:288
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: неправилен ред — липсва втора лексема"

#: src/dircolors.c:360
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu: непозната ключова дума %s"

#: src/dircolors.c:361
msgid "<internal>"
msgstr "<интервал>"

#: src/dircolors.c:442
#, c-format
msgid ""
"the options to output dircolors' internal database and\n"
"to select a shell syntax are mutually exclusive"
msgstr ""
"опциите за извеждане на вътрешната база от данни на\n"
"„dircolors“ и за избор на обвивка са несъвместими"

#: src/dircolors.c:452
msgid "file operands cannot be combined with --print-database (-p)"
msgstr "файлови операнди са несъвместими с „--print-database“ („-p“)."

#: src/dircolors.c:475
msgid "no SHELL environment variable, and no shell type option given"
msgstr "променливата „SHELL“ е без стойност, а и липсва опция за обвивката"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "Употреба: %s [ОПЦИЯ] ИМЕ…\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""
"Извеждане на всяко ИМЕ без последната му част, която не е „/“,\n"
"както и без последните знаци „/“.  Ако ИМЕто не съдържа /, се\n"
"извежда „.“, което означава текущата директория.\n"
"\n"

#: src/dirname.c:59
msgid "  -z, --zero     end each output line with NUL, not newline\n"
msgstr ""
"  -z, --zero     завършване на редовете с нулев байт, а не със знак за нов "
"ред\n"

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""
"\n"
"Примери:\n"
"  %s /usr/bin/          → „/usr“\n"
"  %s dir1/str dir2/str  → „dir1“, следвано от „dir2“\n"
"  %s stdio.h            → „.“\n"

#: src/du.c:285 src/sort.c:415 src/wc.c:118
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]…\n"
"     или: %s [ОПЦИЯ]… --files0-from==ФАЙЛ\n"

#: src/du.c:289
msgid ""
"Summarize disk usage of the set of FILEs, recursively for directories.\n"
msgstr ""
"Резюме на използваното дисково пространство за всеки от ФАЙЛовете и "
"рекурсивно\n"
"за директориите.\n"
"\n"

#: src/du.c:295
msgid ""
"  -0, --null            end each output line with NUL, not newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes, rather than disk usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -0, --null            завършване на редовете с нулев байт вместо с нов "
"ред\n"
"  -a, --all             суми за всички файлове, не само за директориите\n"
"      --apparent-size   действителни размери, а не използваното дисково\n"
"                        пространство.  Обикновено действителният размер е\n"
"                        по-малък, но може да бъде и по-голям в следствие на\n"
"                        дупки в рехави (sparse) файлове, вътрешна "
"фрагментация,\n"
"                        индиректни блокове и други подобни.\n"

#: src/du.c:304
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -B, --block-size=РАЗМEР\n"
"                        да се ползват блокове с този РАЗМЕР байтове, напр.:\n"
"                        с „-BM“ се извеждат размери по 1024×1024 байта.\n"
"                        Вж. раздела за РАЗМЕР по-долу\n"
"  -b, --bytes           същото като „--apparent-size --block-size=1“\n"
"  -c, --total           пресмятане и на общ сбор на използваното "
"пространство\n"
"  -D, --dereference-args\n"
"                        работа със файловете, сочени от символните връзки "
"на\n"
"                        командния ред\n"
"  -d, --max-depth=НИВА  извеждане на общ сбор за директори (или файл при\n"
"                        ползването на „--all“) само ако те са максимум\n"
"                        толкова НИВА под аргументите на командния ред.\n"
"                        Логично: „--max-depth=0“≡„--summarize“\n"

#: src/du.c:317
msgid ""
"      --files0-from=F   summarize disk usage of the\n"
"                          NUL-terminated file names specified in file F;\n"
"                          if F is -, then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --inodes          list inode usage information instead of block usage\n"
msgstr ""
"      --files0-from=ФАЙЛ\n"
"                        резюмиране на използваното дисково пространство от\n"
"                        файловете с имена, разделени с нулев байт, указани "
"във\n"
"                        ФАЙЛа\n"
"  -H                    същото като „--dereference-args“/„-D“\n"
"  -h, --human-readable  по-четими размери (напр. 1K, 234M, 2G)\n"
"      --inodes          информация за използваните i-възли, а не за "
"блоковете\n"

#: src/du.c:326
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k                    също като „--block-size=1K“\n"
"  -L, --dereference     следване на символните връзки\n"
"  -l, --count-links     многократно сумиране на размера при всяка твърда "
"връзка\n"
"  -m                    също като „--block-size=1M“\n"

#: src/du.c:332
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   for directories do not include size of "
"subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -P, --no-dereference  без следване на символните връзки (стандартно)\n"
"  -S, --separate-dirs   да не се включва размерът на поддиректориите\n"
"      --si              като „-h“, но се ползват степени на 1000, а не на "
"1024\n"
"  -s, --summarize       извеждане само на общия сбор за всеки аргумент\n"

#: src/du.c:338
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using STYLE, which can be:\n"
"                            full-iso, long-iso, iso, or +FORMAT;\n"
"                            FORMAT is interpreted like in 'date'\n"
msgstr ""
"  -t, --threshold=РАЗМЕР\n"
"                        без по-малките от този РАЗМЕР, ако той е "
"положителен,\n"
"                        или без по-малките РАЗМЕРа, ако той е отрицателен\n"
"0     --time            извеждане на времето на последна промяна на всеки "
"файл\n"
"                        от директорията или всяка от поддиректориите ѝ\n"
"     --time=ВИД         извеждане на този ВИД време:\n"
"                           ⁃ „access“/„atime“/: последен достъп\n"
"                           ⁃ „ctime“/„status“/„use“: промяна\n"
"      --time-style=ФОРМАТ_НА_ВРЕМЕТО\n"
"                        ползване на този ФОРМАТ_НА_ВРЕМЕТО за времето.  Може "
"да\n"
"                        е: „full-iso“, „long-iso“, „iso“ или +ФОРМАТ.\n"
"                        Последният вариант се интерпретира както от „date“.\n"

#: src/du.c:349
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""
"  -X, --exclude-from=ФАЙЛ  без файлове, съвпадащи с някой от шаблоните във "
"ФАЙЛа\n"
"      --exclude=ШАБЛОН     без файлове, съвпадащи с ШАБЛОНа\n"
"  -x, --one-file-system    без директории от други файлови системи\n"

#: src/du.c:696
#, c-format
msgid "fts_read failed: %s"
msgstr "неуспешно прочитане с „fts_read“: %s"

#: src/du.c:820
#, c-format
msgid "invalid maximum depth %s"
msgstr "неправилна максимална дълбочина %s"

#: src/du.c:849
msgid "invalid --threshold argument '-0'"
msgstr "неправилен аргумент „-0“ за опцията „--threshold“"

#: src/du.c:932
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "не може едновременно да се резюмира и да се показват всички елементи"

#: src/du.c:939
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "ПРЕДУПРЕЖДЕНИЕ: резюмирането е еквивалентно на „--max-depth=0“"

#: src/du.c:945
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "ПРЕДУПРЕЖДЕНИЕ: резюмирането е несъвместимо с „--max-depth=%lu“"

#: src/du.c:956
#, c-format
msgid "warning: options --apparent-size and -b are ineffective with --inodes"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опциите „--apparent-size“ и „-b“ се пренебрегват при "
"ползването на опцията „--inodes“"

#: src/du.c:1021 src/sort.c:4598 src/wc.c:760
msgid "file operands cannot be combined with --files0-from"
msgstr "файловите операнди са несъвместими с „--files0-from“"

#: src/du.c:1088 src/sort.c:4619 src/wc.c:838
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr ""
"при четене на файлови имена от стандартния вход, никое файлово име не може "
"да бъде „%s“"

#: src/du.c:1105 src/du.c:1113 src/wc.c:851 src/wc.c:859
msgid "invalid zero-length file name"
msgstr "неправилно файлово име с дължина 0"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:28
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:42
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"Употреба: %s [КЪСА_ОПЦИЯ]… [НИЗ]…\n"
"     или: %s ДЪЛГА_ОПЦИЯ\n"

#: src/echo.c:46
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"Извеждане на НИЗовете на стандартния изход.\n"
"\n"
"  -n             без извеждане на знаци за нов ред след всеки от НИЗовете\n"

#: src/echo.c:52
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e             обработка на знаци, екранирани с „\\“ (стандартно)\n"
"  -E             без обработка на знаци, екранирани с „\\“\n"

#: src/echo.c:55
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e             обработка на знаци, екранирани с „\\“\n"
"  -E             без обработка на знаци, екранирани с „\\“ (стандартно)\n"

#: src/echo.c:61
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"Ако опцията „-e“ е включена, се разпознават следните последователности:\n"
"\n"

#: src/echo.c:66 src/printf.c:110
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\      обратно наклонена черта\n"
"  \\a      звънец\n"
"  \\b      обратно изтриване\n"
"  \\c      без повече изход\n"
"  \\e      екраниране\n"
"  \\f      нова страница\n"
"  \\n      нов ред\n"
"  \\r      връщане на каретката\n"
"  \\t      хоризонтална табулация\n"
"  \\v      вертикална табулация\n"

#: src/echo.c:78
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   байт с осмичен код NNN (1/2/3 цифри)\n"
"  \\xHH    байт с шестнадесетичен код HH (1/2 цифри)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:38 src/printenv.c:45 src/whoami.c:35
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:112
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-] [ПРОМЕНЛИВА=СТОЙНОСТ]… [КОМАНДА [АРГУМЕНТ]…]\n"

#: src/env.c:115
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr ""
"Задаване на съответната СТОЙНОСТ на всяка ПРОМЕНЛИВА в среда, в която да се "
"изпълни КОМАНДАта.\n"

#: src/env.c:121
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with NUL, not newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"  -i, --ignore-environment\n"
"                       начало с празно обкръжение\n"
"  -0, --null           завършване на всеки ред с нулев байт, а не нов ред\n"
"  -u, --unset=ПРОМЕНЛИВА\n"
"                       отстраняване на променлива от обкръжението\n"

#: src/env.c:126
msgid "  -C, --chdir=DIR      change working directory to DIR\n"
msgstr ""
"  -C, --chdir=ДИРЕКТОРИЯ\n"
"                       ползване на тази ДИРЕКТОРИЯ като работна\n"

#: src/env.c:129
msgid ""
"  -S, --split-string=S  process and split S into separate arguments;\n"
"                        used to pass multiple arguments on shebang lines\n"
msgstr ""
"  -S, --split-string=НИЗ\n"
"                        разделяне на НИЗа на отделни аргументи, ползва се "
"за\n"
"                        подаването на много аргументи на редове, почващи с "
"„#!“\n"

#: src/env.c:133
msgid ""
"      --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\n"
msgstr ""
"      --block-signal[=СИГНАЛ] предотвратяване на доставянето на такъв "
"СИГНАЛ\n"
"                              до командата\n"

#: src/env.c:136
msgid ""
"      --default-signal[=SIG]  reset handling of SIG signal(s) to the "
"default\n"
msgstr ""
"      --default-signal[=СИГНАЛ]\n"
"                              стандартно доставяне на такъв СИГНАЛ\n"

#: src/env.c:139
msgid ""
"      --ignore-signal[=SIG]   set handling of SIG signals(s) to do nothing\n"
msgstr ""
"      --ignore-signal[=СИГНАЛ]\n"
"                              пренебрегване на СИГНАЛа при получаването му\n"

#: src/env.c:142
msgid ""
"      --list-signal-handling  list non default signal handling to stderr\n"
msgstr ""
"      --list-signal-handling  извеждане на зададеното поведение, което не е\n"
"                              по подразбиране, на стандартната грешка\n"

#: src/env.c:145
msgid ""
"  -v, --debug          print verbose information for each processing step\n"
msgstr ""
"  -v, --debug          подробна информация при всяка стъпка на обработката\n"

#: src/env.c:150
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"Самотно „-“ означава „-i“.  Ако не е дадена КОМАНДА, полученото обкръжение "
"се отпечатва.\n"

#: src/env.c:154
msgid ""
"\n"
"SIG may be a signal name like 'PIPE', or a signal number like '13'.\n"
"Without SIG, all known signals are included.  Multiple signals can be\n"
"comma-separated.\n"
msgstr ""
"\n"
"СИГНАЛът може да бъде име на сигнал (напр. „PIPE“) или номер (напр. „13“).\n"
"Ако не е указан никакъв, се извеждат известните на системата сигнали.\n"
"Може да изброите няколко сигнала, разделени с „,“.\n"

#: src/env.c:181
#, c-format
msgid "cannot unset %s"
msgstr "„%s“ не може да се премахне"

#: src/env.c:315
msgid "'\\c' must not appear in double-quoted -S string"
msgstr ""
"„\\c“ не може да се поява в низ за опцията „-S“, който е цитиран с двойни "
"кавички"

#: src/env.c:319
msgid "invalid backslash at end of string in -S"
msgstr "единична обратна наклонена черта в края на низа, подаден на „-S“"

#: src/env.c:322
#, c-format
msgid "invalid sequence '\\%c' in -S"
msgstr "неправилна последователност „\\%c“ в низа към опцията „-S“"

#: src/env.c:336
#, c-format
msgid "only ${VARNAME} expansion is supported, error at: %s"
msgstr "поддържа се замяна само на „${VARNAME}“.  Грешката е при: „%s“"

#: src/env.c:347
msgid "no terminating quote in -S string"
msgstr "завършващата кавичка в низа към опцията „-S“ липсва"

#: src/env.c:613 src/env.c:702 src/operand2sig.c:88
#, c-format
msgid "%s: invalid signal"
msgstr "%s: неправилен сигнал"

#: src/env.c:645
#, c-format
msgid "failed to get signal action for signal %d"
msgstr "действието при получаването на сигнал %d не може да се открие"

#: src/env.c:653
#, c-format
msgid "failed to set signal action for signal %d"
msgstr "действието при получаването на сигнал %d не може да се зададе"

#: src/env.c:725 src/env.c:765
msgid "failed to get signal process mask"
msgstr "маската за обработка на сигнали не може да се получи"

#: src/env.c:754
msgid "failed to set signal process mask"
msgstr "маската за обработка на сигнали не може да се зададе"

#: src/env.c:857
#, c-format
msgid "invalid option -- '%c'"
msgstr "неправилна опция „%c“"

#: src/env.c:858 src/env.c:949
#, c-format
msgid "use -[v]S to pass options in shebang lines"
msgstr "използвайте „-[v]S“, за да подавате опции към реда, почващ с „#!“"

#: src/env.c:891
#, c-format
msgid "cannot set %s"
msgstr "„%s“ не може да се зададе"

#: src/env.c:901
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "не може да зададете „--null“/„-0“ с командата"

#: src/env.c:907
#, c-format
msgid "must specify command with --chdir (-C)"
msgstr "трябва да укажете команда с „--chdir“/„-C“"

#: src/env.c:932
#, c-format
msgid "cannot change directory to %s"
msgstr "директорията не може да се смени към „%s“"

#: src/expand-common.c:90
msgid "tabs are too far apart"
msgstr "табулациите са твърде отдалечени"

#: src/expand-common.c:103
#, c-format
msgid "'/' specifier only allowed with the last value"
msgstr "„/“ е позволен само с последната стойност"

#: src/expand-common.c:120
#, c-format
msgid "'+' specifier only allowed with the last value"
msgstr "„+“ е позволен само с последната стойност"

#: src/expand-common.c:172
#, c-format
msgid "'/' specifier not at start of number: %s"
msgstr "„/“ не е в началото на число: %s"

#: src/expand-common.c:183
#, c-format
msgid "'+' specifier not at start of number: %s"
msgstr "„+“ не е в началото на число: %s"

#: src/expand-common.c:204
#, c-format
msgid "tab stop is too large %s"
msgstr "табулацията е твърде дълга: %s"

#: src/expand-common.c:212
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "размерът на табулациите включва непозволен знак: %s"

#: src/expand-common.c:244
msgid "tab size cannot be 0"
msgstr "размерът на табулациите не може да бъде 0"

#: src/expand-common.c:246
msgid "tab sizes must be ascending"
msgstr "позициите на табулациите трябва да са в нарастващ ред"

#: src/expand-common.c:251
msgid "'/' specifier is mutually exclusive with '+'"
msgstr "префиксът „/“ е несъвместим с „+“"

#: src/expand-common.c:390
msgid "  -t, --tabs=LIST  use comma separated list of tab positions\n"
msgstr ""
"  -t, --tabs=СПИСЪК   СПИСЪКът указва позициите на табулациите, разделени с "
"„,“\n"

#: src/expand-common.c:393
msgid ""
"                     The last specified position can be prefixed with '/'\n"
"                     to specify a tab size to use after the last\n"
"                     explicitly specified tab stop.  Also a prefix of '+'\n"
"                     can be used to align remaining tab stops relative to\n"
"                     the last specified tab stop instead of the first "
"column\n"
msgstr ""
"                     Последната указана позиция може да започва с „/“, за "
"да\n"
"                     укаже размера на всички след нея на реда.  Друг вариант "
"е\n"
"                     позиция да започва „+“, което води до подравняване на\n"
"                     табулациите спрямо предишната указана такава вместо\n"
"                     спрямо първата колона\n"

#: src/expand.c:73
msgid "Convert tabs in each FILE to spaces, writing to standard output.\n"
msgstr ""
"Замяна на табулациите във всеки ФАЙЛ с интервали и извеждане на стандартния "
"изход\n"

#: src/expand.c:80
msgid ""
"  -i, --initial    do not convert tabs after non blanks\n"
"  -t, --tabs=N     have tabs N characters apart, not 8\n"
msgstr ""
"  -i, --initial       без замяна на табулациите след знак, който не е "
"интервал\n"
"  -t, --tabs=БРОЙ     табулациите да са равни на този БРОЙ интервали вместо "
"8\n"

#: src/expand.c:146 src/expand.c:165 src/unexpand.c:181 src/unexpand.c:226
msgid "input line is too long"
msgstr "входният ред е твърде дълъг"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:151 src/ln.c:51 src/mv.c:42 src/tee.c:36
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:152 src/groups.c:37
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:345
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ИЗРАЗ\n"
"     или: %s ОПЦИЯ\n"

#: src/expr.c:353
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"Отпечатване на стойността на ИЗРАЗа на стандартния изход. По-долу празни "
"редове\n"
"отделят групите операции с нарастващ приоритет. ИЗРАЗът може да бъде:\n"
"\n"
"  ⁃ АРГ_1 |  АРГ_2    АРГумент_1, ако не е нулев или 0, а иначе АРГумент_2\n"
"\n"
"  ⁃ АРГ_1 &  АРГ_2    АРГумент_1, ако аргументите не са нулеви или 0, а "
"иначе 0\n"

#: src/expr.c:362
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  ⁃ АРГ_1 <  АРГ_2    АРГ_1 е по-малък от АРГ_2\n"
"  ⁃ АРГ_1 <= АРГ_2    АРГ_1 е по-малък или равен на АРГ_2\n"
"  ⁃ АРГ_1 =  АРГ_2    АРГ_1 е равен на АРГ_2\n"
"  ⁃ АРГ_1 != АРГ_2    АРГ_1 е различен от АРГ_2\n"
"  ⁃ АРГ_1 >= АРГ_2    АРГ_1 е по-голям или равен на АРГ_2\n"
"  ⁃ АРГ_1 >  АРГ_2    АРГ_1 е по-голям от АРГ_2\n"

#: src/expr.c:371
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  ⁃ АРГ_1 +  АРГ_2    аритметична сума на АРГ_1 и АРГ_2\n"
"  ⁃ АРГ_1 -  АРГ_2    аритметична разлика на АРГ_1 и АРГ_2\n"

#: src/expr.c:378
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  ⁃ АРГ_1 *  АРГ_2    аритметично произведение на АРГ_1 и АРГ_2\n"
"  ⁃ АРГ_1 /  АРГ_2    аритметично частно на АРГ_1 разделен на АРГ_2\n"
"  ⁃ АРГ_1 %  АРГ_2    аритметичен остатък на АРГ_1 разделен на АРГ_2\n"

#: src/expr.c:384
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  ⁃ НИЗ : РЕГУЛЯРЕН_ИЗРАЗ      стриктно (anchored) съпоставяне на\n"
"                               РЕГУЛЯРНия_ИЗРАЗ в НИЗа\n"
"\n"
"  ⁃ match НИЗ РЕГУЛЯРЕН_ИЗРАЗ  същото като НИЗ : РЕГУЛЯРЕН_ИЗРАЗ\n"
"  ⁃ substr НИЗ ПОЗИЦИЯ ДЪЛЖИНА подниз на НИЗа, ПОЗИЦИЯта се брои от 1\n"
"  ⁃ index НИЗ ЗНАЦИ            място, където са някои от ЗНАЦИте в НИЗа, или "
"0\n"
"  ⁃ length НИЗ                 дължината на НИЗа\n"

#: src/expr.c:393
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  ⁃ + ЛЕКСЕМА                  обработка на ЛЕКСЕМАта като низ, дори и ако "
"е\n"
"                               ключова дума като „match“ или оператор като "
"„/“\n"
"\n"
"  ⁃ ( ИЗРАЗ )                  стойността на ИЗРАЗ\n"

#: src/expr.c:399
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"В командните обвивки често трябва да екранирате операторите с „'“, „\"“ или "
"„\\“.\n"
"Сравненията са аритметични, ако и двата АРГумента са числа, а иначе са\n"
"лексикографски.  Съпоставянията с образец връщат низа, напаснал между "
"първите\n"
"„\\(“ и „\\)“ или празен низ.  Ако не са използвани „\\(“ и „\\)“, се връща "
"броят\n"
"напаснали знаци или 0.\n"

#: src/expr.c:406
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"Кодът на завършване е:\n"
"  ⁃ 0, ако ИЗРАЗът не е празен или 0;\n"
"  ⁃ 1, ако ИЗРАЗът е празен или 0;\n"
"  ⁃ 2, ако ИЗРАЗът е синтактично неправилен;\n"
"  ⁃ 3, ако е станала грешка.\n"

#: src/expr.c:462
#, c-format
msgid "syntax error: unexpected argument %s"
msgstr "синтактична грешка: неочакван аргумент — „%s“"

#: src/expr.c:665
#, c-format
msgid "syntax error: missing argument after %s"
msgstr "синтактична грешка: след „%s“ липсва аргумент"

#: src/expr.c:748 src/ptx.c:289
msgid "error in regular expression matcher"
msgstr "грешка при пасването на регулярния израз"

#: src/expr.c:776
#, c-format
msgid "syntax error: expecting ')' after %s"
msgstr "синтактична грешка: след „%s“ трябва да има „)“"

#: src/expr.c:779
#, c-format
msgid "syntax error: expecting ')' instead of %s"
msgstr "синтактична грешка: очаква се „)“, а не „%s“"

#: src/expr.c:785
msgid "syntax error: unexpected ')'"
msgstr "синтактична грешка: неочаквана „)“"

#: src/expr.c:931 src/expr.c:968
msgid "non-integer argument"
msgstr "аргумент, който не е цяло число, а трябва да е"

#: src/expr.c:933 src/truncate.c:278
msgid "division by zero"
msgstr "делене на нула"

#: src/expr.c:1027 src/sort.c:2119
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "за да заобиколите този проблем, задайте „LC_ALL='C'“"

#: src/expr.c:1029
#, c-format
msgid "the strings compared were %s and %s"
msgstr "сравнените низове са „%s“ и „%s“."

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:130
msgid "Niels Moller"
msgstr "Niels Moller"

#: src/factor.c:1276 src/factor.c:1376 src/factor.c:1452
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr ""
"Неуспешна проверка за просто число по Лука̀.  Това не трябва да се случва"

#: src/factor.c:2103
msgid "squfof queue overflow"
msgstr "Препълване на опашката за разлагане по квадратната форма (squfof)"

#: src/factor.c:2525
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s не е правилно положително цяло число"

#: src/factor.c:2549 src/od.c:1697 src/od.c:1778
#, c-format
msgid "%s is too large"
msgstr "„%s“ е твърде дълго"

#: src/factor.c:2561
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s [ЧИСЛО]…\n"
"     или: %s ОПЦИЯ\n"

#: src/factor.c:2566
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"Извеждане на простите множители на всички посочени цели ЧИСЛА.  При липса\n"
"на аргументи на командния ред, числата се четат от стандартния вход.\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "текущата директория не може да се определи"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "не може да се влезе в директорията %s"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr ""
"не може да се получи информация със „stat“ за текущата директория,\n"
"която в момента е %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:37
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:269
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "Употреба: %s [-РАЗМЕР] [ОПЦИЯ]… ФАЙЛ…\n"

#: src/fmt.c:270
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""
"Преформатиране на всеки абзац във ФАЙЛовете и извеждане на стандартния "
"изход.\n"
"Опцията с число „-ШИРОЧИНА“ е еквивалентна на „--width=ШИРОЧИНА“\n"
"\n"

#: src/fmt.c:278
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        запазване на отстъпа на първите два реда\n"
"  -p, --prefix=НИЗ          преформатиране само на редовете, започващи с "
"НИЗа.\n"
"                            Той се маха, редовете се форматиран, след което\n"
"                            НИЗът пак се добавя.\n"
"  -s, --split-only          дългите редове се разделят, но късите не се "
"попълват\n"

#: src/fmt.c:287
#, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""
"  -t, --tagged-paragraph    отстъпът на първия ред да се отличава от втория\n"
"  -u, --uniform-spacing     един интервал между думите, два между изречения\n"
"  -w, --width=ШИРОЧИНА      максимална широчина на реда (стандартно 75 "
"знака)\n"
"  -g, --goal=ШИРОЧИНА_ЦЕЛ   широчина-цел на реда (стандартно 93% от "
"широчината)\n"

#: src/fmt.c:355
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr ""
"неправилна опция: „%c“.  „-ШИРОЧИНА“ се разпознава, само ако е първа опция.\n"
"Ако това е невъзможно, ползвайте „-w ШИРОЧИНА“"

#: src/fmt.c:399 src/fmt.c:406
msgid "invalid width"
msgstr "неправилна широчина"

#: src/fold.c:70
msgid "Wrap input lines in each FILE, writing to standard output.\n"
msgstr ""
"Пренасяне на входните редове от всеки ФАЙЛ наново при извеждането на "
"стандартния изход\n"

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         броене на байтовете, вместо стълбовете\n"
"  -s, --spaces        прекъсване на работа при интервали\n"
"  -w, --width=БРОЙ    да се ползва този БРОЙ стълбове, вместо 80\n"

#: src/fold.c:284 src/pr.c:841
msgid "invalid number of columns"
msgstr "неправилен брой знаци"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:30 src/md5sum.c:107 src/realpath.c:33 src/stdbuf.c:38
#: src/timeout.c:78 src/truncate.c:38
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "Употреба: %s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"Извеждане на ограниченията на платформата във формат подходящ за скриптове "
"на обвивката.\n"
"\n"

#: src/group-list.c:68 src/id.c:401
#, c-format
msgid "failed to get groups for user %s"
msgstr "групите на потребителя „%s“ не могат да се получат"

#: src/group-list.c:73 src/id.c:404
#, c-format
msgid "failed to get groups for the current process"
msgstr "групите на текущия процес не могат да се получат"

#: src/group-list.c:113
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "не може да се намери името на група с номер %lu"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ПОТРЕБИТЕЛ]…\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"Извеждане на групите, в които всеки ПОТРЕБИТЕЛ членува, а ако той е "
"пропуснат,\n"
"се извеждат групите на текущия процес.  Отговорът може да не е точен, "
"когато\n"
"базата от данни за групитe се е променила.\n"

#: src/groups.c:106 src/id.c:289
msgid "cannot get real UID"
msgstr "истинският идентификатор на потребител не може да бъде получен"

#: src/groups.c:111 src/id.c:297
msgid "cannot get effective GID"
msgstr ""
"действащият (effective) идентификатор на групата не може да бъде получен"

#: src/groups.c:116 src/id.c:302
msgid "cannot get real GID"
msgstr "истинският идентификатор на групата не може да бъде получен"

#: src/groups.c:130 src/id.c:255
#, c-format
msgid "%s: no such user"
msgstr "„%s“: няма такъв потребител"

#: src/head.c:114
#, c-format
msgid ""
"Print the first %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Извеждане на първите %d реда от всеки ФАЙЛ на стандартния изход.\n"
"При повече от един ФАЙЛ се поставят заглавия с имената на файловете.\n"

#: src/head.c:122
#, c-format
msgid ""
"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM bytes of each file\n"
"  -n, --lines=[-]NUM       print the first NUM lines instead of the first "
"%d;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM lines of each file\n"
msgstr ""
"  -c, --bytes=[-]N         извеждане на първите N байта от всеки файл,\n"
"                           с отрицателно число се извеждат всички, освен\n"
"                           последните N байта от всеки файл\n"
"  -n, --lines=[-]N         извеждане на първите N реда от всеки файл "
"(вместо\n"
"                           първите %d), с отрицателно число се извеждат "
"всички,\n"
"                           освен последните N реда от всеки файл\n"

#: src/head.c:130
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    без извеждане на заглавия с имената на файловете\n"
"  -v, --verbose            винаги да се извеждат заглавия с имената на "
"файловете\n"

#: src/head.c:139
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"БРОят може да бъде следван от следните суфикси-множители:\n"
"b≡512, kB≡1000, K≡1024, MB≡1000×1000, M≡1024×1024,\n"
"GB≡1000×1000×1000, G≡1024×1024×1024 и т.н. за „T“, „P“, „E“, „Z“ и „Y“.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"

#: src/head.c:160
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s: файлът се е свил твърде много"

#: src/head.c:232 src/tail.c:507
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: не може да се отиде към отместване %s във файла"

#: src/head.c:233 src/tail.c:511
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: не може да се отиде към относително отместване %s във файла"

#: src/head.c:275
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s: твърде голям брой байтове"

#: src/head.c:913 src/split.c:1368 src/split.c:1535 src/tail.c:2205
msgid "invalid number of lines"
msgstr "недопустим брой редове"

#: src/head.c:914 src/head.c:1078 src/split.c:1360 src/split.c:1376
#: src/tail.c:2206
msgid "invalid number of bytes"
msgstr "недопустимо количество байтове"

#: src/head.c:1004 src/head.c:1066
#, c-format
msgid "invalid trailing option -- %c"
msgstr "неправилна опция — „%c“"

#: src/hostid.c:41
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]\n"
"Извеждане на шестнадесетичен числов идентификатор на хоста.\n"
"\n"

#: src/hostname.c:56
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"Употреба: %s [ИМЕ]\n"
"     или: %s ОПЦИЯ\n"
"Извеждане или задаване на името на хоста на текущата система.\n"
"\n"

#: src/hostname.c:93
#, c-format
msgid "cannot set name to %s"
msgstr "името не може да се зададе да е „%s“"

#: src/hostname.c:97
msgid "cannot set hostname; this system lacks the functionality"
msgstr ""
"не може да се задава хост-име, тази система не притежава такава възможност"

#: src/hostname.c:105
msgid "cannot determine hostname"
msgstr "името на хоста не може да бъде определено"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:41 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:96 src/pinky.c:489
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ПОТРЕБИТЕЛ]…\n"

#: src/id.c:97
msgid ""
"Print user and group information for each specified USER,\n"
"or (when USER omitted) for the current user.\n"
"\n"
msgstr ""
"Извеждане на информация за потребителя и групата на всеки указан "
"ПОТРЕБИТЕЛ.\n"
"Когато такъв не е указан, се извежда информация за текущия.\n"

#: src/id.c:102
msgid ""
"  -a             ignore, for compatibility with other versions\n"
"  -Z, --context  print only the security context of the process\n"
"  -g, --group    print only the effective group ID\n"
"  -G, --groups   print all group IDs\n"
"  -n, --name     print a name instead of a number, for -ugG\n"
"  -r, --real     print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user     print only the effective user ID\n"
"  -z, --zero     delimit entries with NUL characters, not whitespace;\n"
"                   not permitted in default format\n"
msgstr ""
"  -a             пренебрегва се — за съвместимост с предишни версии\n"
"  -Z, --context  само контекста за сигурност на процеса\n"
"  -g, --group    само номера на действащата (effective) група\n"
"  -G, --groups   номерата на всички групи\n"
"  -n, --name     име вместо номер за „-ugG“\n"
"  -r, --real     реалните (real) вместо действащите номера за „-ugG“\n"
"  -u, --user     само номера на действащия (effective) потребител\n"
"  -z, --zero     разделяне на записите с нулев байт вместо с нов ред,\n"
"                 това не е позволено в стандартния формат\n"

#: src/id.c:115
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"Без никаква ОПЦИЯ просто отпечатва полезна идентификационна информация.\n"

#: src/id.c:153
msgid "--context (-Z) works only on an SELinux/SMACK-enabled kernel"
msgstr ""
"опцията „--context“/„-Z“ работи само с ядра с поддръжка на SELinux/SMACK"

#: src/id.c:158
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "опцията „--context“/„-Z“ работи само с ядра с поддръжка на SELinux"

#: src/id.c:192
msgid "cannot print security context when user specified"
msgstr "контекстът за сигурност не може да се изведе при указан потребител"

#: src/id.c:195
msgid "cannot print \"only\" of more than one choice"
msgstr "не може да се ползва едновременно повече от една от опциите „-gGuZ“"

#: src/id.c:204
msgid "cannot print only names or real IDs in default format"
msgstr ""
"не може да се извеждат само имена или номера във форма̀та по подразбиране"

#: src/id.c:208
msgid "option --zero not permitted in default format"
msgstr "опцията „--zero“ е несъвместима със стандартния формат"

#: src/id.c:224
msgid "can't get process context"
msgstr "контекстът на процеса не може да бъде получен"

#: src/id.c:280
msgid "cannot get effective UID"
msgstr ""
"действащият (effective) идентификатор на потребител не може да бъде получен"

#: src/id.c:344
#, c-format
msgid "cannot find name for user ID %s"
msgstr "никое име на потребител не съответства на идентификатор %s"

#: src/id.c:362
#, c-format
msgid "uid=%s"
msgstr "ид_п=%s"

#: src/id.c:367
#, c-format
msgid " gid=%s"
msgstr " ид_г=%s"

#: src/id.c:374
#, c-format
msgid " euid=%s"
msgstr " е_ид_п=%s"

#: src/id.c:382
#, c-format
msgid " egid=%s"
msgstr "  е_ид_г=%s"

#: src/id.c:410
msgid " groups="
msgstr " групи="

#: src/id.c:426
#, c-format
msgid " context=%s"
msgstr " контекст=%s"

#: src/install.c:378
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: контекстът за сигурност на „%s“ не може да се смени на „%s“"

#: src/install.c:420
#, c-format
msgid "creating directory %s"
msgstr "директорията „%s“ се създава"

#: src/install.c:432 src/mkdir.c:128 src/mkdir.c:161
#, c-format
msgid "failed to set default creation context for %s"
msgstr ""
"стандартният контекст при създаване на файлове не може да се зададе на „%s“"

#: src/install.c:462 src/mkdir.c:181
#, c-format
msgid "failed to restore context for %s"
msgstr "контекстът на „%s“ не може да се възстанови"

#: src/install.c:510
#, c-format
msgid "cannot change ownership of %s"
msgstr "собствеността на „%s“ не може да се смени "

#: src/install.c:534
#, c-format
msgid "cannot set timestamps for %s"
msgstr "времевото клеймо на „%s“ не може да се зададе"

#: src/install.c:556 src/split.c:523 src/timeout.c:506
#, c-format
msgid "fork system call failed"
msgstr "неуспешно изпълнение на „fork“"

#: src/install.c:560
#, c-format
msgid "cannot run %s"
msgstr "„%s“ не може да се изпълни"

#: src/install.c:563
#, c-format
msgid "waiting for strip"
msgstr "изчакване на изпълнението на „strip“"

#: src/install.c:565
#, c-format
msgid "strip process terminated abnormally"
msgstr "командата „strip“ спря неочаквано с грешка"

#: src/install.c:589
#, c-format
msgid "invalid user %s"
msgstr "неправилен потребител „%s“"

#: src/install.c:627
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-T] ИЗТОЧНИК ЦЕЛ\n"
"     или: %s [ОПЦИЯ]… ИЗТОЧНИК… ДИРЕКТОРИЯ\n"
"     или: %s [ОПЦИЯ]… -t ДИРЕКТОРИЯ ЦЕЛ…\n"
"     или: %s [ОПЦИЯ]… -d ДИРЕКТОРИЯ…\n"

#: src/install.c:634
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""
"\n"
"Командата „install“ копира файлове (често — прясно компилирани) в целеви\n"
"местоположения.  Ако искате да свалите и инсталирате готов пакет за GNU/"
"Linux,\n"
"по-добре е да ползвате пакетен мениджър като dnf(1) или apt-get(1).\n"
"\n"
"При първите три варианти ИЗТОЧНИКът се копира в ЦЕЛта или няколко ИЗТОЧНИКа\n"
"се копират в съществуваща ДИРЕКТОРИЯ, като се задават режим на достъп и\n"
"собственик/група.  При четвъртия формат се създават всички компоненти на\n"
"дадените ДИРЕКТОРИи.\n"

#: src/install.c:648
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare each pair of source and destination files, "
"and\n"
"                        in some cases, do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=МЕТОД]\n"
"                      със резервно копие на съществуващите целеви файлове\n"
"  -b                  като „--backup“, но без аргумент\n"
"  -c                  (пренебрегва се)\n"
"  -C, --compare       сравнение във всяка двойка файлове ИЗТОЧНИК-ЦЕЛ и в "
"някои\n"
"                      случаи целта не бива променяна\n"
"  -d, --directory     всичките аргументи са имена на директории и се "
"създават\n"
"                      всички компоненти на посочените директории\n"

#: src/install.c:657
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        or all components of --target-directory,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                  създаване на всички начални компоненти на ЦЕЛта освен\n"
"                      последния, последвано от копиране на ИЗТОЧНИКа в нея\n"
"  -g, --group=ГРУПА   задаване на посочената ГРУПА вместо текущата на "
"процеса\n"
"  -m, --mode=РЕЖИМ    задаване на посочения РЕЖИМ за достъп (както при "
"„chmod“)\n"
"                      вместо „rwxr-xr-x“\n"
"  -o, --owner=СОБСТВЕНИК\n"
"                      задаване на СОБСТВЕНИК (само от привилегирован "
"потребител)\n"

#: src/install.c:665
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps\n"
"                      прилагане на времената за достъп/промяна на "
"файловете-\n"
"                      ИЗТОЧНИци за съответните целеви файлове\n"
"  -s, --strip         премахване на таблиците със символи\n"
"      --strip-program=ПРОГРАМА\n"
"                      премахване на таблиците със символи с тази ПРОГРАМА\n"
"  -S, --suffix=СУФИКС ползване на този СУФИКС за резервни копия, а не "
"обичайния\n"
"  -t, --target-directory=ДИРЕКТОРИЯ\n"
"                      копиране на всички аргументи-ИЗТОЧНИци в ДИРЕКТОРИЯта\n"
"  -T, --no-target-directory\n"
"                      работа с ЦЕЛта като с обикновен файл\n"
"  -v, --verbose       извеждане на името на всяка директория при създаването "
"ѝ\n"

#: src/install.c:675
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z                      set SELinux security context of destination\n"
"                            file and each created directory to default type\n"
"      --context[=CTX]     like -Z, or if CTX is specified then set the\n"
"                            SELinux or SMACK security context to CTX\n"
msgstr ""
"      --preserve-context  запазване на контекста за сигурност на SELinux\n"
"  -Z                      задаване на стандартен за вида контекст на "
"сигурност\n"
"                          за SELinux или SMACK\n"
"      --context[=КОНТЕКСТ]\n"
"                          като „-Z“, но при задаването се прилага този "
"КОНТЕКСТ\n"
"                          за SELinux или SMACK\n"

#: src/install.c:711 src/unlink.c:85
#, c-format
msgid "cannot unlink %s"
msgstr "неуспешно изпълнение на „unlink“ върху „%s“"

#: src/install.c:892
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--preserve-context“ се прескача, защото ядрото е "
"без поддръжка на SELinux"

#: src/install.c:932
msgid "the strip option may not be used when installing a directory"
msgstr ""
"опцията за махане на таблиците със символи не може да се използва при "
"инсталиране на директория"

#: src/install.c:935
msgid "target directory not allowed when installing a directory"
msgstr ""
"инсталирането на директория е несъвместимо с посочването на целева директория"

#: src/install.c:1002 src/mkdir.c:284 src/stdbuf.c:352
#, c-format
msgid "invalid mode %s"
msgstr "неправилен режим „%s“"

#: src/install.c:1009
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--strip-program“ се прескача, защото опцията „-s“ "
"липсва"

#: src/install.c:1014
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr "опциите „--compare“/„-C“ и „--preserve-timestamps“ са несъвместими"

#: src/install.c:1021
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "опциите „--compare“/„-C“ и „--strip“ са несъвместими"

#: src/install.c:1027
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--compare“/„-C“ се прескача, защото сте задали "
"режим с битове, които не са за разрешения"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:41 src/sort.c:67
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:196
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited by blanks.\n"
msgstr ""
"Извеждане на ред на стандартния изход за всяка двойка входни редове със\n"
"съвпадащи стойности в полетата за свързване.  Стандартното поле за "
"свързване\n"
"е първото, а разделител са интервалите.\n"

#: src/join.c:205
msgid ""
"\n"
"  -a FILENUM        also print unpairable lines from file FILENUM, where\n"
"                      FILENUM is 1 or 2, corresponding to FILE1 or FILE2\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
msgstr ""
"\n"
"  -a НОМЕР          извеждане на несъответстващите редове от файла с този\n"
"                    НОМЕР, който е или 1, или 2\n"
"  -e ЗАМЕСТИТЕЛ     замяна на липсващите входни полета с този ЗАМЕСТИТЕЛ\n"

#: src/join.c:211
msgid ""
"  -i, --ignore-case  ignore differences in case when comparing fields\n"
"  -j FIELD          equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case без разлика за големи/малки букви при сравняване на "
"полетата\n"
"  -j ПОЛЕ           същото като „-1 ПОЛЕ -2 ПОЛЕ“\n"
"  -o ФОРМАТ         следване на този ФОРМАТ при съставяне на изходните "
"редове\n"
"  -t ЗНАК           ползване на ЗНАКа за разделител на входните и изходни "
"полета\n"

# JOIN дали да бъде свързване, напасване, откриване на съответствие - съответства
#: src/join.c:217
msgid ""
"  -v FILENUM        like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"  --check-order     check that the input is correctly sorted, even\n"
"                      if all input lines are pairable\n"
"  --nocheck-order   do not check that the input is correctly sorted\n"
"  --header          treat the first line in each file as field headers,\n"
"                      print them without trying to pair them\n"
msgstr ""
"  -v НОМЕР          като „-a НОМЕР“ без извеждане на свързаните редове на "
"изхода\n"
"  -1 ПОЛЕ           свързване по това ПОЛЕ от ФАЙЛ_1\n"
"  -2 ПОЛЕ           свързване по това ПОЛЕ от ФАЙЛ_2\n"
"  --check-order     проверка за правилна подредба на входните редове, дори "
"и\n"
"                    всички да са били успешно напаснати\n"
"  --nocheck-order   без проверка за правилна подредба на входните редове\n"
"  --header          първият ред от всеки файл да е заглавие и те да се "
"отпечатат\n"
"                    без опит за свързване\n"

#: src/join.c:227 src/shuf.c:83 src/sort.c:500 src/uniq.c:201
msgid "  -z, --zero-terminated     line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     завършване на редовете с нулев байт вместо с нов "
"ред\n"

#: src/join.c:232
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"Ако опцията „-t ЗНАК“ е пропусната, бялото поле пред полетата е разделител "
"и\n"
"се прескача.  Иначе ЗНАКът се счита, че разделя полетата.  Всяко ПОЛЕ е "
"номер,\n"
"който се брои от 1.  ФОРМАТите са една или повече спецификации, разделени "
"със\n"
"запетая или интервал,  всяка от които е „НОМЕР_на_файл.ПОЛЕ“ или „0“.\n"
"Стандартният ФОРМАТ извежда свързващото поле, останалите полета от ФАЙЛ_1 и\n"
"останалите полета от ФАЙЛ_2, като те се разделят с указания ЗНАК.\n"
"\n"
"ВНИМАНИЕ: ФАЙЛ_1 и ФАЙЛ_2 трябва да са подредени по свързващите полета!\n"
"Например: ако на „join“ не са подадени опции, ползвайте „sort -k 1b,1“.\n"
"ВНИМАНИЕ: подредбата трябва да е според правилата на „LC_COLLATE“ за "
"локала!\n"
"Ако входните данни не са подредени правилно и някои от редовете не могат да\n"
"бъдат свързани, се извежда съобщение за предупреждение.\n"

#: src/join.c:417
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr "%s:%<PRIuMAX>: не е подреден: %.*s"

#: src/join.c:848 src/join.c:1046
#, c-format
msgid "invalid field number: %s"
msgstr "неправилен номер на поле: %s"

#: src/join.c:869 src/join.c:878
#, c-format
msgid "invalid field specifier: %s"
msgstr "неправилно указано поле: %s"

#: src/join.c:885
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "неправилен номер на файл при указване на поле: %s"

#: src/join.c:929
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "неправилни свързващи полета %lu, %lu"

#: src/join.c:1057
msgid "conflicting empty-field replacement strings"
msgstr "несъвместими заменящи низове за празно поле"

#: src/join.c:1109 src/sort.c:4535
#, c-format
msgid "multi-character tab %s"
msgstr "табулация от множество знаци „%s“"

#: src/join.c:1113 src/sort.c:4540
msgid "incompatible tabs"
msgstr "несъвместими табулации"

#: src/join.c:1186
msgid "both files cannot be standard input"
msgstr "не може и за двата файла да се полза стандартният вход"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"Употреба: %s [-s СИГНАЛ | -СИГНАЛ] ИД_ПР…\n"
"     или: %s -l [СИГНАЛ]…\n"
"     или: %s -t [СИГНАЛ]…\n"

#: src/kill.c:83
msgid "Send signals to processes, or list signals.\n"
msgstr "Изпращане на сигнали към процеси или извеждане на самите сигнали.\n"

#: src/kill.c:89
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=СИГНАЛ, -СИГНАЛ\n"
"                   указване на името или номера на сигнала за изпращане\n"
"  -l, --list       извеждане на имената на сигналите, преобразуване в/от "
"номера\n"
"  -t, --table      извеждане на таблица с информация за сигналите\n"

#: src/kill.c:97
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"СИГНАЛът може да бъде име на сигнал (напр. „HUP“), номер (напр. „1“)\n"
"или код-състояние на изход на процес, прекратен чрез сигнал.\n"
"ИДентификаторът_на_ПРоцес е цяло число, ако е отрицателно — указва\n"
"група от процеси.\n"

#: src/kill.c:206
#, c-format
msgid "%s: invalid process id"
msgstr "%s: неправилен номер на процес"

#: src/kill.c:260
#, c-format
msgid "invalid option -- %c"
msgstr "неправилна опция — „%c“"

#: src/kill.c:269
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: посочени са много сигнали"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "посочени са много опции „-l“ или „-t“"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "не може да се задават сигнали заедно с „-l“ или „-t“"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "не е посочен идентификатор на процес"

#: src/libstdbuf.c:108
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "неправилен режим на буфериране „%s“ за „%s“\n"

#: src/libstdbuf.c:120
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "неуспешно заделяне на буфер за стандартния изход от %<PRIuMAX> байта\n"

#: src/libstdbuf.c:130
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "режимът на буферирането на „%s“ не може да се зададе да е „%s“\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:52
msgid "Michael Stone"
msgstr "Michael Stone"

#: src/link.c:45
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ФАЙЛ_1 ФАЙЛ_2\n"
"     или: %s ОПЦИЯ\n"

#: src/link.c:48
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"Създаване на твърда връзка ФАЙЛ_2 към съществуващ ФАЙЛ_1.\n"
"\n"

#: src/link.c:89
#, c-format
msgid "cannot create link %s to %s"
msgstr "неуспешно създаване на връзка „%s“ към „%s“"

#: src/ln.c:213
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: твърди връзки към директории не са позволени"

#: src/ln.c:238
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: директорията не може да се презапише"

#: src/ln.c:285
#, c-format
msgid "%s: replace %s? "
msgstr "%s: да се замени ли „%s“? "

#: src/ln.c:380
#, c-format
msgid "failed to create symbolic link %s"
msgstr "неуспешно създаване на символна връзка „%s“"

#: src/ln.c:381
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "неуспешно създаване на символна връзка „%s“ към „%s“"

#: src/ln.c:383
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "неуспешно създаване на твърда връзка към „%.0s%s“"

#: src/ln.c:386
#, c-format
msgid "failed to create hard link %s"
msgstr "неуспешно създаване на твърдата връзка „%s“"

#: src/ln.c:387
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "не може да се създаде твърда връзка „%s“ към „%s“"

#: src/ln.c:409
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME\n"
"  or:  %s [OPTION]... TARGET\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [-T] ЦЕЛ ИМЕ_НА_ВРЪЗКА\n"
"     или: %s [ОПЦИЯ]… ЦЕЛ\n"
"     или: %s [ОПЦИЯ]… ЦЕЛ… ДИРЕКТОРИЯ\n"
"     или: %s [ОПЦИЯ]… --target-directory=ДИРЕКТОРИЯ ЦЕЛ…\n"

#: src/ln.c:416
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""
"В първия вариант се създава връзка към посочената ЦЕЛ с такова "
"ИМЕ_НА_ВРЪЗКА.\n"
"Във втория вариант се създава връзка към посочената ЦЕЛ в текущата "
"директория.\n"
"В третия и четвъртия варианти в ДИРекторията се създават връзки към ЦЕЛите.\n"
"Стандартно не трябва да има обекти с имена като на новосъздадените връзки.\n"
"При правенето на твърди връзки всички ЦЕЛи трябва да съществуват.  "
"Символните\n"
"връзки нямат такова ограничение и може да сочат към несъществуваща ЦЕЛ.\n"
"Относителна ЦЕЛ на символна връзка се определя спрямо родителската ѝ "
"директория.\n"

#: src/ln.c:429
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=МЕТОД]        резервно копие на всеки съществуващ целеви "
"файл\n"
"  -b                          като „--backup“, но не приема аргумент\n"
"  -d, -F, --directory         позволяване на системните потребители да се "
"опитат\n"
"                              да правят твърди връзки към директории.  "
"Вероятно\n"
"                              ще получите грешка поради ограничения в "
"системата\n"
"  -f, --force                 изтриване на съществуващите целеви файлове\n"

#: src/ln.c:437
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              create symbolic links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive           питане дали целите да се трият\n"
"  -L, --logical               следване на ЦЕЛи, които са символни връзки\n"
"  -n, --no-dereference        обработване на ИМЕто_НА_ВРЪЗКА като нормален "
"файл,\n"
"                              ако сочи към директория\n"
"  -P, --physical              създаване на твърди връзки към символни "
"връзки\n"
"  -r, --relative              създаване на относителни символни връзки "
"спрямо\n"
"                              местоположението на връзката\n"
"  -s, --symbolic              създаване на символни, а не на твърди връзки\n"

#: src/ln.c:446
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=СУФИКС         ползване на този СУФИКС за резервни копия\n"
"  -t, --target-directory=ДИР  в коя ДИРектория да се правят връзките\n"
"  -T, --no-target-directory   работа с ИМЕ_НА_ВРЪЗКА като нормален файл\n"
"  -v, --verbose               извеждане на името на всеки файл при "
"създаване\n"
"                              на връзка\n"

#: src/ln.c:456
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""
"\n"
"При ползването на „-s“ опциите „-L“ и „-P“ се прескачат.  Иначе последната\n"
"опция определя поведението, когато ЦЕЛта е символна връзка — стандартно то "
"е\n"
"същото като „%s“.\n"

#: src/ln.c:572
msgid "cannot do --relative without --symbolic"
msgstr "опцията „--relative“ изисква „--symbolic“"

#: src/ln.c:584
msgid "cannot combine --target-directory and --no-target-directory"
msgstr "опциите „--target-directory“ и „--no-target-directory“ са несъвместими"

#: src/ln.c:632
#, c-format
msgid "target %s"
msgstr "цел „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME: името на автора не се знае"

#: src/logname.c:39
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "Употреба: %s [ОПЦИЯ]\n"

#: src/logname.c:40
msgid ""
"Print the name of the current user.\n"
"\n"
msgstr ""
"Извеждане на името на текущия потребител.\n"
"\n"

#: src/logname.c:78
msgid "no login name"
msgstr "няма входящо име"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:777
msgid "%b %e  %Y"
msgstr "%e %b %Y"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:790
msgid "%b %e %H:%M"
msgstr "%e %b %H:%M"

#: src/ls.c:1930
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr ""
"пренебрегване на неправилната широчина на реда от променливата на средата "
"„COLUMNS“: %s"

#: src/ls.c:1955
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr ""
"пренебрегване на неправилния размер на табулацията от променливата на "
"средата „TABSIZE“: %s"

#: src/ls.c:2074
msgid "invalid line width"
msgstr "неправилна широчина на реда"

#: src/ls.c:2142
msgid "invalid tab size"
msgstr "неправилен размер на табулатора"

#: src/ls.c:2376
#, c-format
msgid "invalid time style format %s"
msgstr "неправилен формат на време: %s"

#: src/ls.c:2400
msgid "Valid arguments are:\n"
msgstr "Възможните аргументи са:\n"

#: src/ls.c:2404
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr "  ⁃ +ФОРМАТ (напр. „+%H:%M“) за форматиране като дата\n"

#: src/ls.c:2778
#, c-format
msgid "unrecognized prefix: %s"
msgstr "непознат префикс: %s"

#: src/ls.c:2808
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "неразбираема стойност на променливата на средата „LS_COLORS“"

#: src/ls.c:2838 src/stat.c:1046
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr ""
"пренебрегване на неправилния начин на цитиране от променливата на средата "
"„QUOTING_STYLE“: %s"

#: src/ls.c:2905 src/pwd.c:164
#, c-format
msgid "cannot open directory %s"
msgstr "директорията „%s“ не може да се отвори"

#: src/ls.c:2920
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "устройството и i-възелът на „%s“ не могат да се определят"

#: src/ls.c:2929
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s: без извеждане на вече изведена директория"

#: src/ls.c:2954 src/ls.c:3390 src/selinux.c:127 src/selinux.c:300
#, c-format
msgid "error canonicalizing %s"
msgstr "грешка при определянето на каноничния вариант на „%s“"

#: src/ls.c:3017 src/ls.c:3032 src/pwd.c:232
#, c-format
msgid "reading directory %s"
msgstr "четене на директория „%s“"

#: src/ls.c:3048
#, c-format
msgid "closing directory %s"
msgstr "затваряне на директория „%s“"

#: src/ls.c:3765
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "имената на файловете „%s“ и „%s“ не може да се сравнят"

#: src/ls.c:5343
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""
"Извеждане на информация за ФАЙЛовете (по подразбиране за текущата "
"директория).\n"
"Спазване на азбучна подредба, освен ако има опция „-cftuvSUX“ или „--sort“.\n"
"\n"

#: src/ls.c:5350
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all                  без обектите, които започват с „.“\n"
"  -A, --almost-all           без стандартните „.“ и „..“\n"
"      --author               с „-l“ извежда автора на всеки файл\n"
"  -b, --escape               осмично представяне на неграфичните знаци\n"

#: src/ls.c:5356
msgid ""
"      --block-size=SIZE      with -l, scale sizes by SIZE when printing "
"them;\n"
"                               e.g., '--block-size=M'; see SIZE format "
"below\n"
msgstr ""
"      --block-size=РАЗМЕР    заедно с „-l“: мащабиране на стойностите към "
"този\n"
"                             РАЗМЕР при извеждането им, напр. „--block-"
"size=M“.\n"
"                             Вж. по-долу за възможните стойности  на "
"РАЗМЕРа\n"

#: src/ls.c:5360
msgid ""
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                               modification of file status information);\n"
"                               with -l: show ctime and sort by name;\n"
"                               otherwise: sort by ctime, newest first\n"
msgstr ""
"  -B, --ignore-backups       без обектите с имена, завършващи с „~“\n"
"  -c                         с „-lt“: показване и подредба според „ctime“\n"
"                             (времето на последна промяна на информацията "
"за\n"
"                             файла);\n"
"                             с „-l“: показване на ctime, но подредба по "
"името;\n"
"                             иначе: подредба според ctime, най-новите — "
"отпред.\n"

#: src/ls.c:5367
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         colorize the output; WHEN can be "
"'always' (default\n"
"                               if omitted), 'auto', or 'never'; more info "
"below\n"
"  -d, --directory            list directories themselves, not their "
"contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         извеждане на елементите в колони\n"
"      --color[=КОГА]         дали да се използват цветове за посочване на\n"
"                             видовете файлове.  КОГА може да бъде\n"
"                             „never“ (никога), „always“ (винаги) или\n"
"                             „auto“ (автоматично)\n"
"  -d, --directory            извеждане на директориите, вместо съдържанието "
"им\n"
"                             и символните връзки, вместо сочените файлове\n"
"  -D, --dired                изход във формат за режима „dired“ на Емакс\n"

#: src/ls.c:5376
msgid ""
"  -f                         do not sort, enable -aU, disable -ls --color\n"
"  -F, --classify             append indicator (one of */=>@|) to entries\n"
"      --file-type            likewise, except do not append '*'\n"
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                               single-column -1, verbose -l, vertical -C\n"
"      --full-time            like -l --time-style=full-iso\n"
msgstr ""
"  -f                         без подредба, включва „-aU“, изключва „-ls --"
"color“\n"
"  -F, --classify             добавяне на знак за вида на файловете (някой "
"от:\n"
"                             „*“, „/“, „=“, „>“, „@“, „|“)\n"
"      --file-type            същото без добавяне на знака „*“\n"
"      --format=ДУМА          „across“≡„horizontal“≡„-x“ (хоризонтална "
"подредба\n"
"                             по колони),\n"
"                             „vertical“≡„-C“ (вертикална подредба по "
"колони),\n"
"                             „commas“≡„-m“ (хоризонтално изброяване със "
"„,“),\n"
"                             „long“≡„verbose“≡„-l“ (подробен изход),\n"
"                             „single-column“≡„-1“ (по файл на ред).\n"
"      --full-time            същото като „-l --time-style=full-iso“\n"

#: src/ls.c:5384
msgid "  -g                         like -l, but do not list owner\n"
msgstr ""
"  -g                         като „-l“, но без извеждане на собственика\n"

#: src/ls.c:5387
msgid ""
"      --group-directories-first\n"
"                             group directories before files;\n"
"                               can be augmented with a --sort option, but "
"any\n"
"                               use of --sort=none (-U) disables grouping\n"
msgstr ""
"      --group-directories-first\n"
"                             групиране на директориите преди файловете, може "
"да\n"
"                             се комбинира с опция „--sort“, но „--sort=none“ "
"или\n"
"                             „-U“ изключват групирането\n"

#: src/ls.c:5393
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
msgstr "  -G, --no-group             без имена на групите при подробен изход\n"

#: src/ls.c:5396
msgid ""
"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G "
"etc.\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -h, --human-readable       с „-l“ и „-s“ извежда размери във формат 1K, "
"234M,\n"
"                             2G и т.н.\n"
"      --si                   същото, но се ползват степени на 10 (100), а не "
"на\n"
"                             2 (1024)\n"

#: src/ls.c:5400
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                               that points to a directory\n"
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                               (overridden by -a or -A)\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             следване на символните връзки на командния ред\n"
"      --dereference-command-line-symlink-to-dir\n"
"                             следване на символните връзки на командния "
"ред, \n"
"                             които сочат към директории\n"
"      --hide=ОБРАЗЕЦ         без извеждане на елементите, пасващи на "
"ОБРАЗЕЦ\n"
"                             (пренебрегва се, ако има „-a“ или „-A“)\n"

#: src/ls.c:5410
msgid ""
"      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
"                               (default if omitted), 'auto', or 'never'\n"
msgstr ""
"      --hyperlink[=КОГАТО]   хипервръзки за имената на файлове, КОГАТО може "
"да\n"
"                             е „always“ (винаги — стандартно), „auto“\n"
"                             (автоматично) или „never“ (никога)\n"

#: src/ls.c:5414
msgid ""
"      --indicator-style=WORD  append indicator with style WORD to entry "
"names:\n"
"                               none (default), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
msgstr ""
"      --indicator-style=СТИЛ добавяне на знак в СТИЛа към имената на "
"файловете:\n"
"                             „none“ (стандартно — без), „slash“ (-p),\n"
"                             „file-type“ (--file-type), „classify“ (-F)\n"
"  -i, --inode                извеждане на номера на i-възела на всеки файл\n"
"  -I, --ignore=ШАБЛОН        без извеждане на обектите с имена по ШАБЛОНа\n"

#: src/ls.c:5423
msgid ""
"  -k, --kibibytes            default to 1024-byte blocks for disk usage;\n"
"                               used only with -s and per directory totals\n"
msgstr ""
"  -k, --kibibytes            да се ползват степени на 2 (блокове по 1024 "
"байта)\n"
"                             при извеждане на заетото дисково пространство.\n"
"                             Важи само при „-s“ и обобщенията по директории\n"

#: src/ls.c:5427
msgid ""
"  -l                         use a long listing format\n"
"  -L, --dereference          when showing file information for a symbolic\n"
"                               link, show information for the file the link\n"
"                               references rather than for the link itself\n"
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -l                         формат с подробно изброяване\n"
"  -L, --dereference          при показване на информация за символна връзка\n"
"                             да се показва информация за сочения файл вместо "
"за\n"
"                             самата символна връзка\n"
"  -m                         извеждане на елементите по редове, разделени\n"
"                             със запетая\n"

#: src/ls.c:5435
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print entry names without quoting\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      като „-l“, но с номера за потребител и група\n"
"  -N, --literal              извеждане на неекранирани, дословни имена\n"
"  -o                         като „-l“, но без извеждане на групата\n"
"  -p, --indicator-style=slash\n"
"                             добавяне на знак „/“ към имената на "
"директориите\n"

#: src/ls.c:5442
msgid ""
"  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
"      --show-control-chars   show nongraphic characters as-is (the default,\n"
"                               unless program is 'ls' and output is a "
"terminal)\n"
"  -Q, --quote-name           enclose entry names in double quotes\n"
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                               literal, locale, shell, shell-always,\n"
"                               shell-escape, shell-escape-always, c, escape\n"
"                               (overrides QUOTING_STYLE environment "
"variable)\n"
msgstr ""
"  -q, --hide-control-chars   заместване на неграфичните знаци с „?“\n"
"      --show-control-chars   извеждане на неграфичните знаци както са си\n"
"                             (стандартно, освен ако програмата е „ls“ и\n"
"                             изходът е терминал)\n"
"  -Q, --quote-name           заграждане на имената на елементите с „\"“\n"
"      --quoting-style=СТИЛ   СТИЛ на екраниране на имената на елементите —\n"
"                             с превес пред указаното от променливата на\n"
"                             средата „QUOTING_STYLE“:\n"
"                             ⁃ „literal“ (дословно — без екраниране);\n"
"                             ⁃ „locale“ (цитиране с кавички от локала);\n"
"                             ⁃ „shell“ (цитиране при наличие на специални\n"
"                               знаци на обвивката);\n"
"                             ⁃ „shell-always“ (цитиране дори и без нужда);\n"
"                             ⁃ „c“ (цитиране като литерали на C и\n"
"                               обхващащи „\"“);\n"
"                             ⁃ „escape“ (като литерали на C без обхващащи "
"„\"“).\n"

#: src/ls.c:5453
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse              подредба в обратен ред\n"
"  -R, --recursive            рекурсивно извеждане на поддиректориите\n"
"  -s, --size                 извеждане на размера на всеки файл в блокове\n"

#: src/ls.c:5458
msgid ""
"  -S                         sort by file size, largest first\n"
"      --sort=WORD            sort by WORD instead of name: none (-U), size (-"
"S),\n"
"                               time (-t), version (-v), extension (-X)\n"
"      --time=WORD            change the default of using modification "
"times;\n"
"                               access time (-u): atime, access, use;\n"
"                               change time (-c): ctime, status;\n"
"                               birth time: birth, creation;\n"
"                             with -l, WORD determines which time to show;\n"
"                             with --sort=time, sort by WORD (newest first)\n"
msgstr ""
"  -S                         подредба според размера, най-големите отпред\n"
"      --sort=ДУМА            подредба според ДУМАта: „size“≡„-S“, „time“≡„-"
"t“\n"
"                             „none“≡„-U“, „version“≡„-v“, „extension“≡„-X“\n"
"      --time=ВИД_ВРЕМЕ       ВИДът_ВРЕМЕ може да е:\n"
"                               ⁃ „atime“/„access“/„use“≡„-u“ (достъп) или\n"
"                               ⁃ „ctime“/„status“≡„-c“ (създаване).\n"
"                             С „-l“ се показва този ВИД_ВРЕМЕ вместо "
"времето\n"
"                             на промяна, а с „--sort=time“ се подрежда по\n"
"                             съответното време (най-новите —  отпред)\n"

#: src/ls.c:5470
msgid ""
"      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE "
"below\n"
msgstr ""
"      --time-style=ФОРМАТ_ЗА_ВРЕМЕТО\n"
"                               ФОРМАТ_ЗА_ВРЕМЕТО за опцията „-l“, вж. по-"
"долу\n"

#: src/ls.c:5473
msgid ""
"  -t                         sort by time, newest first; see --time\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         подредба по време, от нови към стари (вж. „--"
"time“)\n"
"  -T, --tabsize=РАЗМЕР       табулаторите са с този РАЗМЕР вместо 8 "
"интервала\n"

#: src/ls.c:5477
msgid ""
"  -u                         with -lt: sort by, and show, access time;\n"
"                               with -l: show access time and sort by name;\n"
"                               otherwise: sort by access time, newest first\n"
"  -U                         do not sort; list entries in directory order\n"
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -u                         с „-lt“: показване и подредба според времето "
"на\n"
"                             достъп;\n"
"                             с „-l“: показване на времето, но подредба по "
"името;\n"
"                             иначе: подредба според времето, най-новите — "
"отпред.\n"
"  -U                         без подредба — както е в директорията\n"
"  -v                         подредба с тълкуване на имената като версии\n"

#: src/ls.c:5484
msgid ""
"  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any security context of each file\n"
"  -1                         list one file per line.  Avoid '\\n' with -q or "
"-b\n"
msgstr ""
"  -w, --width=КОЛОНИ         извеждане на този брой КОЛОНИ.  0 — означава, "
"че\n"
"                             няма ограничения\n"
"  -x                         извеждане на елементите по редове, а не в "
"стълбове\n"
"  -X                         подредба в азбучен ред според разширението\n"
"  -Z, --context              извеждане на контекста на сигурността на "
"обектите\n"
"  -1                         извеждане по един файл на ред\n"

#: src/ls.c:5495
msgid ""
"\n"
"The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n"
"FORMAT is interpreted like in date(1).  If FORMAT is "
"FORMAT1<newline>FORMAT2,\n"
"then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n"
"TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX "
"locale.\n"
"Also the TIME_STYLE environment variable sets the default style to use.\n"
msgstr ""
"\n"
"Аргументът ФОРМАТ_НА_ВРЕМЕТО може да е „full-iso“, “long-iso“, „iso“, "
"„locale“\n"
"или “+ФОРМАТ“.  ФОРМАТът е същият както за командата „date(1)“.  Ако "
"ФОРМАТът\n"
"съдържа нов ред: ФОРМАТ_1<нов ред>ФОРМАТ_2, то вторият формат се отнася за\n"
"скорошните файлове, а първият — за всички останали.  Ако "
"ФОРМАТът_НА_ВРЕМЕТО\n"
"започва с „posix-“, то той се ползва само извън локала по POSIX.  "
"Променливата\n"
"на средата „TIME_STYLE“ задава стандартния стил.\n"

#: src/ls.c:5503
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors command to set it.\n"
msgstr ""
"\n"
"Използването на цвят за разграничаване на файловете по вид стандартно е\n"
"изключено както и при задаването на опцията „--color=never“.  При задаване\n"
"на „--color=auto“ командата „ls“ извежда кодове за цвят, само когато "
"изходът\n"
"се извежда на терминал.  Променливата на средата „LS_COLORS“ позволява\n"
"допълнителни настройки.  Може да я зададете с командата „dircolors“.\n"

#: src/ls.c:5510
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"Изходен код:\n"
" 0  — ако всичко е наред;\n"
" 1  — при леки проблеми (напр. няма достъп до поддиректория);\n"
" 2  — при сериозни проблеми (напр. няма достъп до аргумент на командния "
"ред).\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:108
msgid "Samuel Neves"
msgstr "Samuel Neves"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:111 src/seq.c:48
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:112
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/md5sum.c:113
msgid "David Madore"
msgstr "David Madore"

#: src/md5sum.c:229
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"Print or check %s (%d-bit) checksums.\n"
msgstr ""
"Употреба: %s [ОПЦИЯ] [ФАЙЛ]…\n"
"Извеждане или проверка на контролни суми %s (%d-битови).\n"

#: src/md5sum.c:239
msgid ""
"\n"
"  -b, --binary         read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"\n"
"-b, --binary   четене в двоичен режим (стандартно, освен при стандартен "
"вход\n"
"                 от терминал)\n"

#: src/md5sum.c:244
msgid ""
"\n"
"  -b, --binary         read in binary mode\n"
msgstr ""
"\n"
"  -b, --binary   четене в двоичен режим\n"

#: src/md5sum.c:249
#, c-format
msgid "  -c, --check          read %s sums from the FILEs and check them\n"
msgstr ""
"  -c, --check          изчитане на контролните суми „%s“ от ФАЙЛовете и\n"
"                       проверка\n"

#: src/md5sum.c:253
msgid ""
"  -l, --length         digest length in bits; must not exceed the maximum "
"for\n"
"                       the blake2 algorithm and must be a multiple of 8\n"
msgstr ""
"  -l, --length         дължина на контролната сума в битове — трябва да е "
"кратна\n"
"                       на 8 и да е по-малка от максимума за алгоритъма "
"„blake2“\n"

#: src/md5sum.c:258
msgid "      --tag            create a BSD-style checksum\n"
msgstr "      --tag            създаване на контролна сума в стила на BSD\n"

#: src/md5sum.c:262
msgid ""
"  -t, --text           read in text mode (default if reading tty stdin)\n"
msgstr ""
"  -t, --text           четене в текстов режим (при стандартен вход от "
"терминал)\n"

#: src/md5sum.c:266
msgid "  -t, --text           read in text mode (default)\n"
msgstr "  -t, --text           четене в текстов режим (стандартно)\n"

#: src/md5sum.c:269
msgid ""
"  -z, --zero           end each output line with NUL, not newline,\n"
"                       and disable file name escaping\n"
msgstr ""
"  -z, --zero           завършване на всеки ред с нулев байт, а не нов ред,\n"
"                       и без екраниране на знаците в имената\n"

#: src/md5sum.c:273
msgid ""
"\n"
"The following five options are useful only when verifying checksums:\n"
"      --ignore-missing  don't fail or report status for missing files\n"
"      --quiet          don't print OK for each successfully verified file\n"
"      --status         don't output anything, status code shows success\n"
"      --strict         exit non-zero for improperly formatted checksum "
"lines\n"
"  -w, --warn           warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"Следните две опции са полезни само при проверяване на контролни суми:\n"
"      --ignore-missing  без съобщения за липсващи файлове\n"
"      --quiet           без съобщения за успешно проверен файл\n"
"      --status          без съобщения, успехът се определя според кода за "
"изход\n"
"      --strict          изход при неправилно форматирани редове със суми\n"
"  -w, --warn            съобщения при неправилно форматирани редове със "
"суми\n"

#: src/md5sum.c:285
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print a\n"
"line with checksum, a space, a character indicating input mode ('*' for "
"binary,\n"
"' ' for text or where binary is insignificant), and name for each FILE.\n"
"\n"
"Note: There is no difference between binary mode and text mode on GNU "
"systems.\n"
msgstr ""
"\n"
"Сумите се изчисляват така, както е посочено в „%s“.  При проверка входът\n"
"трябва да бъде предишен изход от тази програма.  По подразбиране се извежда "
"ред\n"
"с контролна сума, знак посочващ типа („*“ за двоичен, „ “ за текстов или "
"когато\n"
"това няма значение) и името на всеки ФАЙЛ.\n"
"\n"
"На системи GNU няма разлика между текстов и двоичен режим.\n"

#: src/md5sum.c:697
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s: твърде много редове за контролни суми"

#: src/md5sum.c:720
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s: %<PRIuMAX>: неправилно форматиран ред с контролна сума „%s“"

#: src/md5sum.c:752
msgid "FAILED open or read"
msgstr "НЕУСПЕШНО изпълнение на „open“ или „read“"

#: src/md5sum.c:790
msgid "FAILED"
msgstr "НЕУСПЕХ"

#: src/md5sum.c:792
msgid "OK"
msgstr "УСПЕХ"

#: src/md5sum.c:816
#, c-format
msgid "%s: no properly formatted %s checksum lines found"
msgstr "%s: не са открити правилно форматирани %s редове с контролни суми"

#: src/md5sum.c:826
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> ред е неправилно форматиран"
msgstr[1] "ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> реда са неправилно форматирани"

#: src/md5sum.c:834
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> изброен файл не може да бъде прочетен"
msgstr[1] ""
"ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> изброени файла не могат да бъде прочетени"

#: src/md5sum.c:842
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> пресметната контролна сума НЕ пасва"
msgstr[1] "ПРЕДУПРЕЖДЕНИЕ: %<PRIuMAX> пресметнати контролни суми НЕ пасват"

#: src/md5sum.c:848
#, c-format
msgid "%s: no file was verified"
msgstr "%s: файлът не е проверен"

#: src/md5sum.c:898
msgid "invalid length"
msgstr "неправилна дължина"

#: src/md5sum.c:902 src/md5sum.c:954
#, c-format
msgid "invalid length: %s"
msgstr "неправилна дължина: %s"

#: src/md5sum.c:903
msgid "length is not a multiple of 8"
msgstr "размерът не е кратен на 8"

#: src/md5sum.c:956
#, c-format
msgid "maximum digest length for %s is %<PRIuMAX> bits"
msgstr "максималната дължина на контролната сума за „%s“ е %<PRIuMAX> бита"

#: src/md5sum.c:974
#, c-format
msgid "--tag does not support --text mode"
msgstr "опцията „--tag“ не поддържа режима на „--text“"

#: src/md5sum.c:980
#, c-format
msgid "the --zero option is not supported when verifying checksums"
msgstr "опцията „--zero“ не се поддържа при проверката на контролни суми"

#: src/md5sum.c:987
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "опцията „--tag“ е безсмислена при проверка на контролни суми"

#: src/md5sum.c:994
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"опциите „--binary“ и „--text“ са безсмислени при проверка на контролни суми"

#: src/md5sum.c:1002
#, c-format
msgid "the --ignore-missing option is meaningful only when verifying checksums"
msgstr ""
"опцията „--ignore-missing“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1010
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "опцията „--status“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1017
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "опцията „--warn“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1024
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "опцията „--quiet“ е смислена само при проверка на контролни суми"

#: src/md5sum.c:1031
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "опцията „--strict“ е смислена само при проверка на контролни суми"

#: src/mkdir.c:59 src/rmdir.c:164
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ДИРЕКТОРИЯ…\n"

#: src/mkdir.c:60
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr ""
"Създаване на ДИРЕКТОРИите, ако не са създадени вече.\n"
"\n"

#: src/mkdir.c:66
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as needed\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""
"  -m, --mode=РЕЖИМ  РЕЖИМ за достъп (като „chmod“), а не „a=rwx“ — „umask“\n"
"  -p, --parents     създаване на родителските директории, без грешка за\n"
"                    съществуващи\n"
"  -v, --verbose     извеждане на съобщение за всяка създадена директория\n"

#: src/mkdir.c:71
msgid ""
"  -Z                   set SELinux security context of each created "
"directory\n"
"                         to the default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   задаване на стандартен за вида контекст на сигурност "
"за\n"
"                       SELinux или SMACK на всяка създадена директория\n"
"      --context[=КОНТЕКСТ]\n"
"                        като „-Z“, но при задаването се прилага този "
"КОНТЕКСТ\n"
"                        за SELinux или SMACK\n"

#: src/mkdir.c:221
#, c-format
msgid "created directory %s"
msgstr "създадена е директория „%s“"

#: src/mkdir.c:239 src/mkfifo.c:117 src/mknod.c:134
#, c-format
msgid ""
"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--context“ се прескача, защото изисква ядро с "
"поддръжката на SELinux или SMACK"

#: src/mkfifo.c:54 src/pathchk.c:88
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ИМЕ…\n"

#: src/mkfifo.c:55
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr "Създаване на именувани канали (FIFO) с посочените ИМЕна.\n"

#: src/mkfifo.c:61 src/mknod.c:63
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=РЕЖИМ  задаване на РЕЖИМ за достъп, в допълнение към „a=rw“\n"

#: src/mkfifo.c:64 src/mknod.c:66
msgid ""
"  -Z                   set the SELinux security context to default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   задаване на стандартен за вида контекст на сигурност "
"за\n"
"                       SELinux или SMACK\n"
"      --context[=КОНТЕКСТ]\n"
"                        като „-Z“, но при задаването се прилага този "
"КОНТЕКСТ\n"
"                        за SELinux или SMACK\n"

#: src/mkfifo.c:154 src/mknod.c:151
msgid "invalid mode"
msgstr "неправилен режим за достъп"

#: src/mkfifo.c:161 src/mknod.c:158
msgid "mode must specify only file permission bits"
msgstr "режимът трябва да определя само битовете за достъп до файла"

#: src/mkfifo.c:175 src/mknod.c:271
#, c-format
msgid "cannot set permissions of %s"
msgstr "правата за достъп до „%s“ не може да се зададат"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "Употреба: %s [ОПЦИЯ]… ИМЕ ВИД [ГОЛЯМ МАЛЪК]\n"

#: src/mknod.c:57
msgid "Create the special file NAME of the given TYPE.\n"
msgstr "Създаване на специален файл с посоченото ИМЕ и дадения ВИД.\n"

#: src/mknod.c:73
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"Както ГОЛЯМ, така и МАЛЪК трябва да се посочат, когато ВИДът е „b“, „c“ или "
"„u“,\n"
"и трябва да се пропуснат, когато  той е „p“.  Ако ГОЛЯМ или МАЛЪК започва с "
"0x\n"
"или 0X, номерът се интерпретира като шестнадесетичен, ако започва с 0 — "
"като\n"
"осмичен, а в останалите случаи — като десетичен.  ВИДът може да е:\n"

#: src/mknod.c:80
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      блоков (буфериран) специален файл\n"
"  c, u   знаков (небуфериран) специален файл\n"
"  p      именуван канал\n"

#: src/mknod.c:176
msgid "Special files require major and minor device numbers."
msgstr ""
"При създаване на специални файлове трябва да се посочат и голям, и малък "
"номер на устройство"

#: src/mknod.c:186
msgid "Fifos do not have major and minor device numbers."
msgstr "Именуваните канали нямат малък и голям номер на устройство."

#: src/mknod.c:211
msgid "block special files not supported"
msgstr "работа с блокови специални файлове не се поддържа "

#: src/mknod.c:220
msgid "character special files not supported"
msgstr "работа със знакови специални файлове не се поддържа"

#: src/mknod.c:236
#, c-format
msgid "invalid major device number %s"
msgstr "грешен голям номер на устройство „%s“"

#: src/mknod.c:241
#, c-format
msgid "invalid minor device number %s"
msgstr "грешен малък номер на устройство „%s“"

#: src/mknod.c:246
#, c-format
msgid "invalid device %s %s"
msgstr "неправилно устройство „%s %s“"

#: src/mknod.c:266
#, c-format
msgid "invalid device type %s"
msgstr "неправилен вид на устройство „%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:67
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ШАБЛОН]…\n"

#: src/mktemp.c:68
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"Надеждно създаване на временен файл или директория и извеждане на името им.\n"
"ШАБЛОНът трябва да съдържа поне 3 последователни знака „X“ в крайна "
"позиция.\n"
"За стандартен ШАБЛОН се ползва „tmp.XXXXXXXXXX“, ако такъв не е даден, и се\n"
"приема, че е ползвана опцията „--tmpdir“.\n"

#: src/mktemp.c:73
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr ""
"Файловете са с права „u+rw“, а директориите с „u+rwx“, като естествено се "
"махат\n"
"правата указани с „umask“.\n"

#: src/mktemp.c:77
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     създаване на директория, а не файл\n"
"  -u, --dry-run       без създаване на обект, само отпечатване на име\n"
"                      (това не е безопасно!)\n"
"  -q, --quiet         без диагностичните съобщение при неуспешно създаване "
"на\n"
"                      файл/директория\n"

#: src/mktemp.c:82
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X\n"
msgstr ""
"      --suffix=СУФИКС добавяне на СУФИКСа към ШАБЛОНа.  СУФИКСЪТ трябва да "
"не\n"
"                      съдържа „-“.  Тази опция се подразбира, ако ШАБЛОНът\n"
"                      не завършва на „X“\n"

#: src/mktemp.c:86
msgid ""
"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name;\n"
"                        unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""
"  -p ДИР, --tmpdir[=ДИР]\n"
"                        ШАБЛОНЪТ се интерпретира спрямо тази ДИРектория.  "
"Ако\n"
"                        тя не е зададена, се ползва съдържанието на "
"„TMPDIR“, а\n"
"                        ако и то липсва — „/tmp“.  При задаването на тази "
"опция\n"
"                        ШАБЛОНЪТ не може да е абсолютно име за разлика от\n"
"                        опцията „-t“.  ШАБЛОНът може да съдържа „/“, но\n"
"                        командата „mktemp“ създава само последния компонент\n"

#: src/mktemp.c:93
msgid ""
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -t                  ШАБЛОНът определя името на файла спрямо директорията\n"
"                      която е зададена в „$TMPDIR“.  Ако няма такава —\n"
"                      зададената с опцията „-p“, а ако и такава няма — „/"
"tmp“\n"
"                      (остарял вариант)\n"

#: src/mktemp.c:211
#, c-format
msgid "too many templates"
msgstr "прекалено много шаблони"

#: src/mktemp.c:231
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "с опцията „--suffix“ шаблонът „%s“ трябва да завършва с „X“"

#: src/mktemp.c:256 src/split.c:1345
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "неправилен суфикс „%s“ — съдържа разделител на директории"

#: src/mktemp.c:261
#, c-format
msgid "too few X's in template %s"
msgstr "недостатъчен брой знаци „X“ в шаблона „%s“"

#: src/mktemp.c:277
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "неправилен шаблон „%s“ — съдържа разделител на директории"

#: src/mktemp.c:291
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr ""
"неправилен шаблон „%s“ — указва абсолютно име, а е зададена опцията „--"
"tmpdir“"

#: src/mktemp.c:312
#, c-format
msgid "failed to create directory via template %s"
msgstr "неуспешно създаване на временна директория по шаблона „%s“"

#: src/mktemp.c:323
#, c-format
msgid "failed to create file via template %s"
msgstr "неуспешно създаване на временен файл по шаблона „%s“"

#: src/mv.c:298
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr ""
"Преименуване на ИЗТОЧНИК като ЦЕЛ или преместване на ИЗТОЧНИците в "
"ДИРЕКТОРИЯта.\n"

#: src/mv.c:304
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=МЕТОД]       резервно копие на съществуващи целеви файлове\n"
"  -b                         като „--backup“, но без аргумент\n"
"  -f, --force                без питане преди заместване на файлове\n"
"  -i, --interactive          с питане преди заместване на файлове\n"
"  -n, --no-clobber           без презаписване на съществуващи файлове\n"
"При посочване на повече от една от опциите „-i“, „-f“, „-n“ се взема "
"предвид\n"
"последната.\n"

#: src/mv.c:313
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes отстраняване на крайните наклонени черти от\n"
"                               всички ЦЕЛи\n"
"  -S, --suffix=СУФИКС          суфикс за резервните копия\n"

#: src/mv.c:318
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -Z, --context                set SELinux security context of destination\n"
"                                 file to default type\n"
msgstr ""
"      --target-directory=ДИР   преместване на всички ИЗТОЧНИци в "
"ДИРекторията\n"
"  -T, --no-target-directory    обработка на ЦЕЛта като обикновен файл\n"
"  -u, --update                 преместване, само ако ИЗТОЧНИКът е по-нов от\n"
"                               целевия файл, или ако целевият файл липсва\n"
"  -v, --verbose                извеждане на действията\n"
"  -Z, --context                задаване на стандартен контекст за сигурност\n"
"                               на ЦЕЛта\n"

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "Употреба: %s [ОПЦИЯ] [КОМАНДА [АРГУМЕНТ]…]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""
"Изпълняване на КОМАНДАта със зададената стойност на „nice“, което принципно "
"влияе\n"
"на диспечера на задачите на операционната система.  Без КОМАНДА извежда "
"текущата\n"
"стойност на „nice“.  Диапазонът на „nice“ е от %d (най-голямо предимство за\n"
"процеса) до %d (най-малко предимство).\n"

#: src/nice.c:83
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"  -n, --adjustment=N   добавяне на N към стойността на nice (по подразбиране "
"10)\n"

#: src/nice.c:173
#, c-format
msgid "invalid adjustment %s"
msgstr "неправилна настройка: %s"

#: src/nice.c:182
#, c-format
msgid "a command must be given with an adjustment"
msgstr "трябва да зададете команда заедно с корекцията"

#: src/nice.c:189 src/nice.c:200
msgid "cannot get niceness"
msgstr "неуспешно получаване на стойността на „nice“"

#: src/nice.c:206
#, c-format
msgid "cannot set niceness"
msgstr "неуспешно задаване на стойността на „nice“"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:41
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:180
msgid "Write each FILE to standard output, with line numbers added.\n"
msgstr ""
"Извеждане на всеки от ФАЙЛовете на стандартния изход с номерирани редове.\n"

#: src/nl.c:187
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for logical page delimiters\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=СТИЛ       СТИЛ за номериране на редовете от тялото\n"
"  -d, --section-delimiter=ЗН      разделяне на логическите страници с тези\n"
"                                  два ЗНака\n"
"  -f, --footer-numbering=СТИЛ     СТИЛ за номериране на долния колонтитул\n"

#: src/nl.c:192
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers for each "
"section\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=СТИЛ     номериране на горния колонтитул с този "
"СТИЛ\n"
"  -i, --page-increment=СТЪПКА     СТЪПКА за нарастването на номера\n"
"  -l, --join-blank-lines=БРОЙ     номер само на последния ред при такъв "
"БРОЙ\n"
"                                  последователни празни редове\n"
"  -n, --number-format=ФОРМАТ      номера на редовете според този ФОРМАТ\n"
"  -p, --no-renumber               без рестартиране на броенето при нова\n"
"                                  логическа страница\n"
"  -s, --number-separator=НИЗ      добавяне на НИЗа след всеки номер на ред\n"

#: src/nl.c:200
msgid ""
"  -v, --starting-line-number=NUMBER  first line number for each section\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=НОМЕР\n"
"                                  този начален НОМЕР за всеки раздел\n"
"  -w, --number-width=БРОЙ         такъв БРОЙ знаци за номерата на редовете\n"

#: src/nl.c:206
msgid ""
"\n"
"Default options are: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n"
"\n"
"CC are two delimiter characters used to construct logical page delimiters;\n"
"a missing second character implies ':'.\n"
msgstr ""
"\n"
"Стандартните опции са: „-bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6“\n"
"\n"
"ЗН са двата ЗНака за разделяне на логическите страници.  Ако е пропуснат,\n"
"стандартно вторият е „:“.\n"

#: src/nl.c:213
msgid ""
"\n"
"STYLE is one of:\n"
"\n"
"  a      number all lines\n"
"  t      number only nonempty lines\n"
"  n      number no lines\n"
"  pBRE   number only lines that contain a match for the basic regular\n"
"         expression, BRE\n"
msgstr ""
"\n"
"Стилът е измежду:\n"
"\n"
"  ⁃ „a“  номериране на всички редове\n"
"  ⁃ „t“  номериране само на непразните редове\n"
"  ⁃ „n“  без никакво номериране\n"
"  ⁃ „pРЕГУЛЯРЕН_ИЗРАЗ“\n"
"        номериране само на редовете напасващи РЕГУЛЯРНия_ИЗРАЗ\n"
"\n"

#: src/nl.c:223
msgid ""
"\n"
"FORMAT is one of:\n"
"\n"
"  ln     left justified, no leading zeros\n"
"  rn     right justified, no leading zeros\n"
"  rz     right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"ФОРМАТът е измежду:\n"
"\n"
"  ⁃ „ln“   ляво подравняване, без предхождащи нули\n"
"  ⁃ „rn“   дясно подравняване, без предхождащи нули\n"
"  ⁃ „rz“   дясно подравняване, с предхождащи нули\n"
"\n"

#: src/nl.c:281
msgid "line number overflow"
msgstr "препълване на номера на ред"

#: src/nl.c:484
#, c-format
msgid "invalid header numbering style: %s"
msgstr "неправилен формат за номериране на горен колонтитул: %s"

#: src/nl.c:492
#, c-format
msgid "invalid body numbering style: %s"
msgstr "неправилен формат за номериране: %s"

#: src/nl.c:500
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "неправилен формат за номериране на долен колонтитул: %s"

#: src/nl.c:507
msgid "invalid starting line number"
msgstr "неправилно начално число"

#: src/nl.c:512
msgid "invalid line number increment"
msgstr "неправилна стъпка, с която да нарастват номерата на редовете"

#: src/nl.c:519
msgid "invalid line number of blank lines"
msgstr "неправилен брой празни редове"

#: src/nl.c:526
msgid "invalid line number field width"
msgstr "неправилна широчина на полето за номерата на редовете"

#: src/nl.c:537
#, c-format
msgid "invalid line numbering format: %s"
msgstr "неправилен формат за номериране на редове: %s"

#: src/nohup.c:50
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s КОМАНДА [АРГУМЕНТ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/nohup.c:56
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr ""
"Изпълнение на КОМАНДАта със заглушаване на сигналите за край на връзката "
"(SIGHUP).\n"
"\n"

#: src/nohup.c:62
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from an unreadable file.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"Ако стандартният вход е на терминал, той се пренасочва от нечетим файл.\n"
"Ако стандартният изход е на терминал, той се пренасочва и добавя по "
"възможност\n"
"към файла „nohup.out“.  Ако това е невъзможно, се ползва „$HOME/nohup.out“.\n"
"Ако стандартната грешка е на терминал, той се пренасочва към стандартния "
"изход.\n"
"За запазване на изхода в определен ФАЙЛ ползвайте „%s КОМАНДА > ФАЙЛ“.\n"

#: src/nohup.c:123
#, c-format
msgid "failed to render standard input unusable"
msgstr "неуспешно задаване на стандартния изход като неизползваем"

#: src/nohup.c:125
#, c-format
msgid "ignoring input"
msgstr "входът се пренебрегва"

#: src/nohup.c:169
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "входът се пренебрегва, а изходът се насочва към „%s“"

#: src/nohup.c:170
#, c-format
msgid "appending output to %s"
msgstr "добавяне на изхода към „%s“"

#: src/nohup.c:188
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr ""
"входът се пренебрегва, а стандартната грешка се пренасочва към стандартния "
"изход"

#: src/nohup.c:189
#, c-format
msgid "redirecting stderr to stdout"
msgstr "пренасочване на стандартната грешка към стандартния изход"

#: src/nohup.c:193
#, c-format
msgid "failed to redirect standard error"
msgstr "неуспешно пренасочване на стандартната грешка"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33 src/sync.c:34
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:121 src/whoami.c:44
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "Употреба: %s [ОПЦИЯ]…\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"Извеждане на броя процесорни ядра достъпни за текущия процес,\n"
"той може да е по-малък от общия брой работещи ядра.\n"
"\n"

#: src/nproc.c:63
msgid ""
"      --all      print the number of installed processors\n"
"      --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"      --all      извеждане на броя на наличните ядра\n"
"      --ignore=БРОЙ\n"
"                 по възможност този БРОЙ ядра се пренебрегват\n"

#: src/numfmt.c:694
#, c-format
msgid "value too large to be converted: %s"
msgstr "стойността е прекалено голяма за преобразуване: %s"

#: src/numfmt.c:698
#, c-format
msgid "invalid number: %s"
msgstr "грешно число: %s"

#: src/numfmt.c:702
#, c-format
msgid "rejecting suffix in input: %s (consider using --from)"
msgstr "отхвърлен суфикс на входа „%s“ (пробвайте с опцията „--from“)"

#: src/numfmt.c:706
#, c-format
msgid "invalid suffix in input: %s"
msgstr "неправилен суфикс на входа „%s“"

#: src/numfmt.c:710
#, c-format
msgid "missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)"
msgstr "суфиксът „i“ липсва на входа „%s“ (напр. „Ki“/„Mi“/„Gi“/…)"

#: src/numfmt.c:757 src/numfmt.c:809
#, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr "стойността „%Lf“ не може да се подготви за печат"

#: src/numfmt.c:858
#, c-format
msgid "invalid unit size: %s"
msgstr "неправилен размер на единица: „%s“"

#: src/numfmt.c:884
#, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ЧИСЛО]…\n"

#: src/numfmt.c:887
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""
"Наново форматиране на ЧИСЛата, а ако такива не са зададени, се четат от "
"стандартния вход.\n"

#: src/numfmt.c:891
msgid "      --debug          print warnings about invalid input\n"
msgstr ""
"      --debug          извеждане на предупреждения при грешни входни данни\n"

#: src/numfmt.c:894
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr ""
"  -d, --delimiter=ЗНАК използване на този ЗНАК за разделител вместо "
"интервал\n"

#: src/numfmt.c:897
msgid ""
"      --field=FIELDS   replace the numbers in these input fields "
"(default=1)\n"
"                         see FIELDS below\n"
msgstr ""
"      --field=ПОЛЀТА   замяна на числата в тези полета на входа (стандартно "
"1),\n"
"                       вж. ПОЛЀТА по-долу\n"

#: src/numfmt.c:901
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""
"      --format=ФОРМАТ  използване на стил на „printf“ за ФОРМА̀ТА с плаваща\n"
"                       запетая, вж. ФОРМАТ по-долу\n"

#: src/numfmt.c:905
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""
"      --from=ЕДИНИЦА   автоматично преобразуване на входната към тази "
"ЕДИНИЦА.\n"
"                       Стандартното е „none“ (без), вж. ЕДИНИЦИ по-долу\n"

#: src/numfmt.c:909
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr ""
"      --from-unit=РАЗМЕР\n"
"                       РАЗМЕР на входната единица (вместо стандартния 1)\n"

#: src/numfmt.c:912
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""
"      --grouping       използване на знак за разделяне на групите цифри "
"според\n"
"                       локала.  В българския локал такъв няма и както в "
"нулевия\n"
"                       локал (C/POSIX) опцията не прави нищо\n"

#: src/numfmt.c:916
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""
"      --header[=РЕДОВЕ]\n"
"                       извеждане без преобразуване на този брой първи "
"РЕДОВЕ\n"
"                       като заглавни.  Стандартният брой е 1.\n"

#: src/numfmt.c:920
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""
"      --invalid=РЕЖИМ  РЕЖИМ за реакция при сгрешени числа.  Може да е:\n"
"                       „abort“ (стандартно), „fail“, „warn“ или „ignore“\n"

#: src/numfmt.c:924
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""
"      --padding=БРОЙ_ЗНАЦИ\n"
"                       допълване на изхода до този БРОЙ_ЗНАЦИ.  Положителна\n"
"                       стойност е за допълване отляво, а отрицателна — "
"отдясно.\n"
"                       Допълване не се извършва, ако изходът е по-широк от\n"
"                       този БРОЙ_ЗНАЦИ.  Стандартно автоматично се прилага\n"
"                       допълване, ако в изхода присъства интервал.\n"

#: src/numfmt.c:931
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""
"      --round=МЕТОД    закръгляване по този МЕТОД при мащабирането:\n"
"                         ⁃ „up“: към по-голямото число;\n"
"                         ⁃ „down“: към по-малкото число;\n"
"                         ⁃ „from-zero“:  към по-близкото до 0 (стандартно);\n"
"                         ⁃ „towards-zero“: към по-далечното от 0;\n"
"                         ⁃ „nearest“: към най-близкото.\n"

#: src/numfmt.c:935
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""
"      --suffix=СУФИКС  добавяне на този СУФИКС към изходните числа и "
"приемане\n"
"                       на този незадължителен СУФИКС при входните числа\n"

#: src/numfmt.c:939
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""
"      --to=EДИНИЦА     автоматично преобразуване на изходните числа към "
"тази\n"
"                       ЕДИНИЦА.  Вж. ЕДИНИЦИ по-долу\n"

#: src/numfmt.c:942
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr ""
"      --to-unit=РАЗМЕР РАЗМЕР на изходната единица (вместо стандартната 1)\n"

#: src/numfmt.c:951
msgid ""
"\n"
"UNIT options:\n"
msgstr ""
"\n"
"Опции за ЕДИНИЦИ:\n"

#: src/numfmt.c:954
msgid "  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr ""
"  none       без автоматично преобразуване.  Наличието на суфикс да е "
"грешка\n"

#: src/numfmt.c:957
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""
"  auto       приемане на незадължителен суфикс от 1-2 знака:\n"
"               ⁃ 1K  ≡    1000;\n"
"               ⁃ 1Ki =    1024;\n"
"               ⁃ 1M  ≡ 1000000;\n"
"               ⁃ 1Mi ≡ 1048576;\n"
"               …\n"

#: src/numfmt.c:963
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""
"  si         приемане на незадължителен суфикс от 1 знак:\n"
"               ⁃ 1K  ≡    1000;\n"
"               ⁃ 1M  ≡ 1000000;\n"
"               …\n"

#: src/numfmt.c:968
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""
"  iec        приемане на незадължителен суфикс от 1 знак:\n"
"               ⁃ 1K  ≡    1024;\n"
"               ⁃ 1M  ≡ 1048576;\n"
"               …\n"

#: src/numfmt.c:973
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""
"  iec-i      приемане на незадължителен суфикс от 2 знака:\n"
"               ⁃ 1Ki =    1024;\n"
"               ⁃ 1Mi ≡ 1048576;\n"
"               …\n"

#: src/numfmt.c:979
msgid ""
"\n"
"FIELDS supports cut(1) style field ranges:\n"
"  N    N'th field, counted from 1\n"
"  N-   from N'th field, to end of line\n"
"  N-M  from N'th to M'th field (inclusive)\n"
"  -M   from first to M'th field (inclusive)\n"
"  -    all fields\n"
"Multiple fields/ranges can be separated with commas\n"
msgstr ""
"\n"
"ПОЛЕТАТА могат да бъдат указвани и в стила на „cut(1)“:\n"
"  ⁃ „N“    N-тото поле, като се брои от 1;\n"
"  ⁃ „N-“   от N-тото до последното, включително;\n"
"  ⁃ „N-M“  от N-тото до М-тото, включително;\n"
"  ⁃ „-M“   от 1-вото до М-тото, включително;\n"
"  ⁃ „-“    всички полета.\n"
"Може да задавате множество полета и диапазони като ги разделяте със „,“.\n"

#: src/numfmt.c:989
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional zero (%010f) width\n"
"will zero pad the number. Optional negative values (%-10f) will left align.\n"
"Optional precision (%.1f) will override the input determined precision.\n"
msgstr ""
"\n"
"ФОРМАТът трябва да е подходящ за извеждането на един аргумент с плаваща\n"
"запетая — „%f“.  Незадължителната единична кавичка („%'f“) включва опцията\n"
"„--grouping“, ако се поддържа от текущия локал.  Незадължителната широчина\n"
"(„%10f“) допълва числото отляво до нея.  Незадължителната широчина, "
"предшествана\n"
"от 0 („%010f“), допълва с 0 отляво.  Незадължителна отрицателна широчина\n"
"(„%-10f“) води до допълване отдясно.  Незадължителната точност („%.1f“) е с\n"
"превес над точността, определена на базата на входа.\n"

#: src/numfmt.c:997
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""
"\n"
"Изходният код е 0, ако всички числа на входа са преобразувани успешно.\n"
"Стандартно „%s“ спира при първата грешка, а кодът е 2 — това е същото като\n"
"„--invalid=abort“.  При „--invalid=fail“ обработката продължава, при\n"
"всяка грешка се извежда предупреждение, а изходният код е пак 2.  При\n"
"„--invalid=warn“ отново се обработва всичко и се извеждат предупреждения,\n"
"но изходният код е 0.  При „--invalid=ignore“ предупреждения няма и\n"
"изходният код е пак 0.\n"

#: src/numfmt.c:1006
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""
"\n"
"Примери:\n"
"  $ %s --to=si 1000\n"
"            → „1,0K“\n"
"  $ %s --to=iec 2048\n"
"           → „2,0K“\n"
"  $ %s --to=iec-i 4096\n"
"           → „4,0Ki“\n"
"  $ echo 1K | %s --from=si\n"
"           → „1000“\n"
"  $ echo 1K | %s --from=iec\n"
"           → „1024“\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"

#: src/numfmt.c:1059 src/seq.c:248
#, c-format
msgid "format %s has no %% directive"
msgstr "във форма̀та „%s“ липсва директива с „%%“"

#: src/numfmt.c:1086
#, c-format
msgid "invalid format %s (width overflow)"
msgstr "неправилен формат „%s“ (препълване на широчината)"

#: src/numfmt.c:1091
#, c-format
msgid "--format padding overriding --padding"
msgstr "допълването в опцията „--format“ е с превес над това в „--padding“"

#: src/numfmt.c:1110 src/seq.c:265
#, c-format
msgid "format %s ends in %%"
msgstr "форматът „%s“ завършва с „%%“"

#: src/numfmt.c:1126
#, c-format
msgid "invalid precision in format %s"
msgstr "неправилна точност във форма̀та „%s“"

#: src/numfmt.c:1132
#, c-format
msgid "invalid format %s, directive must be %%[0]['][-][N][.][N]f"
msgstr ""
"неправилен формат „%s“, директивата трябва да е във вид: „%%[0]['][-][N][.]"
"[N]f“"

#: src/numfmt.c:1140 src/seq.c:272
#, c-format
msgid "format %s has too many %% directives"
msgstr "форматът „%s“ съдържа прекалено много директиви с „%%“"

#: src/numfmt.c:1183
#, c-format
msgid "invalid suffix in input %s: %s"
msgstr "неправилен суфикс на входа „%s“: %s"

#: src/numfmt.c:1212
#, c-format
msgid ""
"value/precision too large to be printed: '%Lg/%<PRIuMAX>' (consider using --"
"to)"
msgstr ""
"прекалено голяма стойност/точност за извеждане „%Lg/%<PRIuMAX>“ (пробвайте "
"да използвате опцията „--to“)<"

#: src/numfmt.c:1216
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr ""
"прекалено голяма стойност за извеждане „%Lg“ (пробвайте да използвате "
"опцията „--to“)"

#: src/numfmt.c:1225
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr ""
"прекалено голяма стойност за извеждане „%Lg“ (стойности > 999Y [йота] не се "
"поддържат)"

#: src/numfmt.c:1311
#, c-format
msgid "large input value %s: possible precision loss"
msgstr "прекалено голяма стойност на входа „%s“: възможна загуба на точност"

#: src/numfmt.c:1500
#, c-format
msgid "invalid padding value %s"
msgstr "неправилна стойност за допълването „%s“"

#: src/numfmt.c:1513
msgid "multiple field specifications"
msgstr "множество указатели на полета"

#: src/numfmt.c:1547
#, c-format
msgid "invalid header value %s"
msgstr "неправилна стойност на заглавието „%s“"

#: src/numfmt.c:1574
msgid "--grouping cannot be combined with --format"
msgstr "опциите „--grouping“ и „--format“ са несъвместими"

#: src/numfmt.c:1577 src/sort.c:4686
#, c-format
msgid "failed to set locale"
msgstr "неуспешно задаване на локала"

#: src/numfmt.c:1582
#, c-format
msgid "no conversion option specified"
msgstr "липсва опция за преобразуването"

#: src/numfmt.c:1590
msgid "grouping cannot be combined with --to"
msgstr "групирането е несъвместимо с опцията „--to“"

#: src/numfmt.c:1592
#, c-format
msgid "grouping has no effect in this locale"
msgstr "в този локал няма групиране"

#: src/numfmt.c:1605
#, c-format
msgid "--header ignored with command-line input"
msgstr "опцията „--header“ се прескача при вход от командния ред"

#: src/numfmt.c:1632
#, c-format
msgid "error reading input"
msgstr "грешка при прочитане на входа"

#: src/numfmt.c:1643
#, c-format
msgid "failed to convert some of the input numbers"
msgstr "неуспешно преобразуване на някои от входните числа"

#: src/od.c:323
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]…\n"
"     или: %s [-abcdfilosx]… [ФАЙЛ] [[+]ОТМЕСТВАНЕ[.][b]]\n"
"     или: %s --traditional [ОПЦИЯ]… [ФАЙЛ] [[+]ОТМЕСТВАНЕ[.][b] [+][ЕТИКЕТ]"
"[.][b]]\n"

#: src/od.c:329
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
msgstr ""
"\n"
"Извеждане на еднозначно представяне (стандартно — осмични байтове) на ФАЙЛа "
"на\n"
"стандартния изход.  Ако са посочени повече от един ФАЙЛ, те се прилепят и\n"
"извеждат в посочения ред.\n"

#: src/od.c:337
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"Ако и двата форма̀та са приложими, се приема вторият, ако последният операнд\n"
"започва с „+“ или (ако има два операнда) число.  Операнд ОТМЕСТВАНЕ "
"означава:\n"
"„-j ОТМЕСТВАНЕ“.  ЕТИКЕТът е псевдоадресът на първия изведен байт и се\n"
"увеличава постепенно заедно с обработката.  В ОТМЕСТВАНЕто и ЕТИКЕТа може да "
"се\n"
"ползват префикси: „0x“ или „0X“ за шестнадесетично число, и суфикси: „.“ за\n"
"осмично число и „b“ за множител 512.\n"

#: src/od.c:349
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"      --endian={big|little}   swap input bytes according the specified "
"order\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=ОСНОВА  формат на отместването във файла.  ОСНОВАта "
"може\n"
"                              да е „d“ (десетична), „o“ (осмична), „x“\n"
"                              (шестнадесетична) или „n“ (без отмествания)\n"
"      --endian={big|little}   размяна на входните байтове според указания "
"ред\n"
"  -j, --skip-bytes=БРОЙ       пропускане на този БРОЙ байтове от входа\n"

#: src/od.c:355
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars;\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""
"  -N, --read-bytes=БРОЙ       извеждане на максимално този БРОЙ входни "
"байтове\n"
"  -S БРОЙ, --strings[=БРОЙ]   извеждане на низове с поне този БРОЙ графични\n"
"                              знаци.  Ако не е указан, стандартният БРОЙ е "
"3\n"
"  -t, --format=ФОРМАТ         указване на ФОРМА̀Та/тите за извеждане\n"
"  -v, --output-duplicates     без „*“ за отбелязване на еднакви редове\n"
"  -w[БРОЙ], --width[=БРОЙ]    извеждане по този БРОЙ входни байтове на ред.\n"
"                              Ако не е указан, стандартният БРОЙ е 32.\n"
"      --traditional           да се приемат аргументи в традиционния формат\n"

#: src/od.c:368
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select printable characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"Спецификациите в традиционен формат може да се комбинират:\n"
"  -a   ≡„-t a“  — извеждат се именувани знаци, старшият бит се пренебрегва\n"
"  -b   ≡„-t o1“ — извеждат се осмични байтове\n"
"  -c   ≡„-t c“  — извеждат се печатими знаци или екранирания с „\\“\n"
"  -d   ≡„-t u2“ — извеждат се беззнакови двубайтови десетични числа\n"

#: src/od.c:377
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f   ≡„-t fF“ — извеждат се числа с плаваща запетая\n"
"  -i   ≡„-t dI“ — извеждат се десетични цели числа\n"
"  -l   ≡„-t dL“ — извеждат се десетични дълги числа\n"
"  -o   ≡„-t o2“ — извеждат се двубайтови осмични числа\n"
"  -s   ≡„-t d2“ — извеждат се двубайтови десетични числа\n"
"  -x   ≡„-t x2“ — извеждат се двубайтови шестнадесетични числа\n"

#: src/od.c:385
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          printable character or backslash escape\n"
msgstr ""
"\n"
"\n"
"ВИДът може да съдържа една или повече от следните спецификации:\n"
"  a          именувани знаци, старшият бит се пренебрегва\n"
"  c          печатими знаци или екранирания с „\\“\n"

#: src/od.c:392
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per float\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[РАЗМЕР]  десетично число със знак с този РАЗМЕР в байтове\n"
"  f[РАЗМЕР]  число с плаваща запетая с този РАЗМЕР в байтове\n"
"  o[РАЗМЕР]  знаково осмично число с този РАЗМЕР в байтове\n"
"  u[РАЗМЕР]  беззнаково десетично число с този РАЗМЕР в байтове\n"
"  x[РАЗМЕР]  шестнадесетично число с този РАЗМЕР в байтове\n"

#: src/od.c:399
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"РАЗМЕРът е число.  Ако ВИДът е измежду „doux“, РАЗМЕРът може да е и „C“ за\n"
"„sizeof(char)“, „S“ за „sizeof(short)“, „I“ за s„izeof(int)“ или „L“ за\n"
"„sizeof(long)“.  Ако ВИДът е „f“, РАЗМЕРът може да е и „F“ за "
"„sizeof(float)“,\n"
"„D“ за „sizeof(double)“ или „L“ за „sizeof(long double)“.\n"

#: src/od.c:406
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""
"\n"
"\n"
"При добавянето на суфикс „z“ към вида печатимите знаци се извеждат в края "
"на\n"
"всеки ред.\n"

#: src/od.c:411
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"\n"
"РАЗМЕРът е шестнадесетично цяло число, когато е ползван префикс „0x“ или "
"„0X“.\n"
"Може да се ползва някой и суфикс-множител:\n"
"b≡512, KB≡1000, K≡1024, MB≡1000×1000, M≡1024×1024 и т.н. за „G“, „T“, „P“, "
"„E“,\n"
"„Z“ и „Y“.  Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"

#: src/od.c:685 src/od.c:805
#, c-format
msgid "invalid type string %s"
msgstr "неправилен низ за вида: %s"

#: src/od.c:695
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"неправилен низ за вид %s.\n"
"Тази система не поддържа %lu-байтови целочислени числа"

#: src/od.c:816
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"неправилен низ за вид %s.\n"
"Тази система не поддържа %lu-байтови числа с плаваща запетая"

#: src/od.c:874
#, c-format
msgid "invalid character '%c' in type string %s"
msgstr "неправилен знак „%c“ в низа за вида: „%s“"

#: src/od.c:1110
msgid "cannot skip past end of combined input"
msgstr "не може да се пропусне след края на комбинирания вход"

#: src/od.c:1660
#, c-format
msgid "invalid output address radix '%c'; it must be one character from [doxn]"
msgstr ""
"неправилна основа „%c“ за изхода, тя трябва да бъде знак измежду „doxn“"

#: src/od.c:1798
msgid "no type may be specified when dumping strings"
msgstr "при извеждане на низове не може да се посочва вид"

#: src/od.c:1873
msgid "compatibility mode supports at most one file"
msgstr "в традиционната употреба се поддържа най-много един файл"

#: src/od.c:1894
msgid "skip-bytes + read-bytes is too large"
msgstr "skip-bytes + read-bytes са твърде много"

#: src/od.c:1937
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "ПРЕДУПРЕЖДЕНИЕ: неправилна ширина %lu.  Вместо нея се ползва %d"

#: src/paste.c:222
msgid "standard input is closed"
msgstr "стандартният вход е затворен"

#: src/paste.c:440
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
msgstr ""
"Извеждане на стандартния изход на редове, състоящи се от поредно\n"
"съответстващи си редове от всеки ФАЙЛ, разделени с табулации.\n"

#: src/paste.c:448
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=СПИСЪК разделяне със знаците от този СПИСък, а не с "
"табулации\n"
"  -s, --serial            последователно, а не паралелно, извеждане на "
"файловете\n"

#: src/paste.c:518
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "списъкът с разделители завършва с неекранирана „\\“: %s"

#: src/pathchk.c:89
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"Определяне платформенозависимите конструкции.\n"
"\n"
"  -p                  проверка за повечето POSIX-съвместими системи\n"
"  -P                  проверка за празни имена и начални „-“\n"
"      --portability   проверка за всички POSIX-съвместими системи (като „-p -"
"P“)\n"

#: src/pathchk.c:169
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr "начален „-“ в компонент на името на файл „%s“"

#: src/pathchk.c:195
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "платформенозависим знак „%s“ в името на файл „%s“"

#: src/pathchk.c:271
#, c-format
msgid "empty file name"
msgstr "празно файлово име"

#: src/pathchk.c:313
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s: максималната дължина за име на файл не може да се определи"

#: src/pathchk.c:324
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "ограничението %lu е нарушено от дължината %lu на името на файл „%s“"

#: src/pathchk.c:410
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr ""
"ограничението %lu е нарушено от дължината %lu на компонента на името на файл "
"„%s“"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:37 src/uptime.c:45 src/users.c:35 src/who.c:50
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:39 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:241
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:265
msgid "?????"
msgstr "?????"

#: src/pinky.c:313
#, c-format
msgid "Login name: "
msgstr "Входящо име: "

#: src/pinky.c:316
#, c-format
msgid "In real life: "
msgstr "В реалния живот: "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:320
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:340
#, c-format
msgid "Directory: "
msgstr "Директория: "

#: src/pinky.c:342
#, c-format
msgid "Shell: "
msgstr "Обвивка: "

#: src/pinky.c:361
#, c-format
msgid "Project: "
msgstr "Проект: "

#: src/pinky.c:385
#, c-format
msgid "Plan:\n"
msgstr "План:\n"

#: src/pinky.c:404
msgid "Login"
msgstr "Вход "

#: src/pinky.c:406
msgid "Name"
msgstr "Име "

#: src/pinky.c:407
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:409
msgid "Idle"
msgstr "Неактивен"

#: src/pinky.c:410
msgid "When"
msgstr "Кога"

#: src/pinky.c:413
msgid "Where"
msgstr "Къде"

#: src/pinky.c:490
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              извеждане на посочените ПОТРЕБИТЕЛи в подробен формат\n"
"  -b              без потребителската директория в подробния формат\n"
"  -h              без потребителския файл-проект в подробния формат\n"
"  -p              без потребителския файл-план в подробния формат\n"
"  -s              извеждане в кратък формат (стандартно)\n"

#: src/pinky.c:498
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              без заглавие в съкратен формат\n"
"  -w              без пълните имена в съкратен формат\n"
"  -i              без пълните имена и отдалечените хостове в съкратен "
"формат\n"
"  -q              без пълните имена, отдалечените хостове и\n"
"                  време на неактивност в съкратен формат\n"

#: src/pinky.c:507
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"Олекотена програма „finger“ — извеждане на информация за потребител.\n"
"Файлът „utmp“ ще бъде „%s“.\n"

#: src/pinky.c:591
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr "при използване на -l трябва да се посочи поне едно потребителско име"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:332
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:333
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:778
msgid "integer overflow"
msgstr "препълване на цяло число"

#: src/pr.c:917
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "липсва аргумент към „--pages=ПЪРВА_СТРАНИЦА[:ПОСЛЕДНА_СТРАНИЦА]“"

#: src/pr.c:919
#, c-format
msgid "invalid page range %s"
msgstr "неправилен диапазон страници: „%s“"

#: src/pr.c:979
msgid "'-l PAGE_LENGTH' invalid number of lines"
msgstr "„-l РЕДОВЕ“: неправилен брой РЕДОВЕ на страница"

#: src/pr.c:994
msgid "'-N NUMBER' invalid starting line number"
msgstr "„-N НОМЕР“: неправилен начален НОМЕР на страница"

#: src/pr.c:998
msgid "'-o MARGIN' invalid line offset"
msgstr "„-o ИНТЕРВАЛИ“: неправилен брой ИНТЕРВАЛИ за отместване на ред"

#: src/pr.c:1035
msgid "'-w PAGE_WIDTH' invalid number of characters"
msgstr "„-w ШИРОЧИНА“: неправилен брой знаци за ШИРОЧИНАта"

#: src/pr.c:1044
msgid "'-W PAGE_WIDTH' invalid number of characters"
msgstr "„-W ШИРОЧИНА“: неправилен брой знаци за ШИРОЧИНАта"

#: src/pr.c:1073
msgid "cannot specify number of columns when printing in parallel"
msgstr "не може да указвате брой колони при паралелен печат"

#: src/pr.c:1077
msgid "cannot specify both printing across and printing in parallel"
msgstr "не може да укажете едновременно успореден печат и печат напреки"

#: src/pr.c:1180
#, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr "„-%c“: излишни знаци или неправилно число в аргумента „%s“"

#: src/pr.c:1282
msgid "page width too narrow"
msgstr "ширината на страницата е твърде малка"

#: src/pr.c:2338
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr ""
"началният номер на страница %<PRIuMAX> надминава броя страници %<PRIuMAX>"

#: src/pr.c:2365
msgid "page number overflow"
msgstr "препълване на номера на страница"

#: src/pr.c:2370
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "Стр. %<PRIuMAX>"

#: src/pr.c:2742
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr "Форматиране на ФАЙЛовете за печат по страници и стълбове.\n"

#: src/pr.c:2749
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +ПЪРВА_СТРАНИЦА[:ПОСЛЕДНА_СТРАНИЦА]/--pages=ПЪРВА_СТРАНИЦА[:"
"ПОСЛЕДНА_СТРАНИЦА]\n"
"                    начало на печатането от ПЪРВАта_СТРАНИЦА и завършване с\n"
"                    посочената ПОСЛЕДНА_СТРАНИЦА\n"
"  -КОЛОНИ, --columns=КОЛОНИ\n"
"                    извеждане този брой КОЛОНИ и отпечатване надолу, стига "
"да\n"
"                    не е зададена опцията „-a“.  Разликата в броя на "
"редовете в\n"
"                    колоните на всяка страница е възможно най-малка\n"

#: src/pr.c:2757
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across      печатане на стълбовете напреки вместо надолу, използва "
"се\n"
"                    заедно с „-КОЛОНИ“\n"
"  -c, --show-control-chars\n"
"                    запис със шапки (^G) и осмични числа с „\\“\n"
"  -d, --double-space\n"
"                    разреждане на изхода с добавяне на празен ред след всеки "
"ред\n"

#: src/pr.c:2765
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=ФОРМАТ\n"
"                    да се ползва ФОРМАТ при датата на колонтитула\n"
"  -e[ЗНАК[ШИРОЧИНА]], --expand-tabs[=ЗНАК[ШИРОЧИНА]]\n"
"                    повтаряне на всеки такъв входен ЗНАК толкова пъти, за\n"
"                    имитиране на табулация с такава ШИРОЧИНА (стандартно 8)\n"
"  -F, -f, --form-feed\n"
"                    разделяне на страниците с form feed вместо с нови "
"редове\n"
"                    (с „-F“ има 3-редов горен колонтитул, а без — 5-редови\n"
"                    горен и долен колонтитули)\n"

#: src/pr.c:2775
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h ГОРЕН_КОЛОНТИТУЛ, --header=ГОРЕН_КОЛОНТИТУЛ\n"
"                    ползване на този ГОРЕН_КОЛОНТИТУЛ, центриран по реда,\n"
"                    вместо името на файла.  За празен ред ползвайте „-h "
"\"\"“,\n"
"                    а не „-h\"\"“\n"
"  -i[БРОЙ[ШИРОЧИНА]], --output-tabs[=БРОЙ[ШИРОЧИНА]]\n"
"                    замяна на всеки такъв БРОЙ интервали с табулации с тази\n"
"                    ШИРОЧИНА (стандартно 8)\n"
"  -J, --join-lines  сливане на пълните редове, отменя съкращаването на "
"редове с\n"
"                    „-W“, без подравняване на колоните, „--sep-"
"string[=НИЗ]“\n"
"                    указва разделителите\n"

#: src/pr.c:2784
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63).\n"
"                    implies -t if PAGE_LENGTH <= 10\n"
msgstr ""
"  -l РЕДОВЕ, --length=РЕДОВЕ\n"
"                    задаване на дължината на страниците в РЕДОВЕ (66).\n"
"                    (стандартно броят редове на текста е 56, а с „-F“ е "
"63).\n"
"                    Включва „-t“, ако РЕДОВЕте ≤ 10\n"

#: src/pr.c:2790
msgid ""
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -m, --merge       паралелно извеждане на всички файлове, по един в "
"колона.\n"
"                    Редовете стандартно се отсичат при необходимост, а с\n"
"                    опцията „-J“ пълните редове се сливат\n"

#: src/pr.c:2794
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[РАЗДЕЛИТЕЛ[БРОЙ_ЦИФРИ]], --number-lines[=РАЗДЕЛИТЕЛ[БРОЙ_ЦИФРИ]]\n"
"                    номериране на редовете, номерата са с широчина от този\n"
"                    БРОЙ_ЦИФРИ (стандартно 5), следване с този РАЗДЕЛИТЕЛ\n"
"                    (стандартно табулации).  Номерацията стандартно почва от "
"1\n"
"  -N НОМЕР, --first-line-number=НОМЕР\n"
"                    при номериране на редовете първият ред от първата "
"страница\n"
"                    е с този НОМЕР (вж. +ПЪРВА_СТРАНИЦА)\n"

#: src/pr.c:2802
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o ИНТЕРВАЛИ, --indent=ИНТЕРВАЛИ\n"
"                    отместване на всеки ред с този брой ИНТЕРВАЛИ "
"(стандартно\n"
"                    0).  Не влияе на „-w“ и „-W“, ИНТЕРВАЛИте се добавят "
"към\n"
"                    ШИРОЧИНАта\n"
"  -r, --no-file-warnings\n"
"                    без предупреждаване, ако файлът не може да бъде отворен\n"

#: src/pr.c:2809
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -"
"w.\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[ЗНАК],--separator[=ЗНАК]\n"
"                    разделяне на колоните с този знак — без „-w“ стандартно "
"e\n"
"                    табулация, а с „-w“ няма разделител.  „-s“ отменя "
"отсичането\n"
"                    на редовете при всички опции за колоните — „-СТЪЛБОВЕ“/\n"
"                    „-a -СТЪЛБОВЕ“/„-m“, освен ако е зададена и опцията „-"
"w“\n"

#: src/pr.c:2817
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
msgstr ""
"  -S[НИЗ], --sep-string[=НИЗ]\n"
"                    разделяне на колоните с този НИЗ.  Без „-S“ "
"стандартният\n"
"                    разделител е табулация, включва се и „-J“.  Иначе е "
"интервал\n"
"                    (същото като „-S\" \"“), не влияе на опциите за "
"колоните\n"

#: src/pr.c:2823
msgid ""
"  -t, --omit-header  omit page headers and trailers;\n"
"                     implied if PAGE_LENGTH <= 10\n"
msgstr ""
"  -t, --omit-header  без горни и долни колонтитули.  Автоматично се\n"
"                     включва, когато РЕДОВЕте ≤ 10\n"

#: src/pr.c:2827
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    без горни, долни колонтитули и управляващи знаци за "
"нова\n"
"                    страница — form feed от входните файлове.\n"
"  -v, --show-nonprinting\n"
"                    ползване на осмични числа с „\\“\n"
"  -w ШИРОЧИНА, --width=ШИРОЧИНА\n"
"                    задаване на ШИРОЧИНА на страницата в знаци (стандартно "
"72)\n"
"                    при многоколонен извод, „-s[знак]“ отменя ШИРОЧИНАта\n"

#: src/pr.c:2837
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W ШИРОЧИНА, --page-width=ШИРОЧИНА\n"
"                    налагане на ШИРОЧИНА на страницата в знаци (стандартно "
"72),\n"
"                    отсичане на редовете (освен със „-J“), не се влияе от\n"
"                    „-S“ и „-s“\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ПРОМЕНЛИВА]…\n"
"Извеждане на стойностите на указаните ПРОМЕНЛИВи на средата\n"
"Ако не е посочена ПРОМЕНЛИВА от обкръжението, се извеждат имената\n"
"и стойностите на всички.\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with NUL, not newline\n"
msgstr "  -0, --null     завършване на редовете с нулев байт, а не нов ред\n"

#: src/printf.c:84
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: %s: знаците, следващи знакова константа, са пренебрегнати"

#: src/printf.c:93
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ФОРМАТ [АРГУМЕНТ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/printf.c:98
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"Извеждане на АРГУМЕНТите според ФОРМА̀Та или според ОПЦИите:\n"
"\n"

#: src/printf.c:104
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"ФОРМАТът управлява изхода както при командата printf на C. Разпознават се:\n"
"\n"
"  \\\"      двойни прави кавички\n"

#: src/printf.c:122
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN    байт с осмичен код NNN (1/2/3 цифри)\n"
"  \\xHH    байт с шестнадесетичен код HH (от 1/2 цифри)\n"
"  \\uHHHH  знак от Unicode (ISO/IEC 10646) с 16-ичен код HHHH (4 цифри)\n"
"  \\UHHHHHHHH\n"
"          знак от Unicode със шестнадесетичен код HHHHHHHH (8 цифри)\n"

#: src/printf.c:128
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"  %q      ARGUMENT is printed in a format that can be reused as shell "
"input,\n"
"          escaping non-printable characters with the proposed POSIX $'' "
"syntax.\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%      знак процент\n"
"  %b      АРГУМЕНТ, в който се обработват обратните наклонени черти „\\“,\n"
"          но осмичните числа имат вида \\0 или \\0NNN\n"
"  %q      АРГУМЕНТът се извежда в предложения към POSIX формат — „$''“,\n"
"          непечатимите знаци се екранират\n"
"\n"
"и всички форматни спецификации на C, завършващи с някой от знаците:\n"
"„diouxXfeEgGcs“.  АРГУМЕНТите се преобразуват в нужния тип.  Поддържат се\n"
"променливи ширини.\n"

#: src/printf.c:155
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: очаква се числова стойност"

#: src/printf.c:157
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: стойността не е напълно преобразувана"

#: src/printf.c:254 src/printf.c:281
msgid "missing hexadecimal number in escape"
msgstr "липсва шестнадесетично число след „\\“"

#: src/printf.c:293
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "неправилно универсално име на знак: „\\%c%0*x“"

#: src/printf.c:566
#, c-format
msgid "invalid field width: %s"
msgstr "неправилна ширина на поле: %s"

#: src/printf.c:601
#, c-format
msgid "invalid precision: %s"
msgstr "неправилна точност: %s"

#: src/printf.c:628
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s: неправилна спецификация на преобразуване"

#: src/printf.c:711
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "ПРЕДУПРЕЖДЕНИЕ: започвайки от „%s“ излишните аргументи се пренебрегват"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:42
msgid "F. Pinard"
msgstr "François Pinard"

#: src/ptx.c:424
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (за рег. израз „%s“)"

#: src/ptx.c:823
#, c-format
msgid "error: regular expression has a match of length zero: %s"
msgstr "грешка: регулярният израз напасва и с празен низ: „%s“"

#: src/ptx.c:1814
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ВХОД]…   (без -G)\n"
"     или: %s -G [ОПЦИЯ]… [ВХОД [ИЗХОД]]\n"

#: src/ptx.c:1818
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr ""
"Извеждане на азбучен показалец на думите и контекста им във входните "
"файлове\n"
"\n"

#: src/ptx.c:1825
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
msgstr ""
"  -A, --auto-reference           извеждане на автоматично генерираните "
"препратки\n"
"  -G, --traditional              работа като командата „ptx“ от System V\n"

#: src/ptx.c:1829
msgid ""
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
"                                 The default is '/'\n"
msgstr ""
"  -F, --flag-truncation=НИЗ      отбелязване на съкращаването на ред с този "
"НИЗ.\n"
"                                 Стандартно е „/“\n"

#: src/ptx.c:1833
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=ИМЕ           име на макрос вместо „xx“\n"
"  -O, --format=roff              изход с команди за „roff“\n"
"  -R, --right-side-refs          препратките да са отдясно, не се броят при "
"„-w“\n"
"  -S, --sentence-regexp=РЕГ_ИЗР  РЕГулярен_ИЗРаз за край на редовете или "
"край\n"
"                                 на изреченията\n"
"  -T, --format=tex               изход с команди за „TeX“\n"

#: src/ptx.c:1840
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=РЕГ_ИЗР      РЕГулярен_ИЗРаз, който определя какво е "
"дума\n"
"  -b, --break-file=ФАЙЛ          думите свършват при знак от този ФАЙЛа\n"
"  -f, --ignore-case              подредба без разлика главните и малките "
"букви\n"
"  -g, --gap-size=РАЗМЕР          РАЗМЕР на мястото между полетата в изхода\n"
"  -i, --ignore-file=ФАЙЛ         ФАЙЛ с думи, които да се пренебрегват\n"
"  -o, --only-file=ФАЙЛ           признават се само думи от този ФАЙЛ\n"

#: src/ptx.c:1848
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               първото поле на всеки ред е препратка\n"
"  -t, --typeset-mode               • опцията не е реализирана •\n"
"  -w, --width=БРОЙ               ширина на изхода, препратките не се броят\n"

#: src/ptx.c:1945
#, c-format
msgid "invalid gap width: %s"
msgstr "неправилна ширина на мястото между полетата: %s"

#: src/ptx.c:1972
#, c-format
msgid "invalid line width: %s"
msgstr "неправилна дължина на реда: %s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"Извеждане на пълното файлово име на текущата работна директория.\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical   използване на стойността на променливата на средата "
"„PWD“,\n"
"                  дори тя да съдържа символни връзки\n"
"  -P, --physical  избягване на всички символни връзки\n"

#: src/pwd.c:68
msgid ""
"\n"
"If no option is specified, -P is assumed.\n"
msgstr ""
"\n"
"Ако не е зададена никоя опция, се подразбира „-P“.\n"

#: src/pwd.c:169
#, c-format
msgid "failed to chdir to %s"
msgstr "директорията „%s“ не може да се отвори"

#: src/pwd.c:173 src/pwd.c:280 src/split.c:469
#, c-format
msgid "failed to stat %s"
msgstr "не може да се изпълни „stat“ върху „%s“"

#: src/pwd.c:238
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "не може да се намери какво съответства на i-възел в директорията „%s“"

#: src/pwd.c:367
#, c-format
msgid "ignoring non-option arguments"
msgstr "аргументите, които не са опции, се пренебрегват"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/shred.c:170 src/stat.c:1691
#: src/touch.c:213
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ…\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"Извеждане на стойността на символна връзка или канонично име на файл\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize            привеждане в канонична форма чрез "
"рекурсивно\n"
"                                проследяване на всяка символна връзка във "
"всеки\n"
"                                компонент на даденото име.  Всички освен\n"
"                                последният компонент трябва да съществуват\n"
"  -e, --canonicalize-existing   привеждане в канонична форма чрез "
"рекурсивно\n"
"                                проследяване на всяка символна връзка във "
"всеки\n"
"                                компонент на даденото име.  Всички "
"компоненти\n"
"                                трябва да съществуват\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet\n"
"  -s, --silent                  suppress most error messages (on by "
"default)\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    end each output line with NUL, not newline\n"
msgstr ""
"  -e, --canonicalize-existing   привеждане в канонична форма чрез "
"рекурсивно\n"
"  -m, --canonicalize-missing    проследяване на всяка символна връзка във "
"всеки\n"
"                                компонент на даденото име.  Без изискване "
"за\n"
"                                съществуване на компонентите\n"
"  -n, --no-newline              без извеждане на крайните разделители\n"
"  -q, --quiet                   без повечето съобщения за грешка\n"
"  -s, --silent                  без повечето съобщения за грешка\n"
"  -v, --verbose                 със съобщенията за грешки\n"
"  -z, --zero                    разделяне на редовете с нулев байт, а не нов "
"ред\n"

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr "опцията „--no-newline“ с множество аргументи се прескача"

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""
"Извеждане на абсолютното име на файл, което е определено,\n"
"но последният компонент трябва да съществува\n"

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no path components need exist or be a "
"directory\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=DIR        print the resolved path relative to DIR\n"
"      --relative-base=DIR      print absolute paths unless paths below DIR\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   end each output line with NUL, not newline\n"
"\n"
msgstr ""
"  -e, --canonicalize-existing  всички компоненти на пътя трябва да "
"съществуват\n"
"  -m, --canonicalize-missing   без проверка дали всички елементи на пътя са\n"
"                               съществуващи директории\n"
"  -L, --logical                определяне на „..“ преди символните връзки\n"
"  -P, --physical               определяне на символните връзки по ред на "
"поява\n"
"                               (стандартно)\n"
"  -q, --quiet                  без повечето съобщения за грешки\n"
"      --relative-to=ДИРЕКТОРИЯ извеждане на определения път като "
"относителен\n"
"                               спрямо тази ДИРЕКТОРИЯ\n"
"      --relative-base=ДИРЕКТОРИЯ\n"
"                               извеждане на абсолютни пътища освен, ако не "
"са\n"
"                               в тази ДИРЕКТОРИЯ\n"
"  -s, --strip, --no-symlinks   без заместване на символните връзки\n"
"  -z, --zero                   завършване на редовете с нулев байт, а не нов "
"ред\n"
"\n"

#: src/relpath.c:130
msgid "generating relative path"
msgstr "генериране на относителен път"

#: src/remove.c:273
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: да се влезе ли в директорията без права за запис „%s“? "

#: src/remove.c:274
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: да се влезе ли в директорията „%s“? "

#. TRANSLATORS: In the next two strings the second %s is
#. replaced by the type of the file.  To avoid grammatical
#. problems, it may be more convenient to translate these
#. strings instead as: "%1$s: %3$s is write-protected and
#. is of type '%2$s' -- remove it? ".
#: src/remove.c:291
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: да се изтрие ли %s със защита срещу запис „%s“? "

#: src/remove.c:292
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: да се изтрие ли %s „%s“? "

#: src/remove.c:375
#, c-format
msgid "removed directory %s\n"
msgstr "директорията „%s“ бе изтрита\n"

#: src/remove.c:447
#, c-format
msgid "refusing to remove %s or %s directory: skipping %s"
msgstr ""
"отказ за изтриването на директория с име „%s“ или „%s“: „%s“ се пропуска"

#: src/remove.c:476
#, c-format
msgid "failed to stat %s: skipping %s"
msgstr ""
"неуспешно получаване на информация със „stat“ за „%s“: „%s“ се пропуска"

#: src/remove.c:489 src/remove.c:539
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "„%s“ се пропуска, понеже е на друго устройство"

#: src/remove.c:491
#, c-format
msgid "and --preserve-root=all is in effect"
msgstr "Също така е зададена и опцията „--preserve-root=all“"

#: src/remove.c:559
#, c-format
msgid "traversal failed: %s"
msgstr "неуспешно обхождане: %s"

#: src/remove.c:565
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"неочаквана грешка: „fts_info=%d: %s“\n"
"Молим да я докладвате на „%s“"

#: src/rm.c:117
#, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr "Пробвайте с „%s ./%s“ да изтриете файла „%s“.\n"

#: src/rm.c:134
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"Изтриване на ФАЙЛовете с „unlink“.\n"
"\n"
"  -f, --force           прескачане на несъществуващите файлове и без питане\n"
"  -i                    питане преди всяко триене\n"

#: src/rm.c:140
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively; less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i); without WHEN, prompt always\n"
msgstr ""
"  -I                    еднократно питане преди изтриването на повече от 3 "
"файла\n"
"                        или при рекурсивно триене.  По-малко досадно от „-i“ "
"и\n"
"                        все пак защитава срещу повечето грешки\n"
"      --interactive[=КОГА]\n"
"                        КОГА да се пита при триене: „never“ (никога),\n"
"                        „once“≡„-I“ (веднъж) или „always“≡„-i“ (винаги).\n"
"                        Ако не е дадено КОГА, се пита винаги\n"

#: src/rm.c:147
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system  при рекурсивно изтриване на файлове се прескачат\n"
"                         директориите, които са на файлова система, различна "
"от\n"
"                         тази на съответния аргумент на командния ред\n"

#: src/rm.c:152
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root[=all]  do not remove '/' (default);\n"
"                              with 'all', reject any command line argument\n"
"                              on a separate device from its parent\n"
msgstr ""
"      --no-preserve-root\n"
"                        без специално третиране на „/“\n"
"      --preserve-root[-all]\n"
"                        без рекурсивно триене от „/“ (стандартно)\n"
"  -r, -R, --recursive   рекурсивно изтриване на директориите и съдържанието "
"им\n"
"  -v, --verbose         съобщаване на действията\n"

#: src/rm.c:158
msgid ""
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"  -r, -R, --recursive   рекурсивно изтриване на директориите и съдържанието "
"им\n"
"  -d, --dir             изтриване на празните директории\n"
"  -v, --verbose         съобщаване на действията\n"

#: src/rm.c:165
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"Стандартно „rm“ не трие директории.  За целта ползвайте опцията „--"
"recursive“\n"
"или „-r“, или„-R“, при които всяка изброена директория се трие, заедно със\n"
"съдържанието ѝ\n"

#: src/rm.c:170
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"За да се изтрие файл, чието име започва с „-“ (напр. „-трънки“),\n"
"използвайте някой от вариантити:\n"
"  %s -- -трънки\n"
"\n"
"  %s ./-трънки\n"

#: src/rm.c:179
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using shred.\n"
msgstr ""
"\n"
"Дори да изтриете файл с „rm“, често е възможно съдържанието му да бъде\n"
"възстановено сравнително лесно.  За да затрудните това, пробвайте командата\n"
"„shred“.\n"

#: src/rm.c:297
msgid "you may not abbreviate the --no-preserve-root option"
msgstr "опцията „--no-preserve-root“ не може да се съкращава"

#: src/rm.c:309
#, c-format
msgid "unrecognized --preserve-root argument: %s"
msgstr "непознат аргумент за опцията „--preserve-root“: %s"

#: src/rm.c:359
#, c-format
msgid "%s: remove %<PRIuMAX> argument recursively? "
msgid_plural "%s: remove %<PRIuMAX> arguments recursively? "
msgstr[0] "%s: да се изтрие ли %<PRIuMAX> аргумент рекурсивно?"
msgstr[1] "%s: да се изтрият ли %<PRIuMAX> аргумента рекурсивно?"

#: src/rm.c:362
#, c-format
msgid "%s: remove %<PRIuMAX> argument? "
msgid_plural "%s: remove %<PRIuMAX> arguments? "
msgstr[0] "%s: да се изтрие ли %<PRIuMAX> аргумент?"
msgstr[1] "%s: да се изтрият ли %<PRIuMAX> аргумента?"

#: src/rmdir.c:133 src/rmdir.c:233
#, c-format
msgid "removing directory, %s"
msgstr "изтриване на директорията „%s“"

#: src/rmdir.c:148
#, c-format
msgid "failed to remove directory %s"
msgstr "неуспешно изтриване на директорията „%s“"

#: src/rmdir.c:165
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
msgstr ""
"Изтриване на ДИРЕКТОРИите, ако са празни.\n"
"\n"
"      --ignore-fail-on-non-empty\n"
"                  пренебрегване на проблеми поради непразни директории\n"

#: src/rmdir.c:172
msgid ""
"  -p, --parents   remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' "
"is\n"
"                    similar to 'rmdir a/b/c a/b a'\n"
"  -v, --verbose   output a diagnostic for every directory processed\n"
msgstr ""
"  -p, --parents   изтриване на ДИРЕКТОРИЯта, след което се прави опит за\n"
"                  изтриването на родителските ДИРЕКТОРИи.  Напр.\n"
"                  „rmdir -p a/b/c“ е същото като „rmdir a/b/c a/b a“.\n"
"  -v, --verbose   извеждане на съобщение за всяка обработена директория\n"

#: src/rmdir.c:243
#, c-format
msgid "failed to remove %s"
msgstr "файлът „%s“ не може да се изтрие"

#: src/runcon.c:78
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"Употреба: %s КОНТЕКСТ КОМАНДА [АРГУМЕНТ…]\n"
"     или: %s [ -c ] [-u ПОТРЕБИТЕЛ] [-r РОЛЯ] [-t ВИД] [-l ДИАПАЗОН]\\\n"
"             КОМАНДА [АРГУМЕНТ…]\n"

#: src/runcon.c:82
msgid ""
"Run a program in a different SELinux security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""
"Изпълнение на програма в различен контекст на сигурност на SELinux.\n"
"Без нито КОНТЕКСТ, нито КОМАНДА се извежда текущият контекст на сигурност.\n"

#: src/runcon.c:89
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
"\n"
msgstr ""
"  КОНТЕКСТ               Пълен контекст на сигурност\n"
"  -c, --compute          определяне на контекста на преход на\n"
"                         процеса преди промяна\n"
"  -t, --type=ВИД         вид (при същата роля както родителя)\n"
"  -u, --user=ПОТРЕБИТЕЛ  потребителска самоличност\n"
"  -r, --role=РОЛЯ        роля\n"
"  -l, --range=ДИАПАЗОН   ДИАПАЗОН на нивата\n"
"\n"

#: src/runcon.c:139
msgid "multiple roles"
msgstr "множество роли"

#: src/runcon.c:144
msgid "multiple types"
msgstr "множество видове"

#: src/runcon.c:149
msgid "multiple users"
msgstr "множество потребители"

#: src/runcon.c:154
msgid "multiple levelranges"
msgstr "множество диапазони на нива"

#: src/runcon.c:172 src/runcon.c:208
msgid "failed to get current context"
msgstr "текущият контекст не може да се получи"

#: src/runcon.c:182
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "трябва да укажете някое от „-c“, „-t“, „-u“, „-l“, „-r“ или КОНТЕКСТ"

#: src/runcon.c:190
#, c-format
msgid "no command specified"
msgstr "не е указана команда"

#: src/runcon.c:195
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "„%s“ може да се използва само с ядра с поддръжка на SELinux"

#: src/runcon.c:222
msgid "failed to compute a new context"
msgstr "неуспешно определяне на новия контекст"

#: src/runcon.c:236
#, c-format
msgid "failed to set new user: %s"
msgstr "неуспешно задаване на нов потребител „%s“"

#: src/runcon.c:239
#, c-format
msgid "failed to set new type: %s"
msgstr "неуспешно задаване на нов вид „%s“"

#: src/runcon.c:242
#, c-format
msgid "failed to set new range: %s"
msgstr "неуспешно задаване на нов диапазон „%s“"

#: src/runcon.c:245
#, c-format
msgid "failed to set new role: %s"
msgstr "неуспешно задаване на нова роля „%s“"

#: src/runcon.c:254
#, c-format
msgid "unable to set security context %s"
msgstr "неуспешно задаване на контекст за сигурност „%s“"

#: src/seq.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… КРАЙ\n"
"     или: %s [ОПЦИЯ]… НАЧАЛО КРАЙ\n"
"     или: %s [ОПЦИЯ]… НАЧАЛО СТЪПКА КРАЙ\n"

#: src/seq.c:85
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr ""
"Извеждане на числата от НАЧАЛОто (стандартно 1) до КРАя през тази СТЪПКА "
"(стандартно 1).\n"

#: src/seq.c:91
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"  -f, --format=ФОРМАТ      прилагане на ФОРМА̀Та на „printf“ за плаваща "
"запетая\n"
"  -s, --separator=НИЗ      разделяне на числата с този НИЗ (стандартно: нов "
"ред)\n"
"  -w, --equal-width        допълване с „0“ отпред за еднаква дължина на "
"числата\n"

#: src/seq.c:98
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"
msgstr ""
"\n"
"Ако НАЧАЛОто или СТЪПКАта са пропуснати, стандартно се ползва 1, т.е. дори\n"
"и КРАят да е по-малък от НАЧАЛОто, когато СТЪПКАта е пропусната, тя е 1.\n"
"Извеждането на числа приключва, когато сумата от текущото число и СТЪПКАта "
"е\n"
"след КРАя.\n"
"НАЧАЛОто, СТЪПКАта и КРАят се интерпретират като числа с плаваща запетая.\n"
"Обичайно СТЪПКАта е положителна, ако НАЧАЛОто е по-малко от КРАя и "
"отрицателна\n"
"иначе.  СТЪПКАта не може да е 0.  Никоя от трите стойности не може да е "
"NaN.\n"

#: src/seq.c:109
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"ФОРМАТът трябва да позволява извеждането на аргумент от вид „double“.\n"
"Стандартно е с точност %.PRECf, ако НАЧАЛОто, КРАят и СТЪПКАта са всички с\n"
"десетична точност PREC, а в противен случай е %g.\n"

#: src/seq.c:155
#, c-format
msgid "invalid floating point argument: %s"
msgstr "неправилно число с плаваща запетая като аргумент: %s"

#: src/seq.c:161
#, c-format
msgid "invalid %s argument: %s"
msgstr "неправилен аргумент за %s: „%s“"

#: src/seq.c:268
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "във форматиращия низ „%s“ има непозната директива „%%%c“"

#: src/seq.c:648
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr ""
"не може да се използва форматен низ, когато се извеждат низове с еднаква "
"ширина"

#: src/seq.c:693
#, c-format
msgid "invalid Zero increment value: %s"
msgstr "стъпката не трябва да е нула: %s"

#: src/set-fields.c:167
msgid "invalid byte or character range"
msgstr "неправилен байт или клас от знаци"

#: src/set-fields.c:168
msgid "invalid field range"
msgstr "неправилен диапазон от полета"

#: src/set-fields.c:175 src/set-fields.c:221
msgid "byte/character positions are numbered from 1"
msgstr "позициите на байтовете/знаците се броят от 1"

#: src/set-fields.c:176 src/set-fields.c:222
msgid "fields are numbered from 1"
msgstr "полетата се броят от 1"

#: src/set-fields.c:196
msgid "invalid range with no endpoint: -"
msgstr "неправилен диапазон без край: „-“"

#: src/set-fields.c:210
msgid "invalid decreasing range"
msgstr "неправилен намаляващ диапазон"

#: src/set-fields.c:259
#, c-format
msgid "byte/character offset %s is too large"
msgstr "байтовото/знаковото отместване „%s“ е твърде голямо"

#: src/set-fields.c:260
#, c-format
msgid "field number %s is too large"
msgstr "номерът на поле „%s“ е твърде голям"

#: src/set-fields.c:271
#, c-format
msgid "invalid byte/character position %s"
msgstr "неправилна позиция на байт/знак: „%s“"

#: src/set-fields.c:272
#, c-format
msgid "invalid field value %s"
msgstr "неправилна стойност на полето „%s“"

#: src/set-fields.c:280
msgid "missing list of byte/character positions"
msgstr "липсва списък позиции на байтове/знаци"

#: src/set-fields.c:281
msgid "missing list of fields"
msgstr "липсва списък полета"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:171
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr ""
"Многократно презаписване на съдържанието на посочените ФАЙЛове с цел да се\n"
"затрудни значително възстановяването на данните от тях дори и с използване\n"
"на специална апаратура.\n"

#: src/shred.c:175
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
msgstr ""
"\n"
"Ако за ФАЙЛ е използвано „-“, се чете от стандартния вход.\n"

#: src/shred.c:182
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force    режимът за достъп се променя при нужда да се позволи запис\n"
"  -n, --iterations=ПЪТИ\n"
"                 заличаване този брой ПЪТИ (стандартно: %d)\n"
"      --random-source=ФАЙЛ\n"
"                 изчитане на случайните байтове от ФАЙЛа\n"
"  -s, --size=БРОЙ\n"
"                 заличаване на този БРОЙ байта (може със суфикс като „K“, "
"„M“, …)\n"

#: src/shred.c:188
msgid ""
"  -u             deallocate and remove file after overwriting\n"
"      --remove[=HOW]  like -u but give control on HOW to delete;  See below\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u             освобождаване на заделеното пространство за файла и "
"изтриване\n"
"                 след заличаването му\n"
"      --remove[=НАЧИН]\n"
"                 като „-u“, но със задаване на НАЧИНа за изтриване (вж. по-"
"долу)\n"
"  -v, --verbose  извеждане на информация за напредъка\n"
"  -x, --exact    без закръгляване на размерите на файловете до следващия "
"пълен\n"
"                 блок.  Това е стандартно за специалните файлове и "
"директории\n"
"  -z, --zero     последното припокриване е с нулеви байтове, за да се "
"прикрие\n"
"                 използването на „shred“\n"

#: src/shred.c:198
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.\n"
"The optional HOW parameter indicates how to remove a directory entry:\n"
"'unlink' => use a standard unlink call.\n"
"'wipe' => also first obfuscate bytes in the name.\n"
"'wipesync' => also sync each obfuscated byte to disk.\n"
"The default mode is 'wipesync', but note it can be expensive.\n"
"\n"
msgstr ""
"\n"
"Когато е посочена опция „--remove“/„-u“ ФАЙЛовете се изтриват.  Стандартно "
"това\n"
"не се прави, защото е най-често „shred“ се използва за файлове, представящи\n"
"устройства, като „/dev/hda“ и обикновено такива файлове не трябва да се\n"
"изтриват.\n"
"\n"
"Възможните НАЧИНи се отнасят за служебния запис за файла в директорията му:\n"
"  ⁃ „unlink“: използване на стандартно извикване на „unlink“;\n"
"  ⁃ „wipe“: заличаване на името на файла\n"
"  ⁃ „wipesync“: синхронно презаписване на всеки байт на диска\n"
"\n"
"Стандартно се ползва „wipesync“, но това е времеемко.\n"
"\n"
"\n"

#: src/shred.c:210
msgid ""
"CAUTION: shred assumes the file system and hardware overwrite data in "
"place.\n"
"Although this is common, many platforms operate otherwise.  Also, backups\n"
"and mirrors may contain unremovable copies that will let a shredded file\n"
"be recovered later.  See the GNU coreutils manual for details.\n"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: „shred“ разчита файловата система да заличава данните на\n"
"мястото им.  Макар това обикновено да е така, дизайнът на много от "
"модерните\n"
"файлови системи не отговаря на предположението.  Резервните копия и "
"отдалечените\n"
"огледала също могат да съдържат копия на файла, които не могат да бъдат "
"изтрити\n"
"и които ще позволят изтритият със „shred“ файл да бъде възстановен.  За\n"
"подробности погледнете ръководството на GNU coreutils.\n"

#: src/shred.c:310
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s: неуспешно изпълнение на „fdatasync“"

#: src/shred.c:321
#, c-format
msgid "%s: fsync failed"
msgstr "%s: неуспешно изпълнение на „fsync“"

#: src/shred.c:438
#, c-format
msgid "%s: cannot rewind"
msgstr "%s: неуспешно връщане в началото на файла"

#: src/shred.c:458
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s: итерация %lu/%lu (%s)…"

#: src/shred.c:509
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: грешка при запис при отместване %s"

#: src/shred.c:530
#, c-format
msgid "%s: lseek failed"
msgstr "%s: неуспешно изпълнение на „lseek“"

#: src/shred.c:542
#, c-format
msgid "%s: file too large"
msgstr "%s: файлът е твърде дълъг"

#: src/shred.c:566
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: итерация %lu/%lu (%s)…%s"

#: src/shred.c:582
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: итерация %lu/%lu (%s)…%s/%s %d%%"

#: src/shred.c:840
#, c-format
msgid "%s: fstat failed"
msgstr "%s: неуспешно изпълнение на „fstat“"

#: src/shred.c:851
#, c-format
msgid "%s: invalid file type"
msgstr "%s: неправилен вид файл"

#: src/shred.c:856
#, c-format
msgid "%s: file has negative size"
msgstr "%s: файлът има отрицателен размер"

#: src/shred.c:952 src/sort.c:972 src/split.c:475
#, c-format
msgid "%s: error truncating"
msgstr "%s: неуспешно отсичане"

#: src/shred.c:971
#, c-format
msgid "%s: fcntl failed"
msgstr "%s: неуспешно изпълнение на „fcntl“"

#: src/shred.c:976
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: файл с режим на достъп само за добавяне не може да се заличи"

#: src/shred.c:1059
#, c-format
msgid "%s: removing"
msgstr "%s: изтриване"

#: src/shred.c:1084
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: преименуван на „%s“"

#: src/shred.c:1093
#, c-format
msgid "%s: failed to remove"
msgstr "%s: не може да се изтрие"

#: src/shred.c:1097
#, c-format
msgid "%s: removed"
msgstr "%s: изтрит"

#: src/shred.c:1104 src/shred.c:1147
#, c-format
msgid "%s: failed to close"
msgstr "%s: не може да се затвори"

#: src/shred.c:1140
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s: не може да се отвори в режим за писане"

#: src/shred.c:1203
msgid "invalid number of passes"
msgstr "неправилен брой итерации"

#: src/shred.c:1208 src/shuf.c:462 src/sort.c:4508
msgid "multiple random sources specified"
msgstr "указани са множество източници на случайност"

#: src/shred.c:1222
msgid "invalid file size"
msgstr "неправилен размер на файл"

#: src/shuf.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… [ФАЙЛ]\n"
"     или: %s -e [ОПЦИЯ]… [АРГУМЕНТ]…\n"
"     или: %s -i ОТ-ДО [ОПЦИЯ]…\n"

#: src/shuf.c:68
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr ""
"Запис на случайна пермутация на входните редове на стандартния изход.\n"

#: src/shuf.c:75
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -r, --repeat              output lines can be repeated\n"
msgstr ""
"  -e, --echo                всеки АРГУМЕНТ се интерпретира като входен ред\n"
"  -i, --input-range=ОТ-ДО   всяко число ОТ-ДО се интерпретира като входен "
"ред\n"
"  -n, --head-lines=БРОЙ     извеждане на максимално този БРОЙ редове\n"
"  -o, --output=ФАЙЛ         извеждане във ФАЙЛа вместо на стандартния изход\n"
"      --random-source=ФАЙЛ  случайни байтове от този ФАЙЛ, а не „/dev/"
"urandom“\n"
"  -r, --repeat              позволяване на повторения в изведените редове\n"

#: src/shuf.c:226
msgid "too many input lines"
msgstr "прекалено много входни редове"

#: src/shuf.c:418
msgid "multiple -i options specified"
msgstr "указани са повече от една опции „-i“"

#: src/shuf.c:425 src/shuf.c:431 src/shuf.c:436
msgid "invalid input range"
msgstr "неправилен входен диапазон"

#: src/shuf.c:449
#, c-format
msgid "invalid line count: %s"
msgstr "нeправилен брой редове: %s"

#: src/shuf.c:456 src/sort.c:4502
msgid "multiple output files specified"
msgstr "указани са множество изходни файлове"

#: src/shuf.c:486
#, c-format
msgid "cannot combine -e and -i options"
msgstr "опциите „-e“ и „-i“ са несъвместими"

#: src/shuf.c:575
msgid "no lines to repeat"
msgstr "няма редове за повтаряне"

#: src/sleep.c:44
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  NUMBER need not be an\n"
"integer.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"Употреба: %s БРОЙ[СУФИКС]…\n"
"     или: %s ОПЦИЯ\n"
"Изчакване на този БРОЙ периоди — стандартно са секунди.  СУФИКСът може да "
"бъде\n"
"„s“ за секунди (стандартно), „m“ за минути, „h“ за часове или „d“ за дни.\n"
"БРОят трябва да бъде произволно число с плаваща запетая.  При повече от "
"един\n"
"аргументи се чака сумата от посочените времена.\n"
"\n"

#: src/sleep.c:132 src/timeout.c:332
#, c-format
msgid "invalid time interval %s"
msgstr "неправилен интервал за време „%s“"

#: src/sleep.c:143 src/tail.c:1311
msgid "cannot read realtime clock"
msgstr "часовникът в реално време не може да се чете"

#: src/sort.c:420
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr ""
"Извеждане на подреденото обединено съдържание на всички ФАЙЛ(ове) на "
"стандартния изход\n"

#: src/sort.c:427
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"Опции за подредба:\n"
"\n"

#: src/sort.c:431
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks без отчитане на интервалите в началото\n"
"  -d, --dictionary-order      отчитане само на интервалите и буквено-"
"цифровите\n"
"                              знаци\n"
"  -f, --ignore-case           без разлика между главни и малки букви\n"

#: src/sort.c:437
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""
"  -g, --general-numeric-sort  подредба като числа\n"
"  -i, --ignore-nonprinting    подредба само по видимите знаци, а не "
"интервалите\n"
"  -M, --month-sort            подредба като месеци: (друго) < „ЯНУ“ < … < "
"“ДЕК“\n"

#: src/sort.c:442
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr ""
"  -h, --human-numeric-sort    „човешка“ подредба (със зачитане на 2K, 1G…)\n"

#: src/sort.c:445
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           shuffle, but group identical keys.  See "
"shuf(1)\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort          подредба според числовата стойност на "
"низовете\n"
"  -R, --random-sort           случайна подредба с групиране на еднаквите\n"
"                              ключове (вж. „shuf(1)“)\n"
"      --random-source=ФАЙЛ    четене на случайни байтове от ФАЙЛ (вместо\n"
"                              „/dev/urandom“)\n"
"  -r, --reverse               подредба в обратен ред\n"

#: src/sort.c:451
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=ДУМА             подредба според ДУМАта:\n"
"                                „general-numeric“≡„-g“, „human-numeric“≡„-"
"h“,\n"
"                                „month“≡„-M“, „numeric“≡„-n“, „random“≡„-"
"R“,\n"
"                                „version“≡„-V“\n"
"  -V, --version-sort          естествена подредба като числа-версии\n"
"\n"

#: src/sort.c:459
msgid ""
"Other options:\n"
"\n"
msgstr ""
"Други опции:\n"
"\n"

#: src/sort.c:463
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=БРОЙ     сливане на максимално такъв БРОЙ входа "
"наведнъж,\n"
"                            за повече да се ползват временни файлове\n"

#: src/sort.c:467
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first  само се проверява дали входните данни "
"са\n"
"                                       подредени, без подредба\n"
"  -C, --check=quiet, --check=silent    като „-c“, но без извеждане на "
"първия\n"
"                                       сгрешен ред\n"
"      --compress-program=ПРОГРАМА      компресиране на временните резултати "
"с\n"
"                                       тази ПРОГРАМА, декомпресиране с:\n"
"                                       „ПРОГРАМАта -d“\n"

#: src/sort.c:474
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug               анотиране на частта от реда, използвана за\n"
"                            подредбата и предупреждаване за неправилна "
"употреба\n"
"                            на стандартната грешка\n"
"      --files0-from=ФАЙЛ    за вход се ползват файловете изброени в този "
"ФАЙЛ,\n"
"                            разделени с нулев байт.  Имената се изчитат от\n"
"                            стандартния вход, ако ФАЙЛът е „-“\n"

#: src/sort.c:481
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=КЛЮЧ            подредба според мястото и вида на дадения КЛЮЧ\n"
"  -m, --merge               сливане на вече подредени файлове, не се "
"извършва\n"
"                            допълнително подреждане\n"

#: src/sort.c:485
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=ФАЙЛ         запазване на резултата във ФАЙЛа вместо на\n"
"                            стандартния изход\n"
"  -s, --stable              стабилна подредба, прескачане на последната/\n"
"                            резервната\n"
"  -S, --buffer-size=РАЗМЕР  използване на буфер в паметта с този РАЗМЕР\n"

#: src/sort.c:491
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=РАЗДЕЛИТЕЛ\n"
"                            използване на този РАЗДЕЛИТЕЛ вместо преход от "
"видим\n"
"                            знак към интервал\n"
"  -T, --temporary-directory=ДИРЕКТОРИЯ\n"
"                            използване на тази ДИРЕКТОРИЯ директория за "
"временни\n"
"                            файлове вместо „$TMPDIR“ или „%s“.  Задайте  "
"няколко\n"
"                            такива опции за няколко директории\n"
"      --parallel=БРОЙ       ползване на този БРОЙ паралелни подредби\n"
"  -u, --unique              с „-c“ — проверка за строга наредба, иначе се\n"
"                            извежда само първият от група еквивалентни "
"редове\n"

#: src/sort.c:505
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"КЛЮЧът е ПОЛЕ[.ЗНАК][ОПЦИИ][,ПОЛЕ[.ЗНАК][ОПЦИИ]] за началната и крайната\n"
"позиции, където номерът на ПОЛЕто и мястото на ЗНАКа в полето се броят от "
"1.\n"
"Когато не е указан край се използва редът до края му, а ако не е зададен "
"КЛЮЧ,\n"
"се използва целият ред.  Ако не е зададена някоя от опциите „-t“ и „-b“,\n"
"знаците в полето се броят от началото на предхождащото бяло поле.  ОПЦИИте "
"са\n"
"подмножество на „bdfgiMhnRrV“ и задават подредбата с приоритет пред "
"глобалните\n"
"опции за наредба на това поле.\n"
"\n"
"РАЗМЕРът може да бъде следван от някой от следните множители:\n"

#: src/sort.c:518
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 1% от паметта, b 1, K 1024 (стандартно) и т.н. за M, G, T, P, E, Z, Y.\n"
"\n"
"••• ПРЕДУПРЕЖДЕНИЕ •••\n"
"Локалът, посочен в обкръжението, влияе на подредбата!\n"
"Използвайте LC_ALL=C, за да получите традиционната, при която се сравнява "
"според\n"
"стойността на байтовете.\n"

#: src/sort.c:716
#, c-format
msgid "waiting for %s [-d]"
msgstr "изчакване на „%s“ [-d]"

#: src/sort.c:721
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "„%s“ [-d] бе прекратен неочаквано"

#: src/sort.c:876
#, c-format
msgid "cannot create temporary file in %s"
msgstr "не може да се създаде временен файл в „%s“"

#: src/sort.c:991 src/sort.c:2100 src/sort.c:3137 src/sort.c:3780
#: src/sort.c:3871 src/sort.c:3874
msgid "open failed"
msgstr "неуспешно отваряне"

#: src/sort.c:1011
msgid "fflush failed"
msgstr "неуспешно изчистване на буферите с „fflush“"

#: src/sort.c:1016 src/sort.c:2103 src/sort.c:4778
msgid "close failed"
msgstr "неуспешно затваряне"

#: src/sort.c:1155
msgid "couldn't create temporary file"
msgstr "неуспешно създаване на временен файл"

#: src/sort.c:1194
#, c-format
msgid "couldn't create process for %s -d"
msgstr "неуспешно създаване на процес за „%s -d“"

#: src/sort.c:1267
#, c-format
msgid "warning: cannot remove: %s"
msgstr "ПРЕДУПРЕЖДЕНИЕ: „%s“ не може да се изтрие"

#: src/sort.c:1353
#, c-format
msgid "invalid --%s argument %s"
msgstr "неправилен аргумент „%2$s“ за опцията „--%1$s“"

#: src/sort.c:1356
#, c-format
msgid "minimum --%s argument is %s"
msgstr "минималният аргумент за опцията „--%s“ е „%s“"

#: src/sort.c:1371
#, c-format
msgid "--%s argument %s too large"
msgstr "аргументът „%2$s“ за опцията „--%1$s“ е прекалено голям"

#: src/sort.c:1374
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "максималният аргумент, който опцията „--%s“ приема в момента, е: %s"

#: src/sort.c:1456
msgid "number in parallel must be nonzero"
msgstr "паралелността не може да е 0"

#: src/sort.c:1539
msgid "stat failed"
msgstr "неуспешно изпълнение на „stat“"

#: src/sort.c:1801
msgid "read failed"
msgstr "неуспешно прочитане"

#: src/sort.c:2118
#, c-format
msgid "string transformation failed"
msgstr "неуспешно преобразуване на низове"

#: src/sort.c:2121
#, c-format
msgid "the untransformed string was %s"
msgstr "непреобразуваният низ бе „%s“"

#: src/sort.c:2284
#, c-format
msgid "^ no match for key\n"
msgstr "↑ няма съвпадение по ключа\n"

#: src/sort.c:2456
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr "използваният ключ „%s“ е остарял, заменете го с „%s“"

#: src/sort.c:2463
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "ключ №%lu е с нулева дължина и се прескача"

#: src/sort.c:2472
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr ""
"водещите интервали се значими за ключ №%lu.  Може да укажете и опцията „b“"

#: src/sort.c:2485
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "ключ №%lu е число и заема няколко полета"

#: src/sort.c:2517
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] "опцията „-%s“ се прескача"
msgstr[1] "опциите „-%s“ се прескачат"

#: src/sort.c:2523
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr "опцията „-r“ се отнася само за последната (резервна) подредба"

#: src/sort.c:2797 src/sort.c:2806
msgid "write failed"
msgstr "неуспешен запис"

#: src/sort.c:2849
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: разбърканост: "

#: src/sort.c:2852
msgid "standard error"
msgstr "стандартна грешка"

#: src/sort.c:3764
msgid "cannot read"
msgstr "не може да се прочете"

#: src/sort.c:4043
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s: неправилно указано поле — „%s“"

#: src/sort.c:4053
#, c-format
msgid "options '-%s' are incompatible"
msgstr "опциите „-%s“ са несъвместими"

#: src/sort.c:4103
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s: грешен номер на ред в началото на „%s“"

#: src/sort.c:4362
msgid "invalid number after '-'"
msgstr "грешно число след „--“"

#: src/sort.c:4369 src/sort.c:4455 src/sort.c:4483
msgid "invalid number after '.'"
msgstr "грешно число след „.“"

#: src/sort.c:4382 src/sort.c:4488
msgid "stray character in field spec"
msgstr "излишен знак в указателя на поле"

#: src/sort.c:4429
msgid "multiple compress programs specified"
msgstr "указани са множество програми за компресиране"

#: src/sort.c:4446
msgid "invalid number at field start"
msgstr "неправилно число в началото на поле"

#: src/sort.c:4450 src/sort.c:4478
msgid "field number is zero"
msgstr "номерът на поле е 0"

#: src/sort.c:4459
msgid "character offset is zero"
msgstr "отместването по знак е 0"

#: src/sort.c:4474
msgid "invalid number after ','"
msgstr "неправилно число след „.“"

#: src/sort.c:4524
msgid "empty tab"
msgstr "празна табулация"

#: src/sort.c:4607 src/wc.c:784
#, c-format
msgid "cannot read file names from %s"
msgstr "имената на файловете не могат да се прочетат от „%s“"

#: src/sort.c:4629
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "„%s:%lu“: име с нулева дължина е неправилно за файл"

#: src/sort.c:4635
#, c-format
msgid "no input from %s"
msgstr "няма вход от „%s“"

#: src/sort.c:4688
#, c-format
msgid "text ordering performed using %s sorting rules"
msgstr "подредба според правилата „%s“"

#: src/sort.c:4692
msgid "text ordering performed using simple byte comparison"
msgstr "подредба чрез побайтово сравнение"

#: src/sort.c:4724
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "опцията „-%2$c“ е несъвместима с допълнителния операнд „%1$s“"

#: src/split.c:209
#, c-format
msgid "the suffix length needs to be at least %<PRIuMAX>"
msgstr "дължината на суфикса трябва да е поне %<PRIuMAX>"

#: src/split.c:226
#, c-format
msgid "Usage: %s [OPTION]... [FILE [PREFIX]]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ФАЙЛ[ПРЕФИКС]]\n"

#: src/split.c:230
msgid ""
"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n"
"default size is 1000 lines, and default PREFIX is 'x'.\n"
msgstr ""
"Разделяне на ВХОДа на парчета ПРЕФИКСaa, ПРЕФИКСab,… с фиксиран размер.\n"
"Стандартно ПРЕФИКСът е „x“, а размерът — 1000 реда.\n"

#: src/split.c:238
#, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n"
"  -d                      use numeric suffixes starting at 0, not "
"alphabetic\n"
"      --numeric-suffixes[=FROM]  same as -d, but allow setting the start "
"value\n"
"  -x                      use hex suffixes starting at 0, not alphabetic\n"
"      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines/records per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files; see explanation "
"below\n"
"  -t, --separator=SEP     use SEP instead of newline as the record "
"separator;\n"
"                            '\\0' (zero) specifies the NUL character\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""
"-a, --suffix-length=ДЪЛЖИНА\n"
"                          суфиксите да са с тази ДЪЛЖИНА (стандартно — %d)\n"
"      --additional-suffix=СУФИКС\n"
"                          добавяне на този СУФИКС към имената на файловете\n"
"  -b, --bytes=БАЙТОВЕ     изходните файлове да съдържат този брой БАЙТОВЕ\n"
"  -C, --line-bytes=РАЗМЕР включване на записи с максимално този кумулативен\n"
"                          размер във всеки изходен файл\n"
"  -d                      десетични суфикси, почващи от 0\n"
"      --numeric-suffixes[=НАЧАЛО]\n"
"                          като „-d“, но може да зададете НАЧАЛОто\n"
"  -x                      шестнадесетични суфикси, почващи от 0\n"
"      --hex-suffixes[=НАЧАЛО]\n"
"                          като „-x“, но може да зададете НАЧАЛОто\n"
"  -e, --elide-empty-files без генериране на празни изходни файлове при "
"ползване\n"
"                          на „-n“\n"
"      --filter=КОМАНДА    запис към тази КОМАНДА, името на файл е „$FILE“\n"
"  -l, --lines=БРОЙ        извеждане на този БРОЙ редове/записи в изходен "
"файл\n"
"  -n, --number=БРОЙ       извеждане на този БРОЙ изходни файлове, вж. по-"
"долу\n"
"  -t, --separator=РАЗДЕЛИТЕЛ\n"
"                          разделяне на записите с този РАЗДЕЛИТЕЛ вместо нов "
"ред,\n"
"                          за нулев байт използвайте „\\0“\n"
"  -u, --unbuffered        незабавно копиране на входа към изхода с „-n r/…“\n"

#: src/split.c:256
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr ""
"      --verbose           извеждане на диагностично съобщение преди "
"отварянето\n"
"                          на всеки изходен файл\n"

#: src/split.c:263
msgid ""
"\n"
"CHUNKS may be:\n"
"  N       split into N files based on size of input\n"
"  K/N     output Kth of N to stdout\n"
"  l/N     split into N files without splitting lines/records\n"
"  l/K/N   output Kth of N to stdout without splitting lines/records\n"
"  r/N     like 'l' but use round robin distribution\n"
"  r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"ПАРЧЕТАта може да са:\n"
"  N       разделяне на такъв брой файлове на базата на размера на входа\n"
"  K/N     извеждане на всеки K-ти от общо N файла на стандартния изход\n"
"  l/N     разделяне на N файла без разделяне на редове/записи\n"
"  l/K/N   извеждане на всеки K-ти от общо N файл без разделяне на редове/"
"записи\n"
"          на стандартния изход\n"
"  r/N     като „l“ но с последователно разпределение\n"
"  r/K/N   същото като „r/N“ и с извеждане на всеки K-ти от общо N на "
"стандартния\n"
"          изход\n"

#: src/split.c:450
msgid "output file suffixes exhausted"
msgstr "суфиксите за изходни файлове се изчерпаха"

#: src/split.c:462
#, c-format
msgid "creating file %s\n"
msgstr "създава се файл „%s“\n"

#: src/split.c:471
#, c-format
msgid "%s would overwrite input; aborting"
msgstr "„%s“ ще презапише изхода, отказ за изпълнение"

#: src/split.c:488
msgid "failed to set FILE environment variable"
msgstr "променливата от обкръжението „FILE“ не може да се зададе"

#: src/split.c:490
#, c-format
msgid "executing with FILE=%s\n"
msgstr "изпълнение с „FILE=%s“\n"

#: src/split.c:492
msgid "failed to create pipe"
msgstr "неуспешно създаване на програмен канал"

#: src/split.c:506
msgid "closing prior pipe"
msgstr "предишният програмен канал се затваря"

#: src/split.c:508
msgid "closing output pipe"
msgstr "затваряне на изходния програмен канал"

#: src/split.c:512
msgid "moving input pipe"
msgstr "преместване на входния програмен канал"

#: src/split.c:514
msgid "closing input pipe"
msgstr "затваряне на входния програмен канал"

#: src/split.c:519
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "неуспешно изпълнение на командата „%s -c %s“"

#: src/split.c:525
msgid "failed to close input pipe"
msgstr "неуспешна затваряне на входния програмен канал"

#: src/split.c:561
msgid "waiting for child process"
msgstr "изчакване на дъщерния процес"

#: src/split.c:571
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr "при „FILE=%s“, сигнал %s от командата „%s“"

#: src/split.c:579
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr "при „FILE=%s“, код за изход %d от командата „%s“"

#: src/split.c:586
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "непознат код за състояние от команда (0x%X)"

#: src/split.c:1274
#, c-format
msgid "cannot split in more than one way"
msgstr "не може да се разделя по повече от един начин"

#: src/split.c:1286 src/split.c:1401 src/split.c:1602
msgid "invalid number of chunks"
msgstr "неправилен брой парчета"

#: src/split.c:1291
msgid "invalid chunk number"
msgstr "неправилен номер на парче"

#: src/split.c:1338
msgid "invalid suffix length"
msgstr "неправилна дължина на суфикс"

#: src/split.c:1412
msgid "empty record separator"
msgstr "празен разделител на записи"

#: src/split.c:1423
#, c-format
msgid "multi-character separator %s"
msgstr "разделител от множество знаци „%s“"

#: src/split.c:1431
msgid "multiple separator characters specified"
msgstr "указани да множество знаци за разделители"

#: src/split.c:1462
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "опцията за брой редове „-%s%c“… е твърде голямa"

#: src/split.c:1479
#, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr "%s: неправилна начална стойност за числов суфикс"

#: src/split.c:1480
#, c-format
msgid "%s: invalid start value for hexadecimal suffix"
msgstr "%s: неправилна начална стойност за шестнадесетичен суфикс"

#: src/split.c:1504
msgid "invalid IO block size"
msgstr "неправилен размер на входно/изходен блок: %s"

#: src/split.c:1522
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr ""
"опцията „--filter“ не се прилага към парчета, изведени на стандартния вход"

#: src/split.c:1562
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr ""
"началната стойност на числовия суфикс е прекалено голяма за дължината му"

#: src/split.c:1594
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s: размерът на файла не може да бъде определен"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:197
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:989
#, c-format
msgid "failed to canonicalize %s"
msgstr "„%s“ не може да се приведе в канонична форма"

#: src/stat.c:1092
#, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "ПРЕДУПРЕЖДЕНИЕ: непознато екраниране „\\%c“"

#: src/stat.c:1153
#, c-format
msgid "%s: invalid directive"
msgstr "%s: неправилна команда"

#: src/stat.c:1200
#, c-format
msgid "warning: backslash at end of format"
msgstr "ПРЕДУПРЕЖДЕНИЕ: обратна наклонена черта в края на форматен низ"

#: src/stat.c:1231
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr "„%s“ няма как да означава стандартния вход в режим на файлова система"

#: src/stat.c:1238
#, c-format
msgid "cannot read file system information for %s"
msgstr "информацията за „%s“ не може да се прочете от файловата система"

#: src/stat.c:1362 src/stat.c:1429
#, c-format
msgid "cannot stat standard input"
msgstr "не може да се изпълни „stat“ върху стандартния вход"

#: src/stat.c:1364
#, c-format
msgid "cannot statx %s"
msgstr "не може да се получи информация със „statx“ за „%s“"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1608
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  Файл: „%n“\n"
"   Ид.: %-8i Дължина на име: %-7l Вид: %T\n"
"Размер блок: %-10s Фундаментален размер блок: %S\n"
"Блокове: Общо: %-10b Свободни: %-10f Налични: %a\n"
"I-възли: Общо: %-10c Свободни: %d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1629
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  Файл: „%N“\n"
"Размер: %-10s Блокове: %-10b Вх./изх. %-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1639
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %-5h Device type: %t,%T\n"
msgstr "Устройство: %Dh/%dd I-възли: %-10i Връзки: %-5h Вид: %t,%T\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1647
msgid "Device: %Dh/%dd\tInode: %-10i  Links: %h\n"
msgstr "Устройство: %Dh/%dd I-възли: %-10i Връзки: %-5h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1656
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "Достъп: (%04a/%10.10A)  Потр: (%5u/%8U) Гр: (%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1666
#, c-format
msgid "Context: %C\n"
msgstr "Контекст: %C\n"

#: src/stat.c:1674
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"   Последен достъп: %x\n"
"  Промяна на файла: %y\n"
"Смяна на метаданни: %z\n"
"         Създаване: %w\n"

#: src/stat.c:1692
msgid "Display file or file system status.\n"
msgstr "Извеждане на информация за файл или файлова система.\n"

#: src/stat.c:1698
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"  -L, --dereference     следване на символните връзки\n"
"  -f, --file-system     извеждане на състоянието на файловата система\n"
"                        вместо това на файла\n"

#: src/stat.c:1702
msgid ""
"      --cached=MODE     specify how to use cached attributes;\n"
"                          useful on remote file systems. See MODE below\n"
msgstr ""
"      --cached=РЕЖИМ    как да се ползват кешираните атрибути, което е "
"полезно\n"
"                        за отдалечените файлови системи.  Вижте РЕЖИМ по-"
"долу\n"

#: src/stat.c:1706
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline;\n"
"                          if you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c  --format=ФОРМАТ   ползване на посочения ФОРМАТ, вместо стандартния.\n"
"                        Извеждане на нов ред след всяко използване на "
"ФОРМА̀Та\n"
"      --printf=ФОРМАТ   като --format, но „\\“ се интерпретират, а "
"задължителният\n"
"                        завършващ нов ред не се извежда.  Ако искате нов "
"ред,\n"
"                        вмъкнете „\\n“ във ФОРМА̀Та.\n"
"  -t, --terse           извеждане на информацията в сбита форма\n"

#: src/stat.c:1717
msgid ""
"\n"
"The --cached MODE argument can be; always, never, or default.\n"
"`always` will use cached attributes if available, while\n"
"`never` will try to synchronize with the latest attributes, and\n"
"`default` will leave it up to the underlying file system.\n"
msgstr ""
"\n"
"Аргументът РЕЖИМ към опцията „--cached“ може да е:\n"
"  ⁃ „always“:  винаги да се ползва кеширан атрибут, ако е наличен\n"
"  ⁃ „never“:   винаги да се ползва актуална стойност на атрибута\n"
"  ⁃ „default“: решението се взима според ползваната файлова система\n"

#: src/stat.c:1724
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   permission bits in octal (note '#' and '0' printf flags)\n"
"  %A   permission bits and file type in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"Допустими ФОРМАТи за файлове (без „--file-system“) са:\n"
"\n"
"  ⁃ „%a“:  режим за достъп като осмично число (вж. флагове „#“/„0“ на "
"„printf“)\n"
"  ⁃ „%A“:  режим за достъп във формат, удобен за четене от хора\n"
"  ⁃ „%b“:  брой заделени блокове (вж. %B)\n"
"  ⁃ „%B“:  размер в байтове на всеки блок, съобщен от %b\n"
"  ⁃ „%C“:  контекст за сигурност на SELinux\n"

#: src/stat.c:1733
msgid ""
"  %d   device number in decimal\n"
"  %D   device number in hex\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""
"  ⁃ „%d“:  десетичен номер на устройство\n"
"  ⁃ „%D“:  шестнадесетичен номер на устройство\n"
"  ⁃ „%f“:  шестнадесетичен суров режим (raw mode)\n"
"  ⁃ „%F“:  вид на файла\n"
"  ⁃ „%g“:  номер на групата на собственика\n"
"  ⁃ „%G“:  име на групата на собственика\n"

#: src/stat.c:1741
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %t   major device type in hex, for character/block device special files\n"
"  %T   minor device type in hex, for character/block device special files\n"
msgstr ""
"  ⁃ „%h“:  брой твърди връзки\n"
"  ⁃ „%i“:  номер на i-възел\n"
"  ⁃ „%m“:  точка на монтиране\n"
"  ⁃ „%n“:  име на файла\n"
"  ⁃ „%N“:  име на файла в кавички, сочен файл, ако е символна връзка\n"
"  ⁃ „%o“:  оптимален размер на входно-изходния блок за бърз трансфер\n"
"  ⁃ „%s“:  общ размер в байтове\n"
"  ⁃ „%t“:  голям шестнадесетичен номер на устройство при специални файлове\n"
"  ⁃ „%T“:  малък шестнадесетичен номер на устройство при специални файлове\n"

#: src/stat.c:1752
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last data modification, human-readable\n"
"  %Y   time of last data modification, seconds since Epoch\n"
"  %z   time of last status change, human-readable\n"
"  %Z   time of last status change, seconds since Epoch\n"
"\n"
msgstr ""
"  ⁃ „%u“:  идентификатор на собственика\n"
"  ⁃ „%U“:  потребителско име на собственика\n"
"  ⁃ „%w“:  време на създаване, ако такова има.  Ако няма: „-“\n"
"  ⁃ „%W“:  време на създаване в секунди от Епохата.  Ако няма: „0“\n"
"  ⁃ „%x“:  време на последен достъп\n"
"  ⁃ „%X“:  време на последен достъп в секунди от Епохата\n"
"  ⁃ „%y“:  време на последна промяна на данните\n"
"  ⁃ „%Y“:  време на последна промяна на данните в секунди от Епохата\n"
"  ⁃ „%z“:  време на последна промяна на метаданните\n"
"  ⁃ „%Z“:  време на последна промяна на метаданните в секунди от Епохата\n"
"\n"

#: src/stat.c:1766
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""
"Поддържат се следните формати за файловите системи са:\n"
"\n"
"  ⁃ „%a“:  свободни блокове, достъпни за обикновени потребители\n"
"  ⁃ „%b“:  общ брой блокове за данни във файловата система\n"
"  ⁃ „%c“:  общ брой i-възли във файловата система\n"
"  ⁃ „%d“:  свободни i-възли във файловата система\n"
"  ⁃ „%f“:  свободни блокове във файловата система\n"

#: src/stat.c:1775
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""
"  ⁃ „%i“:  шестнадесетичен идентификатор на файловата система\n"
"  ⁃ „%l“:  максимална дължина на файловите имена\n"
"  ⁃ „%n“:  име на файла\n"
"  ⁃ „%s“:  оптимален размер на блока за бърз трансфер\n"
"  ⁃ „%S“:  основен размер на блока (при броене на блоковете)\n"
"  ⁃ „%t“:  вид на файловата система като шестнадесетично число\n"
"  ⁃ „%T“:  човешко име на вида на файловата система\n"

#: src/stat.c:1785
#, c-format
msgid ""
"\n"
"--terse is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"\n"
"„--terse“ означава следния ФОРМАТ:\n"
"    %s"

#: src/stat.c:1796
#, c-format
msgid ""
"--terse --file-system is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"„--terse --file-system“ означава следния ФОРМАТ:\n"
"    %s"

#: src/stdbuf.c:91
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "Употреба: %s [ОПЦИЯ]… КОМАНДА…\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr ""
"Изпълнение на КОМАНДАта с промяна на буферирането на стандартния вход, изход "
"и грешка.\n"

#: src/stdbuf.c:98
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=РЕЖИМ  промяна на буферирането на стандартния вход\n"
"  -o, --output=РЕЖИМ промяна на буферирането на стандартния изход\n"
"  -e, --error=РЕЖИМ  промяна на буферирането на стандартната грешка\n"

#: src/stdbuf.c:105
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"Ако РЕЖИМът е „L“, съответният поток ще се буферира поредово.\n"
"Този вариант не може да се приложи към стандартния вход.\n"

#: src/stdbuf.c:108
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"Ако РЕЖИМът е „0“, съответният поток е небуфериран.\n"

#: src/stdbuf.c:111
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"РЕЖИМът може да се състои от цяло число и незадължителен суфикс-множител.\n"
"Напр. 10K≡10×1024\n"
"Единиците „K“(≡1024), „M“(≡1024×1024), „G“, „T“, „P“, „E“, „Z“, „Y“ са за\n"
"последователните степени на 1024, а вариантите с B — „KB“(≡1000),\n"
"„M“(≡1000×1000), „GB“, „TB“, „PB“, „EB“, „ZB“, „YB“ са за степените на "
"1000.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"
"В този случай РЕЖИМът указва размера на буфера, приложен към съответния "
"поток.\n"

#: src/stdbuf.c:118
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for example) then that will override corresponding changes by 'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""
"\n"
"ПРЕДУПРЕЖДЕНИЕ: Ако КОМАНДАта сама указва буфурирането на стандартните си\n"
"потоци, както прави „tee“, това има приоритет над указаното от „stdbuf“.\n"
"Някои филтри, като „dd“, „cat“ и др.) не използват потоци за входно/изходни\n"
"операции и не се влияят от промяната на настройките чрез „stdbuf“.\n"

#: src/stdbuf.c:243
#, c-format
msgid "failed to find %s"
msgstr "командата „%s“ не е открита"

#: src/stdbuf.c:267 src/stdbuf.c:300
#, c-format
msgid "failed to update the environment with %s"
msgstr "неуспешна промяна на средата чрез „%s“"

#: src/stdbuf.c:346
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "поредовото буфериране на стандартния вход е безсмислено"

#: src/stdbuf.c:377
#, c-format
msgid "you must specify a buffering mode option"
msgstr "трябва да укажете опция за режима на буфериране"

#: src/stty.c:531
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"Употреба: %s [-F УСТРОЙСТВО | --file=УСТРОЙСТВО] [НАСТРОЙКА]…\n"
"     или: %s [-F УСТРОЙСТВО | --file=УСТРОЙСТВО] [-a|--all]\n"
"     или: %s [-F УСТРОЙСТВО | --file=УСТРОЙСТВО] [-g|--save]\n"

#: src/stty.c:537
msgid "Print or change terminal characteristics.\n"
msgstr "Извеждане или промяна на характеристиките на терминала.\n"

#: src/stty.c:543
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"  -a, --all          извеждане на всички настройки във формат, четим от "
"хора\n"
"  -g, --save         извеждане на всички настройки във формат, четим от "
"stty\n"
"  -F, --file=УСТРОЙСТВО\n"
"                     отваряне и използване на посоченото УСТРОЙСТВО вместо\n"
"                     стандартния вход\n"

#: src/stty.c:550
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"Незадължителен знак „-“ преди НАСТРОЙКА показва отрицание.  Със знак „•“\n"
"са означени настройките, която не са от POSIX.  Кои настройки са допустими\n"
"зависи от използваната система.\n"

#: src/stty.c:555
msgid ""
"\n"
"Special characters:\n"
msgstr ""
"\n"
"Специални знаци:\n"

#: src/stty.c:559
msgid " * discard CHAR  CHAR will toggle discarding of output\n"
msgstr " • discard ЗНАК  ЗНАК, превключващ изхвърлянето на изхода\n"

#: src/stty.c:564
msgid ""
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
msgstr ""
" • dsusp ЗНАК    ЗНАК, изпращащ сигнал „terminal stop“ (спиране на\n"
"                 терминала), при изчистването на буферите на входа\n"

#: src/stty.c:568
msgid ""
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"   eof ЗНАК      ЗНАК, изпращащ сигнал край на файл (ще прекрати входа)\n"
"   eol ЗНАК      ЗНАК, завършващ реда\n"

#: src/stty.c:573
msgid " * eol2 CHAR     alternate CHAR for ending the line\n"
msgstr " • eol2 ЗНАК     алтернативен ЗНАК за край на ред\n"

#: src/stty.c:577
msgid ""
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
"   erase ЗНАК    ЗНАК, изтриващ последния въведен знак\n"
"   intr ЗНАК     ЗНАК, изпращащ сигнал за прекъсване\n"
"   kill ЗНАК     ЗНАК, изтриващ текущия ред\n"

#: src/stty.c:583
msgid " * lnext CHAR    CHAR will enter the next character quoted\n"
msgstr " • lnext ЗНАК    ЗНАК, въвеждащ следващия знак цитиран\n"

#: src/stty.c:588
msgid " * status CHAR   CHAR will send an info signal\n"
msgstr " • status CHAR   ЗНАК, изпращащ сигнал за информация\n"

#: src/stty.c:592
msgid "   quit CHAR     CHAR will send a quit signal\n"
msgstr "   quit ЗНАК     ЗНАК, изпращащ сигнал за прекратяване (quit)\n"

#: src/stty.c:596
msgid " * rprnt CHAR    CHAR will redraw the current line\n"
msgstr " • rprnt ЗНАК    ЗНАК, извеждащ целия текущ ред наново\n"

#: src/stty.c:600
msgid ""
"   start CHAR    CHAR will restart the output after stopping it\n"
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
msgstr ""
"   start CHAR    ЗНАК, подновяващ извеждането след спирането му\n"
"   stop ЗНАК     ЗНАК, спиращ извеждането\n"
"   susp ЗНАК     ЗНАК, изпращащ сигнал „спиране на терминала“\n"

#: src/stty.c:606
msgid " * swtch CHAR    CHAR will switch to a different shell layer\n"
msgstr ""
" • swtch ЗНАК    ЗНАК, превключващ към друг слой на обвивката (остарял "
"начин\n"
"                 за управление на задачите под System V)\n"
"\n"

#: src/stty.c:611
msgid " * werase CHAR   CHAR will erase the last word typed\n"
msgstr " • werase ЗНАК   ЗНАК, изтриващ последната въведена дума\n"

#: src/stty.c:615
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
msgstr ""
"\n"
"Специални настройки:\n"
"  N             задаване на скорост за входа и изхода от N бода\n"

#: src/stty.c:621
msgid ""
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
" • cols N        задаване, че терминалът има N стълба, към ядрото\n"
" • columns N     същото като „cols N“\n"

#: src/stty.c:626
#, c-format
msgid ""
" * [-]drain      wait for transmission before applying settings (%s by "
"default)\n"
msgstr ""
" • [-]drain      изчакване за предаване на данни, преди прилагането на\n"
"                 настройките (стандартно е „%s“)\n"

#: src/stty.c:628
msgid "on"
msgstr "вкл."

#: src/stty.c:628
msgid "off"
msgstr "изкл."

#: src/stty.c:629
msgid "   ispeed N      set the input speed to N\n"
msgstr "   ispeed N      скоростта на входа да е N\n"

#: src/stty.c:633
msgid " * line N        use line discipline N\n"
msgstr " • line N        дисциплината на реда да е N\n"

#: src/stty.c:637
msgid ""
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"   min N         с „-icanon“ — задаване на поне N знака за завършено четене\n"
"   ospeed N      задаване на скорост на изхода N бода\n"

#: src/stty.c:642
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
msgstr ""
" • rows N        задаване, че терминалът има N реда, към ядрото\n"
" • size          извеждане на броя редове и стълбове според ядрото\n"

#: src/stty.c:647
msgid ""
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
"   speed         извеждане на скоростта на терминала\n"
"   time N        с „-icanon“ — изтичане на времето за четене при изминаване\n"
"                 на N десети от секундата\n"

#: src/stty.c:651
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
msgstr ""
"\n"
"Управляващи настройки:\n"
"   [-]clocal     забраняване на сигналите за управление на модем\n"
"   [-]cread      позволяване на получаването на входа\n"

#: src/stty.c:658
msgid " * [-]crtscts    enable RTS/CTS handshaking\n"
msgstr " • [-]crtscts    включване на ръкостискане по „RTS/CTS“\n"

#: src/stty.c:663
msgid " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
msgstr " • [-]cdtrdsr    включване на ръкостискане по „DTR/DSR“\n"

#: src/stty.c:667
msgid "   csN           set character size to N bits, N in [5..8]\n"
msgstr "   csN           задаване на размер на знака от N бита, N e 5/6/7/8\n"

#: src/stty.c:670
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""
"   [-]cstopb     използване на два стоп-бита на знак (един с „-“)\n"
"   [-]hup        изпращане на сигнал „hangup“, когато и последният процес\n"
"                 затвори това устройство-телетип (tty)\n"
"   [-]hupcl      същото като „[-]hup“\n"
"   [-]parenb     генериране на бит за четност на изхода и очакване на\n"
"                 такъв на входа\n"
"   [-]parodd     задаване на текова четност (четна с „-“)\n"

#: src/stty.c:678
msgid " * [-]cmspar     use \"stick\" (mark/space) parity\n"
msgstr ""
" • [-]cmspar     псевдо проверка по четност (stick parity) — битът е винаги\n"
"                 1 (mark) или 0 (space)\n"

#: src/stty.c:682
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
"   [-]ignpar     ignore characters with parity errors\n"
msgstr ""
"\n"
"Настройки на входа:\n"
"   [-]brkint     прекъсванията да довеждат до сигнал за прекъсване\n"
"   [-]icrnl      заместване на знаците за връщане на курсора със\n"
"                 знаци за нов ред\n"
"   [-]ignbrk     пренебрегване на знаците за прекъсване\n"
"   [-]igncr      пренебрегване на знаците за връщане на каретката\n"
"   [-]ignpar     пренебрегване на знаците с грешка на четността\n"

#: src/stty.c:692
msgid ""
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
msgstr ""
" • [-]imaxbel    звуков сигнал без изчистване на пълен входен буфер при нов "
"знак\n"

#: src/stty.c:696
msgid ""
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"   [-]inlcr      заместване на знаците за нов ред със\n"
"                 знаци за връщане на каретката\n"
"   [-]inpck      включване на проверка за четността на входа\n"
"   [-]istrip     изчистване на старшия (8-мия) бит от входните знаци\n"

#: src/stty.c:702
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " • [-]iutf8      приемане, че входните знаци са кодирани в UTF-8\n"

#: src/stty.c:707
msgid " * [-]iuclc      translate uppercase characters to lowercase\n"
msgstr " • [-]iuclc      заместване на главните знаци с малки\n"

#: src/stty.c:712
msgid ""
" * [-]ixany      let any character restart output, not only start character\n"
msgstr ""
" • [-]ixany      всеки знак да рестартира извеждането (не само знакът за "
"старт)\n"

#: src/stty.c:716
msgid ""
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
"   [-]ixoff      позволяване на изпращането на знаци за старт/стоп\n"
"   [-]ixon       позволяване на управление на потока XON/XOFF\n"
"   [-]parmrk     маркиране на грешките по четност (с последователност "
"255-0)\n"
"   [-]tandem     същото като „[-]ixoff“\n"

#: src/stty.c:722
msgid ""
"\n"
"Output settings:\n"
msgstr ""
"\n"
"Настройки на изхода:\n"

#: src/stty.c:727
msgid " * bsN           backspace delay style, N in [0..1]\n"
msgstr " • bsN           забавяне на обратното триене, N е 0/1\n"

#: src/stty.c:732
msgid " * crN           carriage return delay style, N in [0..3]\n"
msgstr " • crN           забавяне на връщането на каретката, N е 0/1/2/3\n"

#: src/stty.c:737
msgid " * ffN           form feed delay style, N in [0..1]\n"
msgstr " • ffN           забавяне при подаването на формуляра, N е 0/1\n"

#: src/stty.c:742
msgid " * nlN           newline delay style, N in [0..1]\n"
msgstr " • nlN           забавяне на новия ред, N е 0/1\n"

#: src/stty.c:747
msgid " * [-]ocrnl      translate carriage return to newline\n"
msgstr " • [-]ocrnl      заместване на връщането на каретката с нов ред\n"

#: src/stty.c:752
msgid ""
" * [-]ofdel      use delete characters for fill instead of NUL characters\n"
msgstr " • [-]ofdel      запълване с изтриващи знаци, а не с нулеви байтове\n"

#: src/stty.c:757
msgid ""
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
msgstr ""
" • [-]ofill      забавяне чрез извеждане на запълващи знаци, а не с таймери\n"

#: src/stty.c:762
msgid " * [-]olcuc      translate lowercase characters to uppercase\n"
msgstr " • [-]olcuc      заместване на малките букви с главни\n"

#: src/stty.c:767
msgid " * [-]onlcr      translate newline to carriage return-newline\n"
msgstr ""
" • [-]onlcr      заместване на новите редове с комбинация от\n"
"                 връщане на каретката и нов ред\n"

#: src/stty.c:772
msgid " * [-]onlret     newline performs a carriage return\n"
msgstr " • [-]onlret     знакът за нов ред извежда връщане на каретката\n"

#: src/stty.c:777
msgid " * [-]onocr      do not print carriage returns in the first column\n"
msgstr ""
" • [-]onocr      без извеждане на връщането на каретката в първата колона\n"

#: src/stty.c:781
msgid "   [-]opost      postprocess output\n"
msgstr "   [-]opost      допълнителна, последваща обработка на изхода\n"

#: src/stty.c:785
msgid ""
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
msgstr ""
" • tabN          забавяне при вертикална табулация, N е 0/1/2/3\n"
" • tabs          същото като „tab0“\n"
" • -tabs         същото като „tab3“\n"

#: src/stty.c:792
msgid " * vtN           vertical tab delay style, N in [0..1]\n"
msgstr " • vtN           забавяне при вертикална табулация, N е 0/1\n"

#: src/stty.c:796
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
msgstr ""
"\n"
"Локални настройки:\n"
"   [-]crterase   локално извеждане на изтриващите знаци като\n"
"                 backspace-space-backspace\n"

#: src/stty.c:802
msgid ""
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
" • crtkill       заличаване на реда според настройките „echoprt“ и „echoe“\n"
" • -crtkill      заличаване на реда според настройките „echoctl“ и „echok“\n"

#: src/stty.c:808
msgid " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
msgstr ""
" • [-]ctlecho    локално извеждане на контролните знаци, екранирани с "
"„шапки“\n"
"                 (напр. „^c“)\n"

#: src/stty.c:812
msgid "   [-]echo       echo input characters\n"
msgstr "   [-]echo       локално извеждане на входните знаци\n"

#: src/stty.c:816
msgid " * [-]echoctl    same as [-]ctlecho\n"
msgstr " • [-]echoctl    същото като „[-]ctlecho“\n"

#: src/stty.c:820
msgid ""
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
"   [-]echoe      същото като „[-]crterase“\n"
"   [-]echok      локално извеждане на нов ред след заличаващ знак\n"

#: src/stty.c:825
msgid " * [-]echoke     same as [-]crtkill\n"
msgstr " • [-]echoke     същото като „[-]crtkill“\n"

#: src/stty.c:829
msgid "   [-]echonl     echo newline even if not echoing other characters\n"
msgstr ""
"   [-]echonl     локално извеждане на новите редове, дори когато другите "
"знаци\n"
"                 не се извеждат\n"

#: src/stty.c:833
msgid ""
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
msgstr ""
" • [-]echoprt    локално извеждане между „\\“ и „/“ на изтритите знаци\n"

#: src/stty.c:838
msgid " * [-]extproc    enable \"LINEMODE\"; useful with high latency links\n"
msgstr ""
" • [-]extproc    включване на поредов режим „LINEMODE“ — полезно при връзки\n"
"                 с висока латентност\n"

#: src/stty.c:843
msgid " * [-]flusho     discard output\n"
msgstr " • [-]flusho     изхвърляне на изхода\n"

#: src/stty.c:847
#, c-format
msgid ""
"   [-]icanon     enable special characters: %s\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"   [-]icanon     включване на управляващите знаци: %s\n"
"   [-]iexten     включване на управляващите знаци извън POSIX\n"

#: src/stty.c:858
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
msgstr ""
"   [-]isig       позволяване на управляващите знаци за\n"
"                 „interrupt“, „quit“ и „suspend“\n"
"   [-]noflsh     без изчистване на буферите след знаците за\n"
"                 „interrupt“ и „quit“\n"

#: src/stty.c:863
msgid " * [-]prterase   same as [-]echoprt\n"
msgstr " • [-]prterase   същото като „[-]echoprt“\n"

#: src/stty.c:868
msgid ""
" * [-]tostop     stop background jobs that try to write to the terminal\n"
msgstr ""
" • [-]tostop     спиране на фоновите задачи, които извеждат информация\n"
"                 на терминала\n"

#: src/stty.c:873
msgid ""
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""
" • [-]xcase      с „icanon“ — заместване на главните букви с екранирани\n"
"                 с „\\“ малки букви\n"

#: src/stty.c:877
msgid ""
"\n"
"Combination settings:\n"
msgstr ""
"\n"
"Комбинирани настройки:\n"

#: src/stty.c:882
msgid " * [-]LCASE      same as [-]lcase\n"
msgstr " • [-]LCASE      същото като „[-]lcase“\n"

#: src/stty.c:886
msgid ""
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"   cbreak        същото като „-icanon“\n"
"   -cbreak       същото като „icanon“\n"

#: src/stty.c:890
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
msgstr ""
"   cooked        същото като „brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon“.  Управляващите знаци „eof“ и „eol“ са със\n"
"                 стандартното си значение\n"
"   -cooked       същото като „raw“\n"

#: src/stty.c:895
#, c-format
msgid "   crt           same as %s\n"
msgstr "   crt           същото като „%s“\n"

#: src/stty.c:905
#, c-format
msgid ""
"   dec           same as %s intr ^c erase 0177\n"
"                 kill ^u\n"
msgstr ""
"   dec           същото като „%s intr ^c erase 0177\n"
"                 kill ^u“\n"

#: src/stty.c:920
msgid " * [-]decctlq    same as [-]ixany\n"
msgstr " • [-]decctlq    същото като „[-]ixany“\n"

#: src/stty.c:924
msgid ""
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
"   -evenp        same as -parenb cs8\n"
msgstr ""
"   ek            изчистване на всички знаци до стандартните им стойности\n"
"   evenp         същото като „parenb -parodd cs7“\n"
"   -evenp        същото като „-parenb cs8“\n"

#: src/stty.c:930
msgid " * [-]lcase      same as xcase iuclc olcuc\n"
msgstr " • [-]lcase      същото като „xcase iuclc olcuc“\n"

#: src/stty.c:934
msgid ""
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
msgstr ""
"   litout        същото като „-parenb -istrip -opost cs8“\n"
"   -litout       същото като „parenb istrip opost cs7“\n"

#: src/stty.c:938
#, c-format
msgid ""
"   nl            same as %s\n"
"   -nl           same as %s\n"
msgstr ""
"   nl            същото като „%s“\n"
"   -nl           същото като „%s“\n"

#: src/stty.c:956
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"   oddp          същото като „parenb parodd cs7“\n"
"   -oddp         същото като „-parenb cs8“\n"
"   [-]parity     същото като „[-]evenp“\n"
"   pass8         същото като „-parenb -istrip cs8“\n"
"   -pass8        същото като „parenb istrip cs7“\n"

#: src/stty.c:963
#, c-format
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"   raw           същото като „-ignbrk -brkint -ignpar -parmrk -inpck -"
"istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0“\n"
"   -raw          същото като „cooked“\n"

#: src/stty.c:982
#, c-format
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 all special characters to their default values\n"
msgstr ""
"   sane          същото като „cread -ignbrk brkint -icrnl -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s“\n"
"                 всички управляващи знаци запазват стандартната си стойност\n"

#: src/stty.c:1068
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"Управление на терминалната линия (tty) свързана на стандартния изход.  Без\n"
"аргументи извежда скоростта в бодове, дисциплината на линията и различията "
"от\n"
"„stty sane“.  В настройките ЗНАците се задават дословно или екранирани — "
"„^c“,\n"
"„0x37“, „0177“ или „127“.  Специалните стойности „^-“ и „undef“ се "
"използват,\n"
"за да сe изключат съответните управляващи знаци.\n"

#: src/stty.c:1097
#, c-format
msgid "missing argument to %s"
msgstr "липсва аргумент за %s"

#: src/stty.c:1140 src/stty.c:1258
#, c-format
msgid "invalid argument %s"
msgstr "неправилен аргумент %s"

#: src/stty.c:1192
#, c-format
msgid "%s: error setting %s"
msgstr "%s: грешка при задаване на %s"

#: src/stty.c:1234
#, c-format
msgid "invalid line discipline %s"
msgstr "неправилна дисциплина на редовете: %s"

#: src/stty.c:1326
msgid "only one device may be specified"
msgstr "може да се посочва само едно устройство"

#: src/stty.c:1360
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr "опциите за четим от хора и четим от stty стилове са несъвместими"

#: src/stty.c:1366
msgid "when specifying an output style, modes may not be set"
msgstr "при посочване на изходен стил не може да се настройват режими"

#: src/stty.c:1384
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: не може наново да се зададе режим без блокиране"

#: src/stty.c:1447
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: не може да се осъществят всички поискани операции"

#: src/stty.c:1792
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: няма информация за размера на това устройство"

#: src/stty.c:2321
msgid "invalid integer argument"
msgstr "неправилен целочислен аргумент"

#. This is a proper name. See the gettext manual, section Names.
#: src/sum.c:38
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#: src/sum.c:63
msgid "Print checksum and block counts for each FILE.\n"
msgstr "Извеждане на контролната сума и броя блокове за всеки ФАЙЛ.\n"

#: src/sum.c:69
msgid ""
"\n"
"  -r              use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"\n"
"  -r             използване на алгоритъма от BSD, блоковете са по 1K\n"
"  -s, --sysv     използване на алгоритъма от System V, блоковете са по 512B\n"

#: src/sync.c:64
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Употреба: %s [ОПЦИЯ] [ФАЙЛ]…\n"

#: src/sync.c:65
msgid ""
"Synchronize cached writes to persistent storage\n"
"\n"
"If one or more files are specified, sync only them,\n"
"or their containing file systems.\n"
"\n"
msgstr ""
"Синхронизиране на кешираните записи с устройствата за постоянно съхранение\n"
"\n"
"Ако са указани файлове, се синхронизират само те или само файловите системи, "
"на\n"
"които принадлежат.\n"
"\n"

#: src/sync.c:73
msgid "  -d, --data             sync only file data, no unneeded metadata\n"
msgstr ""
"  -d, --data             синхронизиране само на данните, а не и на "
"метаданните\n"

#: src/sync.c:76
msgid "  -f, --file-system      sync the file systems that contain the files\n"
msgstr ""
"  -f, --file-system      синхронизиране на файловите системи на файловете\n"

#: src/sync.c:115
#, c-format
msgid "error opening %s"
msgstr "грешка при отварянето на „%s“"

#: src/sync.c:126
#, c-format
msgid "couldn't reset non-blocking mode %s"
msgstr "режимът без блокиране не може да се зададе наново „%s“"

#: src/sync.c:157
#, c-format
msgid "error syncing %s"
msgstr "грешка при синхронизирането на „%s“"

#: src/sync.c:215
msgid "cannot specify both --data and --file-system"
msgstr "опциите „--data“ и „--file-system“ са несъвместими"

#: src/sync.c:219
msgid "--data needs at least one argument"
msgstr "опцията „--data“ изисква поне един аргумент"

#: src/system.h:347
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"ПРЕДУПРЕЖДЕНИЕ: Обвивката ви може да има своя собствена версия на „%s“.\n"
"Тя обикновено се предпочита пред версията, описана тук.  Проверете\n"
"документацията на използваната от вас обвивка за поддържаните от нея опции.\n"

#: src/system.h:353
msgid "      --help     display this help and exit\n"
msgstr "      --help     извеждане на тази помощ и изход\n"

#: src/system.h:355
msgid "      --version  output version information and exit\n"
msgstr "      --version  извеждане на версията и изход\n"

#: src/system.h:583
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"Ако ФАЙЛ няма или е „-“, се чете от стандартния вход.\n"

#: src/system.h:590
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"\n"
"Аргументите, които са задължителни за дългите опции, са задължителни и за "
"късите\n"
"варианти.\n"

#: src/system.h:598
msgid ""
"\n"
"The SIZE argument is an integer and optional unit (example: 10K is "
"10*1024).\n"
"Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"РАЗМЕРът може да бъде следван от цяло число и незадължителен суфикс-"
"множител.\n"
"Напр. 10K≡10×1024\n"
"Единиците „K“(≡1024), „M“(≡1024×1024), „G“, „T“, „P“, „E“, „Z“, „Y“ са за\n"
"последователните степени на 1024, а вариантите с B — „KB“(≡1000),\n"
"„M“(≡1000×1000), „GB“, „TB“, „PB“, „EB“, „ZB“, „YB“ са за степените на "
"1000.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"

#: src/system.h:608
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"Извеждане на стойностите в единици според първия зададен РАЗМЕР измежду\n"
"последователно:\n"
"  ⁃ опцията „--block-size;\n"
"  ⁃ стойността на „%s_BLOCK_SIZE“ (променлива на средата);\n"
"  ⁃ стойността на „BLOCK_SIZE“ (променлива на средата);\n"
"  ⁃ стойността на „BLOCKSIZE“ (променлива на средата).\n"
"Иначе се използват единици от по 1024 байта (или 512, ако е зададена\n"
"променливата „POSIXLY_CORRECT“).\n"

#: src/system.h:618
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"Суфиксът за резервни копия е „~“, освен при изрично задаване чрез „--"
"suffix“\n"
"или с променливата на средата „SIMPLE_BACKUP_SUFFIX“.  Методът за управление "
"на\n"
"версиите може да се посочва с „--backup“ или с променливата "
"„VERSION_CONTROL“.\n"
"Допустимите стойности са:\n"

#: src/system.h:625
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  ⁃ none, off       без резервни копия (освен при --backup)\n"
"  ⁃ numbered, t     номерирани резервни копия\n"
"  ⁃ existing, nil   номерирани, ако вече има номерирани, иначе — прости\n"
"  ⁃ simple, never   винаги да се правят прости резервни копия\n"

#: src/system.h:655
#, c-format
msgid ""
"\n"
"%s online help: <%s>\n"
msgstr ""
"\n"
"Помощ за „%s“: <%s>\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <https://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at https://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:666
msgid "Report any translation bugs to <https://translationproject.org/team/>\n"
msgstr ""
"Докладвайте за грешки и проблеми с превода на <https://translationproject."
"org/team/bg.html>\n"

#: src/system.h:669
#, c-format
msgid "Full documentation <%s%s>\n"
msgstr "Пълна документация <%s%s>\n"

#: src/system.h:671
#, c-format
msgid "or available locally via: info '(coreutils) %s%s'\n"
msgstr ""
"достъпна локално чрез командата:\n"
"\n"
"  info '(coreutils) %s%s'\n"

#: src/system.h:682
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "За повече информация изпълнете „%s --help“.\n"

#: src/system.h:726
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: Цикъл в директориите.\n"
"Това почти със сигурност означава, че имате повредена файлова система.\n"
"ИЗВЕСТЕТЕ ВАШИЯ СИСТЕМЕН АДМИНИСТРАТОР.\n"
"Следната директория е част от цикъла:\n"
"  „%s“\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:136
msgid "Write each FILE to standard output, last line first.\n"
msgstr ""
"Извеждане в обратен ред на редовете от всеки ФАЙЛ на стандартния изход.\n"

#: src/tac.c:143
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             прикрепяне на разделителя преди, а не след\n"
"  -r, --regex              интерпретиране на разделителя като регулярен "
"израз\n"
"  -s, --separator=НИЗ      за разделител да се ползва НИЗът, а не знакът за "
"нов ред\n"

#: src/tac.c:223 src/tac.c:233 src/tac.c:343
#, c-format
msgid "%s: seek failed"
msgstr "%s: неуспешно позициониране със „seek“ във файл"

#: src/tac.c:276
msgid "record too large"
msgstr "твърде дълъг запис"

#: src/tac.c:458
#, c-format
msgid "failed to create temporary file in %s"
msgstr "неуспешно създаване на временен файл в „%s“"

#: src/tac.c:466
#, c-format
msgid "failed to open %s for writing"
msgstr "„%s“ не може да се отвори за запис"

#: src/tac.c:484
#, c-format
msgid "failed to rewind stream for %s"
msgstr "неуспешно пренавиване на потока за „%s“"

#: src/tac.c:521 src/tac.c:533
#, c-format
msgid "%s: write error"
msgstr "%s: грешка при запис"

#: src/tac.c:582
#, c-format
msgid "failed to open %s for reading"
msgstr "„%s“ не може да се отвори за четене"

#: src/tac.c:650
msgid "separator cannot be empty"
msgstr "разделителят не може да бъде празен"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:78
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:269
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"Извеждане на последните %d реда от всеки ФАЙЛ на стандартния изход.\n"
"Когато има повече от един ФАЙЛ, пред всеки се поставя заглавие с името му.\n"

#: src/tail.c:277
msgid ""
"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
"                             output starting with byte NUM of each file\n"
msgstr ""
"  -c, --bytes=[+]БАЙТ      извеждане на този брой от последните БАЙТове.\n"
"                           „+“ води до извеждане на съдържанието на всеки "
"файл\n"
"                           след този БАЙТ\n"

#: src/tail.c:281
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                             an absent option argument means 'descriptor'\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           извеждане на добавяните данни към файла.  "
"Липсата\n"
"                           на аргумент е еднозначна с „--follow=descriptor“\n"
"  -F                       същото като „--follow=name --retry“\n"

#: src/tail.c:287
#, c-format
msgid ""
"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last "
"%d;\n"
"                             or use -n +NUM to output starting with line "
"NUM\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                             changed size after N (default %d) iterations\n"
"                             to see if it has been unlinked or renamed\n"
"                             (this is the usual case of rotated log files);\n"
"                             with inotify, this option is rarely useful\n"
msgstr ""
"  -n, --lines=[+]РЕД       извеждане на този брой от последните РЕДове "
"вместо %d\n"
"                            „+“ води до извеждане на съдържанието на всеки "
"файл\n"
"                           след този РЕД\n"
"      --max-unchanged-stats=N\n"
"                           при ползването на „--follow=name“ всеки ФАЙЛ, "
"който\n"
"                           не си е сменил размера след N (стандартно %d)\n"
"                           итерации, се отваря наново за да се провери, дали "
"не\n"
"                           е бил изтрит или преименуван (което е обичайно "
"при\n"
"                           подмяна на журналните файлове).  При наличието "
"на\n"
"                           „inotify“ рядко се налага ползвате тази опция\n"

#: src/tail.c:300
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file if it is inaccessible\n"
msgstr ""
"      --pid=ИД_ПР          заедно с „-f“ — „tail“ приключва след края на "
"командата\n"
"                           с този ИДентификатор_на_ПРОЦЕС\n"
"  -q, --quiet, --silent    без извеждане на заглавия с имената на файловете\n"
"      --retry              продължаване с опитите да се отворят и "
"недостъпните\n"
"                           файлове\n"

#: src/tail.c:305
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations;\n"
"                             with inotify and --pid=P, check process P at\n"
"                             least once every N seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=N   с „-f“ се изчаква приблизително N секунди "
"(стандартно\n"
"                           е 1.0) между итерациите.  При ползване на "
"„inotify“ и\n"
"                           „--pid=ПРОЦЕС“ — ПРОЦЕСЪТ се проверява поне "
"веднъж на\n"
"                           всеки N секунди\n"
"  -v, --verbose            заглавията винаги да съдържат имената на "
"файловете\n"

#: src/tail.c:317
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
msgstr ""
"\n"
"БРОят може да бъде следван от следните суфикси-множители:\n"
"b≡512, kB≡1000, K≡1024, MB≡1000×1000, M≡1024×1024,\n"
"GB≡1000×1000×1000, G≡1024×1024×1024 и т.н. за „T“, „P“, „E“, „Z“ и „Y“.\n"
"Приемат се и двоични префикси: KiB≡K, MiB≡M и т.н.\n"

#: src/tail.c:325
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"При ползването на „--follow“ („-f“), „tail“ следва файловия дескриптор — "
"дори\n"
"файлът да бъде преименуван или преместен, командата ще го следи.  "
"Стандартното\n"
"поведение не е подходящо, когато важното е името на файла, а не дескриптора\n"
"(примерно при редовната подмяна на журналните файлове).  В такива случаи\n"
"ползвайте „--follow=name“.  Така се следи файлът с точно това име, без\n"
"преименуването, изтриването и създаването да пречат.\n"

#: src/tail.c:416
#, c-format
msgid "closing %s (fd=%d)"
msgstr "Затваряне на „%s“ (файлов дескриптор=%d)"

#: src/tail.c:515
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: не може да се отиде на отместване „%s“ спрямо края на файла"

#: src/tail.c:951
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr ""
"местоположението на „%s“ не може да се определи, ще се ползва периодична "
"проверка"

#: src/tail.c:1007
#, c-format
msgid "%s has been replaced with an untailable symbolic link"
msgstr ""
"„%s“ е заменен със символна връзка, с която командата „tail“ не може да "
"работи"

#: src/tail.c:1022
#, c-format
msgid "%s has become inaccessible"
msgstr "„%s“ е станал недостъпен"

#: src/tail.c:1040
#, c-format
msgid "%s has been replaced with an untailable file%s"
msgstr "„%s“ е заменен с файл, с който командата „tail“ не може да работи%s"

#: src/tail.c:1042 src/tail.c:2048
msgid "; giving up on this name"
msgstr ", името няма да се обработва повече"

#: src/tail.c:1048
#, c-format
msgid "%s has been replaced with an untailable remote file"
msgstr ""
"„%s“ е заменен с отдалечен файл, с който командата „tail“ не може да работи"

#: src/tail.c:1069
#, c-format
msgid "%s has become accessible"
msgstr "„%s“ е станал достъпен"

#: src/tail.c:1081
#, c-format
msgid "%s has appeared;  following new file"
msgstr "„%s“ се е появил — следва се краят на новия файл"

#: src/tail.c:1091
#, c-format
msgid "%s has been replaced;  following new file"
msgstr "„%s“ е заменен — следва се краят на новия файл"

#: src/tail.c:1206
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s: не може да се смени режимът към такъв без блокиране"

#: src/tail.c:1252 src/tail.c:1427
#, c-format
msgid "%s: file truncated"
msgstr "%s: файлът бе отсечен"

#: src/tail.c:1286 src/tail.c:1628
#, c-format
msgid "no files remaining"
msgstr "няма повече файлове"

#: src/tail.c:1522
#, c-format
msgid "cannot watch parent directory of %s"
msgstr ""
"текущата родителска директория не може да се наблюдава (в момента е „%s“)"

#: src/tail.c:1525 src/tail.c:1542 src/tail.c:1752
#, c-format
msgid "inotify resources exhausted"
msgstr "ресурсите за „inotify“ са изчерпани"

#: src/tail.c:1546 src/tail.c:1760
#, c-format
msgid "cannot watch %s"
msgstr "„%s“ не може да се наблюдава"

#: src/tail.c:1595
#, c-format
msgid "%s was replaced"
msgstr "„%s“ бе заменен"

#: src/tail.c:1667
msgid "error waiting for inotify and output events"
msgstr "грешка при изчакването на изходни събития и такива от „inotify“"

#: src/tail.c:1695
msgid "error reading inotify event"
msgstr "грешка при четене на събития от „inotify“"

#: src/tail.c:1714
#, c-format
msgid "directory containing watched file was removed"
msgstr "директория с наблюдавани файлове е премахната"

#: src/tail.c:2046
#, c-format
msgid "%s: cannot follow end of this type of file%s"
msgstr "%s: краят на този вид файлове не може да се следва%s"

#: src/tail.c:2227
msgid "invalid maximum number of unchanged stats between opens"
msgstr ""
"неправилен максимален брой достъпвания без промяна на информацията за достъп"

#: src/tail.c:2235
msgid "invalid PID"
msgstr "неправилен номер на процес"

#: src/tail.c:2251
#, c-format
msgid "invalid number of seconds: %s"
msgstr "неправилен брой секунди: %s"

#: src/tail.c:2270
#, c-format
msgid "option used in invalid context -- %c"
msgstr "опцията е използвана в неправилен контекст — „%c“"

#: src/tail.c:2282
#, c-format
msgid "warning: --retry ignored; --retry is useful only when following"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--retry“ се пренебрегва — тя важи само при следване"

#: src/tail.c:2286
#, c-format
msgid "warning: --retry only effective for the initial open"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: опцията „--retry“ важи само при първоначалното отваряне"

#: src/tail.c:2291
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: номерът на процес се пренебрегва, опцията „--pid=PID“ важи "
"само при следване"

#: src/tail.c:2294
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "ПРЕДУПРЕЖДЕНИЕ: опцията „--pid=PID“ не се поддържа на тази система"

#: src/tail.c:2400
#, c-format
msgid "cannot follow %s by name"
msgstr "„%s“ не може да се следва според името"

#: src/tail.c:2415
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "ПРЕДУПРЕЖДЕНИЕ: безкрайното следване на стандартния вход е безполезно"

#: src/tail.c:2512
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "„inotify“ липсва, ще се ползва периодична проверка"

#: src/tee.c:88
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"Копиране на стандартния изход във всеки от ФАЙЛовете, а също и на "
"стандартния изход.\n"
"\n"
"  -a, --append              добавяне (а не заместване) към посочените "
"ФАЙЛове\n"
"  -i, --ignore-interrupts   заглушаване на сигналите за прекъсване\n"

#: src/tee.c:94
msgid ""
"  -p                        diagnose errors writing to non pipes\n"
"      --output-error[=MODE]   set behavior on write error.  See MODE below\n"
msgstr ""
"  -p                        диагностициране на грешките при запис в обект, "
"който\n"
"                            не е програмен канал\n"
"      --output-error[=РЕЖИМ]\n"
"                            поведение при грешка при запис.  Вж. „РЕЖИМ“\n"

#: src/tee.c:100
msgid ""
"\n"
"MODE determines behavior with write errors on the outputs:\n"
"  'warn'         diagnose errors writing to any output\n"
"  'warn-nopipe'  diagnose errors writing to any output not a pipe\n"
"  'exit'         exit on error writing to any output\n"
"  'exit-nopipe'  exit on error writing to any output not a pipe\n"
"The default MODE for the -p option is 'warn-nopipe'.\n"
"The default operation when --output-error is not specified, is to\n"
"exit immediately on error writing to a pipe, and diagnose errors\n"
"writing to non pipe outputs.\n"
msgstr ""
"\n"
"РЕЖИМът определя поведението при грешка при извеждане на изхода:\n"
"  ⁃ warn         извеждане на причината за грешката във всички ситуации\n"
"  ⁃ warn-nopipe  извеждане на причината за грешката, освен при писане в "
"канал\n"
"  ⁃ exit         изход при грешка във всички ситуации\n"
"  ⁃ exit-nopipe  изход при грешка, освен при писане в програмен канал\n"
"Стандартният РЕЖИМ при опция „-p“ е „warn-nopipe“.\n"
"Стандартното действие, когато не е зададена опцията „--output-error“, е\n"
"незабавен изход при писане към програмен канал, а иначе е да изведе\n"
"съобщение с обяснение за грешката.\n"

#: src/test.c:126
#, c-format
msgid "missing argument after %s"
msgstr "липсва аргумент след „%s“"

#: src/test.c:162
#, c-format
msgid "invalid integer %s"
msgstr "неправилно цяло число „%s“"

#: src/test.c:244
#, c-format
msgid "%s expected"
msgstr "очаква се „%s“"

#: src/test.c:247
#, c-format
msgid "%s expected, found %s"
msgstr "очаква се „%s“, а е получено „%s“"

#: src/test.c:328
msgid "-nt does not accept -l"
msgstr "опцията „-nt“ е несъвместима с „-l“"

#: src/test.c:341
msgid "-ef does not accept -l"
msgstr "опцията „-ef“ е несъвместима с „-l“"

#: src/test.c:357
msgid "-ot does not accept -l"
msgstr "опцията „-ot“ е несъвместима с „-l“"

#: src/test.c:366
#, c-format
msgid "%s: unknown binary operator"
msgstr "%s: непознат бинарен оператор"

#: src/test.c:396
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очаква се унарен оператор"

#: src/test.c:632
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очаква се бинарен оператор"

#: src/test.c:690
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"Употреба: test ИЗРАЗ\n"
"     или: test\n"
"     или: [ ИЗРАЗ ]\n"
"     или: [ ]\n"
"     или: [ ОПЦИЯ\n"

#: src/test.c:697
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr ""
"Изход с код-състояние, определен от ИЗРАЗ.\n"
"\n"

#: src/test.c:703
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"Ако ИЗРАЗът е изпуснат, се приема лъжа.  Иначе ИЗРАЗ е истина и лъжа и "
"определя\n"
"кода на завършване.  Той може да бъде:\n"

#: src/test.c:708
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( ИЗРАЗ )                    ИЗРАЗът е истина\n"
"  ! ИЗРАЗ                      ИЗРАЗът е лъжа\n"
"  ИЗРАЗ_1 -a ИЗРАЗ_2           както ИЗРАЗ_1, така и ИЗРАЗ_2 са истина\n"
"  ИЗРАЗ_1 -o ИЗРАЗ_2           поне един от ИЗРАЗ_1 и ИЗРАЗ_2 е истина\n"

#: src/test.c:715
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  [-n] НИЗ             НИЗът е с ненулева дължина\n"
"  НИЗ                  същото като „-n НИЗ“\n"
"  -z НИЗ               НИЗът е с дължина нула\n"
"  НИЗ_1 = НИЗ_2        низовете са еднакви\n"
"  НИЗ_1 != НИЗ_2       низовете не са еднакви\n"

#: src/test.c:723
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  ЦЯЛО_1 -eq ЦЯЛО_2       ЦЯЛО_1 е равно на ЦЯЛО_2\n"
"  ЦЯЛО_1 -ge ЦЯЛО_2       ЦЯЛО_1 е по-голямо или равно на ЦЯЛО_2\n"
"  ЦЯЛО_1 -gt ЦЯЛО_2       ЦЯЛО_1 е по-голямо от ЦЯЛО_2\n"
"  ЦЯЛО_1 -le ЦЯЛО_2       ЦЯЛО_1 е по-малко или равно на ЦЯЛО_2\n"
"  ЦЯЛО_1 -lt ЦЯЛО_2       ЦЯЛО_1 е по-малко от ЦЯЛО_2\n"
"  ЦЯЛО_1 -ne ЦЯЛО_2       ЦЯЛО_1 е различно от ЦЯЛО_2\n"

#: src/test.c:732
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  ФАЙЛ_1 -ef ФАЙЛ_2   ФАЙЛ_1 и ФАЙЛ_2 имат равни номера на устройство и i-"
"възел\n"
"  ФАЙЛ_1 -nt ФАЙЛ_2   ФАЙЛ_1 е по-нов (според датата на изменение) от "
"ФАЙЛ_2\n"
"  ФАЙЛ_1 -ot ФАЙЛ_2   ФАЙЛ_1 е по-стар (според датата на изменение) от "
"ФАЙЛ_2\n"

#: src/test.c:738
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b ФАЙЛ     ФАЙЛът съществува и е специален блоков файл\n"
"  -c ФАЙЛ     ФАЙЛът съществува и е специален символен файл\n"
"  -d ФАЙЛ     ФАЙЛът съществува и е директория\n"
"  -e ФАЙЛ     ФАЙЛът съществува\n"

#: src/test.c:745
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f ФАЙЛ     ФАЙЛът съществува и е обикновен файл\n"
"  -g ФАЙЛ     ФАЙЛът съществува и при изпълнение задава група\n"
"  -h ФАЙЛ     ФАЙЛът съществува и е символна връзка (същото като „-L“)\n"
"  -G ФАЙЛ     ФАЙЛът съществува и се притежава от действащата група\n"
"  -k ФАЙЛ     ФАЙЛът съществува и е с лепкав бит\n"

#: src/test.c:752
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -N FILE     FILE exists and has been modified since it was last read\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and read permission is granted\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L ФАЙЛ     ФАЙЛът съществува и е символна връзка (същото като „-h“)\n"
"  -N ФАЙЛ     ФАЙЛът съществува и е променен след последното четене от него\n"
"  -O ФАЙЛ     ФАЙЛът съществува и се притежава от действащия потребител\n"
"  -p ФАЙЛ     ФАЙЛът съществува и е именуван канал\n"
"  -r ФАЙЛ     ФАЙЛът съществува и е достъпен за четене\n"
"  -s ФАЙЛ     ФАЙЛът съществува и има ненулев размер\n"

#: src/test.c:760
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and write permission is granted\n"
"  -x FILE     FILE exists and execute (or search) permission is granted\n"
msgstr ""
"  -S ФАЙЛ     ФАЙЛът съществува и е гнездо\n"
"  -t [FD]     файловият дескриптор FD е отворен на терминал\n"
"  -u ФАЙЛ     ФАЙЛът съществува и при изпълнение задава потребител\n"
"  -w ФАЙЛ     ФАЙЛът съществува и е достъпен за запис\n"
"  -x ФАЙЛ     ФАЙЛът съществува и е изпълним файл (при директория:\n"
"              може да се търси)\n"

#: src/test.c:767
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"Освен при „-h“ и -„L“ всички файлови проверки се правят към сочените от\n"
"символни връзки файлове.  При повечето обвивки „(“, „)“ трябва да бъдат\n"
"екранирани (напр. с „\\“).\n"
"\n"
"Вместо ЦЯЛО число може да ползвате и „-l НИЗ“, което дава дължината на "
"НИЗа.\n"

#: src/test.c:773
msgid ""
"\n"
"NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n"
"EXPR2' or 'test EXPR1 || test EXPR2' instead.\n"
msgstr ""
"\n"
"ПРЕДУПРЕЖДЕНИЕ: Двоичните „-a“ и „-o“ не са еднозначни!  Вместо тях "
"ползвайте:\n"
"„test ИЗРАЗ_1 && test ИЗРАЗ_2“ или „test ИЗРАЗ_1 || test ИЗРАЗ_2“.\n"

#: src/test.c:778
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"ПРЕДУПРЕЖДЕНИЕ: „[“ приема опциите „--help“ и „--version“, а „test“ — не!\n"
"„test“ ги обработва по същия начин както произволен друг непразен НИЗ.\n"

#: src/test.c:783
msgid "test and/or ["
msgstr "„test“ и/или „[“"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:795
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:796
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:850
#, c-format
msgid "missing %s"
msgstr "липсва „%s“"

#: src/test.c:864
#, c-format
msgid "extra argument %s"
msgstr "излишен аргумент „%s“"

#: src/timeout.c:135
#, c-format
msgid "warning: timer_settime"
msgstr "ПРЕДУПРЕЖДЕНИЕ: „timer_settime“ върна грешка"

#: src/timeout.c:140
#, c-format
msgid "warning: timer_create"
msgstr "ПРЕДУПРЕЖДЕНИЕ: „timer_create“ върна грешка"

#: src/timeout.c:207
#, c-format
msgid "sending signal %s to command %s"
msgstr "изпращане на сигнал „%s“ на командата „%s“"

#: src/timeout.c:235
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"Употреба: %s [ОПЦИЯ]… ПЕРИОД КОМАНДА [АРГУМЕНТ]…\n"
"     или: %s [ОПЦИЯ]\n"

#: src/timeout.c:239
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr ""
"Изпълнение на КОМАНДАта и последващо прекратяване, ако не е приключила при "
"изтичането на този ПЕРИОД.\n"

#: src/timeout.c:245
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                   command times out\n"
"      --foreground\n"
"                 when not running timeout directly from a shell prompt,\n"
"                   allow COMMAND to read from the TTY and get TTY signals;\n"
"                   in this mode, children of COMMAND will not be timed out\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                   this long after the initial signal was sent\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout;\n"
"                   SIGNAL may be a name like 'HUP' or a number;\n"
"                   see 'kill -l' for a list of signals\n"
msgstr ""
"      --preserve-status\n"
"                 изход със същия код както КОМАНДАта, дори и ПЕРИОДът за\n"
"                 изпълнението ѝ да изтече\n"
"      --foreground\n"
"                 да се позволява четенето от терминала и получаване на\n"
"                 терминалните сигнали дори и при изпълнение на „timeout“,\n"
"                 което не е директно от командния ред.  В този режим\n"
"                 дъщерните процеси на КОМАНДАта не се прекратяват при\n"
"                 изтичането на ПЕРИОДа\n"
"  -k, --kill-after=ИЗЧАКВАНЕ\n"
"                 изпращане и на „KILL“, ако КОМАНДАта не е приключила\n"
"                 изпълнението си, дори и след това време за ИЗЧАКВАНЕ след\n"
"                 изпращането на първоначалния сигнал\n"
"  -s, --signal=СИГНАЛ\n"
"                 СИГНАЛът, който следва да се изпрати след изтичането на\n"
"                 ПЕРИОДА за изпълнение.  Може да го укажете с име или "
"номер.\n"
"                 Пълният списък със сигнали може да получите като изпълните\n"
"                 командата „kill -l“.\n"

#: src/timeout.c:260
msgid "  -v, --verbose  diagnose to stderr any signal sent upon timeout\n"
msgstr ""
"  -v, --verbose  извеждане на стандартната грешка на изпратените сигнали\n"
"                 при изтичането на периода\n"
"                 \n"

#: src/timeout.c:266
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
"A duration of 0 disables the associated timeout.\n"
msgstr ""
"\n"
"ПЕРИОДът е число с плаваща запетая и незадължителен суфикс:\n"
"  ⁃ „s“ за секунди (стандартно при изпускане);\n"
"  ⁃ „m“ за минути;\n"
"  ⁃ „h“ за часове;\n"
"  ⁃ „d“ за дни.\n"
"Продължителност „0“ маха ограничението при изпълнение.\n"

#: src/timeout.c:271
msgid ""
"\n"
"If the command times out, and --preserve-status is not set, then exit with\n"
"status 124.  Otherwise, exit with the status of COMMAND.  If no signal\n"
"is specified, send the TERM signal upon timeout.  The TERM signal kills\n"
"any process that does not block or catch that signal.  It may be necessary\n"
"to use the KILL (9) signal, since this signal cannot be caught, in which\n"
"case the exit status is 128+9 rather than 124.\n"
msgstr ""
"\n"
"Когато периодът мине и опцията „--preserve-status“ не е зададена, кодът за\n"
"състояние при изход е 124.  Ако опцията е зададена, се ползва кодът от\n"
"командата.  Ако не е указан сигнал, при изтичане на времето се праща "
"„TERM“,\n"
"който убива процеси, които не го блокират или прихващат.  Ако това се "
"случи,\n"
"се изпраща сигнал „KILL“ (9), защото той сработва винаги.  В този случай "
"кодът\n"
"за състояние е 128+9 вместо 124.\n"

#: src/timeout.c:346 src/timeout.c:403
#, c-format
msgid "warning: sigprocmask"
msgstr "ПРЕДУПРЕЖДЕНИЕ: неуспешно изпълнение на „sigprocmask“"

#: src/timeout.c:425
#, c-format
msgid "warning: disabling core dumps failed"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: неуспешно изключване на разтоварването на паметта във файл "
"„core“"

#: src/timeout.c:544
#, c-format
msgid "error waiting for command"
msgstr "грешка при изчакване на командата"

#: src/timeout.c:555
#, c-format
msgid "the monitored command dumped core"
msgstr "изпълняваната команда разтовари паметта си във файл „core“"

#: src/timeout.c:568
#, c-format
msgid "unknown status from command (%d)"
msgstr "непознат код за състояние от командата: %d"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:310
#, c-format
msgid "invalid date format %s"
msgstr "неправилен формат за дата „%s“"

#: src/touch.c:192
#, c-format
msgid "cannot touch %s"
msgstr "не може да се изпълни „touch“ върху „%s“"

#: src/touch.c:198
#, c-format
msgid "setting times of %s"
msgstr "задава се време на „%s“"

#: src/touch.c:214
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""
"Задаване на времето за достъп и промяна на всеки от ФАЙЛовете да е "
"текущото.\n"
"\n"
"Ако ФАЙЛът не съществува, той се създава като празен файл, освен ако е "
"зададена\n"
"някоя от опциите „-c“ или „-h“.\n"
"\n"
"Ако ФАЙЛът е „-“, той се обработва по специален начин — „touch“ променя\n"
"времената на файла, към който стандартният изход е пренасочен.\n"

#: src/touch.c:226
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a                     задаване само на времето за достъп\n"
"  -c, --no-create        без създаване на файловете, ако не съществуват\n"
"  -d, --date=НИЗ         анализ на НИЗа като време и ползване вместо "
"текущото\n"
"  -f                     (пренебрегва се)\n"

#: src/touch.c:232
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference   действа върху символните връзки, вместо върху "
"сочените\n"
"                         файлове (само при системи, позволяващи промяна на\n"
"                         времевите клейма на символни връзки)\n"
"  -m                     задаване само на времето на последна промяна\n"

#: src/touch.c:238
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=ФАЙЛ   използване на времето на този ФАЙЛ вместо текущото\n"
"  -t ВРЕМЕ               ползване на [[ГГ]ГГ]ММДДччММ[.сс] вместо текущото "
"време\n"
"     --time=ВИД          задаване този ВИД време:\n"
"                           ⁃ „access“/„atime“/„use“≡„-а“: последен достъп\n"
"                           ⁃ „modify“/„mtime“≡„-m“: промяна\n"

#: src/touch.c:247
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"Опциите „-d“ и „-t“ приемат различни формати за време и дата!\n"

#: src/touch.c:336
#, c-format
msgid "cannot specify times from more than one source"
msgstr "не може да се посочват времена с повече от един източник"

#: src/touch.c:410
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: „touch %s“ e остарял вариант!  Ползвайте:\n"
"„touch -t %04ld%02d%02d%02d%02d.%02d“"

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Употреба: %s [ОПЦИЯ]… МНОЖЕСТВО_1 [МНОЖЕСТВО_2]\n"

#: src/tr.c:291
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, -C, --complement    use the complement of SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace each sequence of a repeated character\n"
"                            that is listed in the last specified SET,\n"
"                            with a single occurrence of that character\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
msgstr ""
"Заместване или отстраняване на знаци и/или повторения от стандартния вход и\n"
"извеждане на стандартния изход.\n"
"\n"
"  -c, -C, --complement    използване на допълнението на  МНОЖЕСТВО_1\n"
"  -d, --delete            отстраняване на знаците от МНОЖЕСТВО_1 без "
"заместване\n"
"  -s, --squeeze-repeats   замяна на всяка входяща последователност от един "
"и\n"
"                          същ, повтарящ се знак, член на съответното "
"МНОЖЕСТВО\n"
"                          (1 или 2), с единствен съответстващ знак\n"
"  -t, --truncate-set1     първоначално МНОЖЕСТВО_1 се съкращава до "
"дължината\n"
"                          на МНОЖЕСТВО_2\n"

#: src/tr.c:304
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"МНОЖЕСТВата се задават като низове от знаци.  Повечето представят себе си.\n"
"Поддържат се следните последователности:\n"
"\n"
"  \\NNN            знакът с осмичен код NNN (1 до 3 осмични цифри)\n"
"  \\\\              обратна наклонена черта\n"
"  \\a              звуков сигнал (BEL)\n"
"  \\b              обратно триене (backspace)\n"
"  \\f              край на страницата (form feed)\n"
"  \\n              нов ред (new line)\n"
"  \\r              връщане на курсора (return)\n"
"  \\t              хоризонтална табулация\n"

#: src/tr.c:318
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              вертикална табулация\n"
"  ЗНАК_1-ЗНАК_2   всички знаци от ЗНАК_1 до ЗНАК_2\n"
"  [ЗНАК*]         повтаряне на ЗНАКа в края на МНОЖЕСТВО_1 до достигане\n"
"                  на дължината на МНОЖЕСТВО_1\n"
"  [ЗНАК*БРОЙ]     повтаряне на ЗНАКа такъв БРОЙ пъти.  БРОят е осмично "
"число,\n"
"                  когато започва с 0\n"
"  [:alnum:]       всички букви и цифри\n"
"  [:alpha:]       всички букви\n"
"  [:blank:]       всички празни знаци\n"
"  [:cntrl:]       всички управляващи знаци\n"
"  [:digit:]       всички цифри\n"

#: src/tr.c:329
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       всички видими знаци с изключение на интервали, табулации и "
"др.\n"
"  [:lower:]       всички малки букви\n"
"  [:print:]       всички видими знаци, включително интервали, табулации\n"
"  [:punct:]       всички препинателни знаци\n"
"  [:space:]       хоризонтално или вертикално бяло поле\n"
"  [:upper:]       всички главни букви\n"
"  [:xdigit:]      всички шестнадесетични цифри\n"
"  [=ЗНАК=]        всички знаци, еквивалентни на ЗНАКа\n"

#: src/tr.c:339
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses the last\n"
"specified SET, and occurs after translation or deletion.\n"
msgstr ""
"\n"
"Замяна се извършва, само ако липсва опцията „-d“ и едновременно са зададени\n"
"МНОЖЕСТВО_1 и МНОЖЕСТВО_2.  Опцията „-t“ може да се ползва само при замяна.\n"
"Ако е по-късо, МНОЖЕСТВО_2 се допълва до МНОЖЕСТВО_1 с повтаряне на "
"последния\n"
"знак от МНОЖЕСТВО_2.  Излишните знаци от МНОЖЕСТВО_2 се пренебрегват.\n"
"Само „[:lower:]“ и „[:upper:]“ гарантирано се в ред на нарастване.  Ако "
"някой\n"
"от тези класове се ползва в МНОЖЕСТВО_2, задължително трябва да използвате\n"
"другия в МНОЖЕСТВО_1, за да се извърши смяна на регистъра.  За опцията „-s“ "
"се\n"
"използва последно указаното МНОЖЕСТВО (1 или 2) и се прилага след "
"извършването\n"
"на замяната или триенето.\n"

#: src/tr.c:507
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: нееднозначната осмична последователност: „\\%c%c%c“\n"
"                е интерпретирана като двубайтовата последователност: „\\0%c"
"%c, %c“"

#: src/tr.c:516
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ: самотна обратна наклонена черта в края на форматиращ низ"

#: src/tr.c:666
#, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr "границите на интервала „%s-%s“ са в обратен ред"

#: src/tr.c:812
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "неправилен брой повторения %s в конструкция „[c*n]“"

#: src/tr.c:888
#, c-format
msgid "missing character class name '[::]'"
msgstr "името на класа̀ знаци „[::]“ липсва"

#: src/tr.c:891
#, c-format
msgid "missing equivalence class character '[==]'"
msgstr "знакът за клас на еквивалентност „[==]“ липсва"

#: src/tr.c:906
#, c-format
msgid "invalid character class %s"
msgstr "неправилен клас от знаци „%s“"

#: src/tr.c:925
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: класът на еквивалентност трябва да се означи само един знак"

#: src/tr.c:1205
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "лошо подравнена [:upper:] и/или [:lower:] конструкция"

#: src/tr.c:1309
msgid "too many characters in set"
msgstr "множество с твърде много знаци"

#: src/tr.c:1393
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr ""
"при замяна, когато МНОЖЕСТВО_1 e по-дълго от МНОЖЕСТВО_2,\n"
"второто не трябва да завършва с клас от знаци"

#: src/tr.c:1449
msgid "the [c*] repeat construct may not appear in string1"
msgstr "конструкцията „[c*]“ не може да се появява в МНОЖЕСТВО_1"

#: src/tr.c:1459
msgid "only one [c*] repeat construct may appear in string2"
msgstr "в МНОЖЕСТВО_2 може да се среща само конструкцията за повторение „[c*]“"

#: src/tr.c:1467
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "при заместване не може да се срещат конструкции „[=c=]“ в МНОЖЕСТВО_2"

#: src/tr.c:1474
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""
"при заместване единствените класове знаци, които може да се срещат в\n"
"МНОЖЕСТВО_2 са „upper“ и „lower“"

#: src/tr.c:1489
msgid "when not truncating set1, string2 must be non-empty"
msgstr "когато МНОЖЕСТВО_1 не се съкращава, МНОЖЕСТВО_2 не може да е празно"

#: src/tr.c:1498
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"при заместване с допълващи (обратни) класове знаци, МНОЖЕСТВО_2 трябва\n"
"да покрива всички знаци от МНОЖЕСТВО_1"

#: src/tr.c:1507
msgid "the [c*] construct may appear in string2 only when translating"
msgstr ""
"конструкцията „[c*]“ може да се среща в МНОЖЕСТВО_2 само при заместване"

#: src/tr.c:1759
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr ""
"Трябва да сe посочат двe множества при едновременно изтриване на знаци и "
"отстраняване на повторения."

#: src/tr.c:1761
msgid "Two strings must be given when translating."
msgstr "При замяна трябва да се посочат двe множества."

#: src/tr.c:1771
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr ""
"Трябва да се посочи само един низ при изтриване без отстраняване на "
"повторенията."

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s [ПРЕНЕБРЕГНАТ_АРГУМЕНТ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "Завършване с код-състояние за успех."

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "Завършване с код-състояние за неуспех."

#: src/truncate.c:70
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "Употреба: %s [ОПЦИЯ]… ФАЙЛ…\n"

#: src/truncate.c:71
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the sparse extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""
"Отсичане на размера на ФАЙЛа — намаляване или увеличаването до зададения "
"размер\n"
"\n"
"Ако ФАЙЛът не съществува, се създава.\n"
"\n"
"Ако ФАЙЛът е по-голям от зададения размер, при отсичането излишните данни "
"се\n"
"губят.  Ако ФАЙЛът е по-малък, отсичането го увеличава, а рехавата, нова "
"част се\n"
"запълва с нулеви байтове.\n"

#: src/truncate.c:83
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create        без създаване на файлове\n"

#: src/truncate.c:86
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr ""
"  -o, --io-blocks        РАЗМЕРът указва броя на вх./изх. блокове, а не "
"байтове\n"

#: src/truncate.c:89
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE bytes\n"
msgstr ""
"  -r, --reference=ФАЙЛ_ЕТАЛОН\n"
"                         размерът да е същият както на ФАЙЛа_ЕТАЛОН\n"
"  -s, --size=РАЗМЕР      задаване или промяна на този РАЗМЕР байтове\n"

#: src/truncate.c:95
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""
"\n"
"РАЗМЕРът може да се предхожда от следните знаци:\n"
"  ⁃ „+“: увеличаване с;\n"
"  ⁃ „-“: намаляване с;\n"
"  ⁃ „<“: най-много;\n"
"  ⁃ „>“: поне;\n"
"  ⁃ „/“: закръгляване надолу до кратно на;\n"
"  ⁃ „%“: закръгляване нагоре до кратно на.\n"

#: src/truncate.c:124
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdPTR> byte blocks for file %s"
msgstr "препълване при %<PRIdMAX> блокове × %<PRIdPTR> байта за файла „%s“"

#: src/truncate.c:145
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "„%s“ е с неизползваем, отрицателен размер"

#: src/truncate.c:155 src/truncate.c:348
#, c-format
msgid "cannot get the size of %s"
msgstr "размерът на „%s“ не може да се отчете"

#: src/truncate.c:179
#, c-format
msgid "overflow extending size of file %s"
msgstr "препълване при увеличаване на размера на файла „%s“"

#: src/truncate.c:193
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "неуспешно отсичане на „%s“ до %<PRIdMAX> байта"

#: src/truncate.c:266
#, c-format
msgid "multiple relative modifiers specified"
msgstr "указани са множество относителни модификатори"

#: src/truncate.c:275
msgid "Invalid number"
msgstr "Неправилно число"

#: src/truncate.c:297
#, c-format
msgid "you must specify either %s or %s"
msgstr "трябва да укажете или %s, или %s"

#: src/truncate.c:304
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "трябва да укажете относителен %s с %s"

#: src/truncate.c:311
#, c-format
msgid "%s was specified but %s was not"
msgstr "„%s е указан, а %s не е"

#: src/truncate.c:368
#, c-format
msgid "cannot open %s for writing"
msgstr "„%s“ не може да се отвори за запис"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:40
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:82
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
msgstr ""
"Употреба: %s [ОПЦИЯ] [ФАЙЛ]\n"
"\n"
"Извеждане на напълно подреден списък, съвместим с частичната наредба във "
"ФАЙЛа.\n"

#: src/tsort.c:89 src/uptime.c:213
#, c-format
msgid "\n"
msgstr "\n"

#: src/tsort.c:475
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s: входните данни съдържат нечетен брой лексеми"

#: src/tsort.c:521
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: входният файл съдържа цикъл:"

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"Извеждане на името на файла на терминала, който е свързан със стандартния "
"вход.\n"
"\n"
"  -s, --silent, --quiet   без извеждане, връщане само на код-състояние\n"

#: src/tty.c:127
msgid "not a tty"
msgstr "не е „tty“"

#: src/uname.c:125
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"Извеждане на информация да системата.  Без никаква ОПЦИЯ е същото като с „-"
"s“.\n"
"\n"
"  -a, --all                извеждане на цялата информация в следния ред\n"
"                           („-p“ и „-i“ се пропускат, ако не са известни):\n"
"  -s, --kernel-name        име на ядрото\n"
"  -n, --nodename           име на компютъра в мрежата\n"
"  -r, --kernel-release     подверсия на ядрото\n"

#: src/uname.c:134
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type (non-portable)\n"
"  -i, --hardware-platform  print the hardware platform (non-portable)\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     версия на ядрото\n"
"  -m, --machine            хардуерно име на машината\n"
"  -p, --processor          вид на микропроцесора (не е преносимо)\n"
"  -i, --hardware-platform  хардуерна платформа (не е преносимо)\n"
"  -o, --operating-system   операционна система\n"

#: src/uname.c:144
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"Извеждане на архитектурата на машината.\n"
"\n"

#: src/uname.c:287
msgid "cannot get system name"
msgstr "името на системата не може да се получи"

#: src/unexpand.c:82
msgid "Convert blanks in each FILE to tabs, writing to standard output.\n"
msgstr ""
"Замяна на интервалите във всеки ФАЙЛ и извеждане на стандартния изход\n"

#: src/unexpand.c:89
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
msgstr ""
"  -a, --all        преобразуване на всички празни знаци, а не само в "
"началото\n"
"                   на редовете\n"
"      --first-only преобразуване на празните знаци само в началото на "
"редовете\n"
"                   (отменя „-a“)\n"
"  -t, --tabs=N     използване на табулации с размер N знака вместо през 8\n"
"                   (включва „-a“)\n"

#: src/unexpand.c:306
msgid "tab stop value is too large"
msgstr "табулацията е твърде дълга"

#: src/uniq.c:166
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ВХОД [ИЗХОД]]\n"

#: src/uniq.c:170
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""
"Съкращаване на последователно повтарящи се редове до един от (стандартния) "
"ВХОД и извеждане на (стандартния) ИЗХОДа.\n"
"\n"
"Без опции последователно повтарящите се редове се заменят с първия от тях.\n"

#: src/uniq.c:179
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines, one for each group\n"
msgstr ""
"  -c, --count           редовете да се предхождат от броя срещания\n"
"  -d, --repeated        извеждане само на повтарящите се редове, по\n"
"                        един от всяка група\n"

#: src/uniq.c:183
msgid ""
"  -D                    print all duplicate lines\n"
"      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
"                                 with an empty line;\n"
"                                 METHOD={none(default),prepend,separate}\n"
msgstr ""
"  -D                    извеждане на всички повтарящи се редове\n"
"      --all-repeated[=РЕЖИМ]\n"
"                        като „-D“, но се позволява разделянето на групите с\n"
"                        празен ред.  РЕЖИМът може да е „none“ (без, "
"стандартно),\n"
"                        „prepend“ (празен ред отпред), „separate“ (празен "
"ред\n"
"                        само помежду)\n"

#: src/uniq.c:189
msgid "  -f, --skip-fields=N   avoid comparing the first N fields\n"
msgstr ""
"  -f, --skip-fields=БРОЙ\n"
"                        без сравнение на този БРОЙ от първите полета\n"

#: src/uniq.c:192
msgid ""
"      --group[=METHOD]  show all items, separating groups with an empty "
"line;\n"
"                          METHOD={separate(default),prepend,append,both}\n"
msgstr ""
"      --group[=РЕЖИМ]   извеждане на всички редове, като групите се разделят "
"с\n"
"                        празен ред.  РЕЖИМът може да е „none“ (без, "
"стандартно),\n"
"                        „prepend“ (празен ред отпред), „separate“ (празен "
"ред\n"
"                        само помежду)\n"

#: src/uniq.c:196
msgid ""
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -i, --ignore-case     без разлика между главни и малки букви при "
"сравнение\n"
"  -s, --skip-chars=БРОЙ прескачане на този БРОЙ от първите знаци при "
"сравнение\n"
"  -u, --unique          извеждане само на неповтарящите се редове\n"

#: src/uniq.c:204
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr ""
"  -w, --check-chars=БРОЙ\n"
"                        сравняване на максимум този БРОЙ знаци в редовете\n"

#: src/uniq.c:209
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"Полето се състои от празни знаци (обикновено интервали и/или табулации),\n"
"следвани от непразни знаци.  Полетата се прескачат преди знаците.\n"

#: src/uniq.c:214
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
msgstr ""
"\n"
"ПРЕДУПРЕЖДЕНИЕ: „uniq“ не засича повтарящи се редове, които не са строго\n"
"последователни (не са един след друг).  Възможно е да трябва първо да "
"подредите\n"
"редовете със „sort“ или даже да използвате „sort -u“ и да не ви трябва "
"„uniq“.\n"

#: src/uniq.c:425
msgid "too many repeated lines"
msgstr "твърде много повторени редове"

#: src/uniq.c:600
msgid "invalid number of fields to skip"
msgstr "неправилен брой полета за пропускане"

#: src/uniq.c:609
msgid "invalid number of bytes to skip"
msgstr "неправилен брой байтове за пропускане"

#: src/uniq.c:619
msgid "invalid number of bytes to compare"
msgstr "неправилен брой знаци за сравняване"

#: src/uniq.c:641
#, c-format
msgid "--group is mutually exclusive with -c/-d/-D/-u"
msgstr "опцията „--group“ е несъвместима с опциите „-c“/„-d“/„-D“/„-u“"

#: src/uniq.c:648
#, c-format
msgid "grouping and printing repeat counts is meaningless"
msgstr "групирането и извеждането на броя повторения е безсмислено"

#: src/uniq.c:655
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"извеждането на всички повтарящи се редове и броя повторения е безсмислено"

#: src/unlink.c:45
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s ФАЙЛ\n"
"     или: %s ФАЙЛ\n"

#: src/unlink.c:48
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"Изтриване на посочения ФАЙЛ посредством системната функция „unlink“.\n"
"\n"

#: src/uptime.c:126
msgid "couldn't get boot time"
msgstr "не може да се получи времето на начално зареждане"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:137
msgid " %H:%M:%S  "
msgstr " %H:%M:%S  "

#: src/uptime.c:139
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:141
#, c-format
msgid "up ???? days ??:??,  "
msgstr "???? дена ??:??,  "

#: src/uptime.c:145
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "%ld ден %2d:%02d,  "
msgstr[1] "%ld дни %2d:%02d,  "

#: src/uptime.c:150
#, c-format
msgid "up  %2d:%02d,  "
msgstr "  %2d:%02d,  "

#: src/uptime.c:152
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "%lu потребител"
msgstr[1] "%lu потребители"

#: src/uptime.c:162
#, c-format
msgid ",  load average: %.2f"
msgstr ",  средно натоварване: %.2f"

#: src/uptime.c:200
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"Извеждане на текущото време, продължителността на времето, през което "
"системата е била\n"
"стартирана, броя потребители, използващи в момента системата, и средния брой "
"задачи\n"
"в опашката на многозадачния диспечер през последните 1, 5 и 15 минути."

#: src/uptime.c:209
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr ""
"  Процесите, които спят,\n"
"  но не могат да бъдат прекъснати, също се броят в средното натоварване.\n"

#: src/uptime.c:215
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Ако не е посочен ФАЙЛ, се използва „%s“.  Най-често за ФАЙЛ се ползва „%s“.\n"

#: src/users.c:106
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"Извеждане кой в момента е влязъл в системата според ФАЙЛ.\n"
"Ако не е посочен ФАЙЛ, се използва „%s“. Често ФАЙЛ е „%s“.\n"
"\n"

#: src/wc.c:123
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  A word is a non-zero-length sequence of\n"
"characters delimited by white space.\n"
msgstr ""
"Извеждане на броя на новите редове, думи и байтове във всеки ФАЙЛ, както и\n"
"обща статистика, ако е посочен повече от един ФАЙЛ.  За дума се счита всяка\n"
"последователност от непразни знаци, разделени с празни като табулации,\n"
"интервали и др.\n"
"  -c, --bytes            извеждане на броя байтове\n"
"  -m, --chars            извеждане на броя букви\n"
"  -l, --lines            извеждане на броя редове\n"

#: src/wc.c:131
msgid ""
"\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"\n"
"Опциите по-долу определят кои статистики от следните, точно в този ред, се\n"
"извеждат: нови редове, думи, знаци, байтове, максимална дължина на ред.\n"
"  -c, --bytes            извеждане на броя на байтовете\n"
"  -m, --chars            извеждане на броя на знаците\n"
"  -l, --lines            извеждане на броя на новите редове\n"

#: src/wc.c:139
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the maximum display width\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=ФАЙЛ четене на файловете, чиито имена са изредени в "
"този\n"
"                         ФАЙЛ, като всяко име завършва с нулев байт.  Ако\n"
"                         ФАЙЛът е „-“, се чете от стандартния вход\n"
"  -L, --max-line-length  извеждане на дължината на най-дългия ред\n"
"  -w, --words            извеждане на броя думи\n"

#: src/who.c:213
msgid " old "
msgstr " стар "

#: src/who.c:443
msgid "system boot"
msgstr "стартиране на системата"

#: src/who.c:451 src/who.c:453
msgid "id="
msgstr "id="

#: src/who.c:466 src/who.c:471
msgid "term="
msgstr "терм="

#: src/who.c:468 src/who.c:472
msgid "exit="
msgstr "изход="

#: src/who.c:489
msgid "LOGIN"
msgstr "ВХОД"

#: src/who.c:509
msgid "clock change"
msgstr "смяна на часа"

#: src/who.c:521 src/who.c:522
msgid "run-level"
msgstr "старт-ниво"

#: src/who.c:525 src/who.c:526
msgid "last="
msgstr "посл="

#: src/who.c:557
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"брой потребители - %lu\n"

#: src/who.c:563
msgid "NAME"
msgstr "ИМЕ"

#: src/who.c:563
msgid "LINE"
msgstr "ЛИНИЯ"

#: src/who.c:563
msgid "TIME"
msgstr "ВРЕМЕ"

#: src/who.c:563
msgid "IDLE"
msgstr "АЙЛЯК"

#: src/who.c:564
msgid "PID"
msgstr "PID"

#: src/who.c:564
msgid "COMMENT"
msgstr "КОМЕНТАР"

#: src/who.c:564
msgid "EXIT"
msgstr "ИЗХОД"

#: src/who.c:644
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "Употреба: %s [ОПЦИЯ]… [ ФАЙЛ | АРГУМЕНТ_1 АРГУМЕНТ_2 ]\n"

#: src/who.c:645
msgid "Print information about users who are currently logged in.\n"
msgstr "Извеждане на информация кой в момента е влязъл в системата.\n"

#: src/who.c:648
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all         същото като „-b -d --login -p -r -t -T -u“\n"
"  -b, --boot        времето на последното начално зареждане\n"
"  -d, --dead        извеждане на броя умрели процеси\n"
"  -H, --heading     извеждане на заглавен ред\n"

#: src/who.c:655
msgid "  -l, --login       print system login processes\n"
msgstr "  -l, --login       извеждане на процесите за влизане в системата\n"

#: src/who.c:658
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup      опит за извеждане на канонични мрежови имена на "
"компютрите\n"
"                    чрез DNS\n"
"  -m                само мрежовото име и потребителя, свързан на "
"стандартния\n"
"                    вход\n"
"  -p, --process     активни процеси, породени от „init“\n"

#: src/who.c:663
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       извеждане на всички входни имена и броя на влезлите\n"
"                    потребители\n"
"  -r, --runlevel    извеждане на текущото ниво на стартиране\n"
"  -s, --short       извеждане само на името, линията и времето (по "
"подразбиране)\n"
"  -t, --time        извеждане на последната промяна на системния часовник\n"

#: src/who.c:669
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    добавяне на състоянието на „mesg“ на потребителите\n"
"                    („+“, „-“ или „?“)\n"
"  -u, --users       извеждане на потребителите, влезли в системата\n"
"      --message     същото като „-T“\n"
"      --writable    същото като „-T“\n"

#: src/who.c:677
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""
"\n"
"Ако не е посочен ФАЙЛ, се използва „%s“.  Често ФАЙЛ е „%s“.\n"
"Ако са посочени АРГУМЕНТ_1 АРГУМЕНТ_2, се предполага „-m“:\n"
"обичайни са „am i“ и „съм аз“.\n"

#: src/whoami.c:45
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"Извежда името текущия действителен (effective) потребител.\n"
"Същото като id -un.\n"
"\n"

#: src/whoami.c:86
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "не може да се намери името на потребител №%lu"

#: src/yes.c:41
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"Употреба: %s [НИЗ]…\n"
"     или: %s ОПЦИЯ\n"

#: src/yes.c:47
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
"Непрекъснато извеждане на ред от посочените НИЗ(ове) или „y“.\n"
"\n"
