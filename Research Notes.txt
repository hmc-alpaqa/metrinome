docker run -it -v /home/gabe/Documents/repos/path-complexity/src:/app/code 0
5f0e7a90b2c /bin/bash

OR 

docker run -it -v /home/gabe/Documents/repos/path-complexity/src:/app/code 0
5f0e7a90b2c /usr/bin/zsh 

docker build -f c:\users\gabe\desktop\path-complexity\Dockerfile.dev .
docker container ls 
docker kill <id>

java -classpath './javacfg/analysis/:commons-cli-1.2.jar:asm-all-5.0.3.jar:commons-io-2.4.jar' ./javacfg/Extractor.java

File -> Project Structure -> Project Settings -> Modules -> "Your Module Name" -> Sources -> Language Level 
    - Temporarily fixes the compilation issue, but should change this in Maven 

To make the jar, call 'mvn package' 

The class reader ONLY WORKS for .class files 

Look at these lectures: 
https://www.prismmodelchecker.org/lectures/

KLEE Tutorial: 
https://klee.github.io/tutorials/testing-function/
(1) Make the variables symbolic 
    --> klee_make_symbolic(&a, sizeof(a), "a");
(2) Include KLEE: #include <klee/klee.h>
(3) clang-6.0 -I /app/klee/include -emit-llvm -c -g -O0 -Xclang -disable-O0-optnone get_sign.c
(4) Take the .bc file 
(5) Execute klee on this file. 
(6) It puts the result in klee-out-<number> where number starts at 0 and increases. Sample stdout 
result: 

KLEE: output directory is "/app/examples/src/klee-out-0"
KLEE: Using Z3 solver backend

KLEE: done: total instructions = 33 
KLEE: done: completed paths = 3 
KLEE: done: generated tests = 3 

Current TODO: 

1. Can we collect info: # constraints analyzed, # tests made, amount of memory used.
    -> things that describe performance.
    
    Can currently collect number of tests made from .bc file. 

2. Then try to correlate path complexity metric and KLEE stuff.
3. Find some large dataset in C++ (Boost library, other popular libraries) [done]
    Start with: 
    - Boost
    - OpenCV [https://opencv.org/releases/]
    - OpenMP
    More Available At: https://en.cppreference.com/w/cpp/links/libs
    Good source for C repos: https://github.com/trending/c

4. Ask ishaan how he got those branch conditions (Python probably easiest, 
    maybe look at C++ one to get branch conditions).
5. Memoize / dynamic programming approach for NPATH.
    -> Is there way to automatically convert recursive thing to dynamic programming.
6. Write some unit tests + making sure that everything is setup correctly [WIP].
7. Try to write some things about the tool [WIP].
8. configure additional parameters (like getting support
for POSIX runtime as given by the previous steps).
9. Would be cool to use Github actions (one is currently set up on Pull requests) to run the Unit 
tests automatically and give the result.

Other Notes:     
1. Use Python binding for z3.
